<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Pipeviz</title>
        <link rel="icon" href="https://raw.githubusercontent.com/mattlianje/d4/master/pix/pipeviz.png" />
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script src="https://unpkg.com/@hpcc-js/wasm@2.13.0/dist/graphviz.umd.js"></script>
        <script src="https://unpkg.com/d3-graphviz@5.0.2/build/d3-graphviz.min.js"></script>
        <style>
            :root {
                --bg-primary: #fff;
                --bg-secondary: #f5f5f5;
                --bg-code: #f5f5f5;
                --text-primary: #000;
                --text-secondary: #666;
                --text-muted: #828282;
                --border-color: #ccc;
                --border-light: #eee;
            }
            [data-theme='dark'] {
                --bg-primary: #1a1a1a;
                --bg-secondary: #252525;
                --bg-code: #2d2d2d;
                --text-primary: #e0e0e0;
                --text-secondary: #aaa;
                --text-muted: #888;
                --border-color: #444;
                --border-light: #333;
            }
            html {
                overflow-y: scroll;
            }
            /* Prevent modal from causing body padding jitter */
            body.modal-open {
                padding-right: 0 !important;
            }
            .modal-backdrop {
                width: 100% !important;
            }
            body {
                background-color: var(--bg-primary);
                min-height: 100vh;
                font-family: Verdana, Geneva, sans-serif;
                font-size: 13px;
                color: var(--text-primary);
            }
            .hero-section {
                background: var(--bg-primary);
                margin: 1rem auto;
                padding: 1.5rem 4rem;
                max-width: 1600px;
            }
            @media (max-width: 768px) {
                .hero-section {
                    padding: 1.5rem 1.5rem;
                }
                .feature-grid {
                    grid-template-columns: 1fr !important;
                }
            }
            .nav-tabs {
                border-bottom: 1px solid var(--border-color);
                margin-bottom: 1.5rem;
            }
            .nav-tabs .nav-link {
                border: none;
                color: var(--text-muted);
                font-weight: 400;
                padding: 6px 12px;
                margin-right: 2px;
                background: transparent;
                border-radius: 0;
                font-size: 12px;
            }
            .nav-tabs .nav-link:hover {
                color: var(--text-primary);
                background-color: var(--bg-secondary);
            }
            .nav-tabs .nav-link.active {
                background-color: var(--bg-primary);
                color: var(--text-primary);
                border-bottom: 2px solid var(--text-primary);
            }
            .nav-tabs.hidden-on-home {
                display: none;
            }
            .nav-separator {
                width: 1px;
                background: var(--border-color);
                margin: 8px 6px;
                opacity: 0.5;
            }
            @media (max-width: 768px) {
                .nav-separator {
                    display: none;
                }
            }
            .card {
                border: none;
                border-radius: 0;
                box-shadow: none;
                background: transparent;
            }
            .card-body {
                padding: 0;
            }
            .table-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .table {
                background: var(--bg-primary);
                font-size: 13px;
                border-collapse: collapse;
                table-layout: fixed;
                width: 100%;
                min-width: 900px;
            }
            .table th {
                background-color: var(--bg-secondary);
                border-bottom: 1px solid var(--border-color);
                font-weight: bold;
                color: var(--text-primary);
                white-space: nowrap;
                font-size: 11px;
            }
            .table td {
                border-bottom: 1px solid var(--border-light);
                vertical-align: top;
                color: var(--text-primary);
                overflow: hidden;
            }
            .table td > div {
                overflow-x: auto;
            }
            .table .col-sources > div,
            .table .col-tags > div {
                white-space: normal;
            }
            .table .col-sources .badge,
            .table .col-tags .badge {
                display: block;
                width: fit-content;
                margin-bottom: 2px;
            }
            .table tr:last-child td {
                border-bottom: none;
            }
            .table .col-name {
                width: 200px;
                font-size: 0.85em;
            }
            .table .col-desc {
                width: 250px;
                font-size: 0.8em;
            }
            .table .col-schedule {
                width: 100px;
            }
            .table .col-sources {
                width: 340px;
            }
            .table .col-cluster {
                width: 120px;
            }
            .table .col-tags {
                width: 160px;
            }
            .table .col-links {
                width: 140px;
            }
            .links-scroll {
                display: flex;
                flex-wrap: wrap;
                gap: 3px;
            }
            .links-scroll a {
                white-space: nowrap;
            }
            .table .col-owner {
                width: 180px;
            }
            .table .col-metadata {
                width: 200px;
            }
            .badge {
                font-weight: normal;
                font-size: 11px;
                padding: 2px 5px;
                border-radius: 2px;
                display: inline-block;
                margin-bottom: 2px;
            }
            .badge-snowflake {
                background-color: #e8f4fd;
                color: #0366d6;
                border: 1px solid #0366d6;
            }
            .badge-delta {
                background-color: #fff3e0;
                color: #e65100;
                border: 1px solid #e65100;
            }
            .badge-s3 {
                background-color: #fff8e1;
                color: #f57c00;
                border: 1px solid #f57c00;
            }
            .badge-api {
                background-color: #e8f5e9;
                color: #2e7d32;
                border: 1px solid #2e7d32;
            }
            .badge-database {
                background-color: #f3e5f5;
                color: #7b1fa2;
                border: 1px solid #7b1fa2;
            }
            .badge-tag {
                background-color: #fff3e0;
                color: #e65100;
                border: 1px solid #e65100;
            }
            .badge-cluster {
                background-color: #e3f2fd;
                color: #1565c0;
                border: 1px solid #1565c0;
            }
            .graph-container {
                background: var(--bg-primary);
                min-height: 500px;
                position: relative;
                border: 1px solid var(--border-color);
                overflow: hidden;
            }
            .graph-container svg {
                max-width: 100%;
            }
            .graph-controls {
                position: absolute;
                top: 10px;
                left: 10px;
                right: 10px;
                z-index: 10;
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
                align-items: center;
            }
            .analysis-toggle {
                display: flex;
                align-items: center;
                gap: 6px;
            }
            .analysis-toggle input {
                display: none;
            }
            .graph-ctrl-btn {
                padding: 4px 10px;
                font-size: 11px;
                border: 1px solid var(--border-color);
                border-radius: 3px;
                cursor: pointer;
                background: var(--bg-primary);
                color: var(--text-secondary);
                transition: all 0.15s;
                font-family: inherit;
            }
            .graph-ctrl-btn:hover {
                border-color: var(--text-muted);
                color: var(--text-primary);
            }
            .graph-ctrl-btn:active {
                background: var(--bg-secondary);
            }
            .graph-ctrl-btn.danger {
                border-color: #c98b8b;
                color: #c98b8b;
            }
            .graph-ctrl-btn.danger:hover {
                background: #fbe9e7;
                border-color: #c98b8b;
                color: #8b5a5a;
            }
            [data-theme='dark'] .graph-ctrl-btn.danger:hover {
                background: rgba(201, 139, 139, 0.15);
                color: #e0a0a0;
            }
            .node-actions {
                display: flex;
                flex-wrap: wrap;
                gap: 6px;
                margin: 10px 0;
            }
            .format-toggle {
                display: flex;
                gap: 4px;
            }
            .export-format-btn.active,
            .backfill-view-btn.active {
                background: #e3f2fd;
                border-color: #2196f3;
                color: #1565c0;
            }
            [data-theme='dark'] .export-format-btn.active,
            [data-theme='dark'] .backfill-view-btn.active {
                background: rgba(33, 150, 243, 0.2);
                color: #90caf9;
            }
            .backfill-view-btn.danger.active {
                background: #fbe9e7;
                border-color: #c98b8b;
                color: #8b5a5a;
            }
            [data-theme='dark'] .backfill-view-btn.danger.active {
                background: rgba(201, 139, 139, 0.15);
                color: #e0a0a0;
            }
            #pipelines-only-btn.active,
            #collapse-all-btn.active {
                background: #e3f2fd;
                border-color: #2196f3;
                color: #1565c0;
            }
            [data-theme='dark'] #pipelines-only-btn.active,
            [data-theme='dark'] #collapse-all-btn.active {
                background: rgba(33, 150, 243, 0.2);
                color: #90caf9;
            }
            .analysis-toggle label {
                display: flex;
                align-items: center;
                gap: 4px;
                padding: 4px 10px;
                font-size: 11px;
                border: 1px solid var(--border-color);
                border-radius: 3px;
                cursor: pointer;
                background: var(--bg-primary);
                color: var(--text-secondary);
                transition: all 0.15s;
            }
            .analysis-toggle label:hover {
                border-color: var(--text-muted);
            }
            #cp-toggle:checked + label {
                background: #fce4ec;
                border-color: #d63384;
                color: #ad1457;
            }
            [data-theme='dark'] #cp-toggle:checked + label {
                background: rgba(214, 51, 132, 0.2);
                color: #f48fb1;
            }
            #cost-toggle:checked + label {
                background: #e8f5e9;
                border-color: #66bb6a;
                color: #2e7d32;
            }
            [data-theme='dark'] #cost-toggle:checked + label {
                background: rgba(102, 187, 106, 0.2);
                color: #a5d6a7;
            }
            .cp-indicator,
            .cost-indicator {
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: #ccc;
            }
            #cp-toggle:checked + label .cp-indicator {
                background: #d63384;
                box-shadow: 0 0 6px #d63384;
            }
            #cost-toggle:checked + label .cost-indicator {
                background: #66bb6a;
                box-shadow: 0 0 6px #66bb6a;
            }
            #graph svg {
                width: 100%;
                height: 500px;
            }
            .legend {
                position: absolute;
                bottom: 10px;
                left: 10px;
                background: var(--bg-primary);
                padding: 8px 12px;
                font-size: 11px;
                max-width: 160px;
                opacity: 0.9;
                color: var(--text-primary);
            }
            .json-editor {
                font-family: monospace;
                font-size: 12px;
                border: 1px solid var(--border-color);
                border-radius: 2px;
                background: var(--bg-primary);
                color: var(--text-primary);
            }
            .json-editor:focus {
                border-color: var(--text-muted);
                box-shadow: none;
                outline: none;
            }
            .node-highlighted {
                stroke: #e65100 !important;
                stroke-width: 3px !important;
                filter: drop-shadow(0 0 4px rgba(230, 81, 0, 0.4));
            }
            .node-highlighted polygon,
            .node-highlighted ellipse,
            .node-highlighted path {
                fill: #fff3e0 !important;
            }
            .node-highlighted text {
                font-weight: normal !important;
                fill: #000;
                stroke: none !important;
                stroke-width: 0 !important;
            }
            .node-highlighted text[fill='#d63384'] {
                fill: #d63384 !important;
            }
            .node-connected {
                stroke: #7b1fa2 !important;
                stroke-width: 1.5px !important;
            }
            .node-connected text {
                font-weight: normal !important;
                fill: #000;
                stroke: none !important;
                stroke-width: 0 !important;
            }
            .node-connected text[fill='#d63384'] {
                fill: #d63384 !important;
            }
            .node-dimmed {
                opacity: 0.35 !important;
                transition: opacity 0.2s ease;
            }
            .node-critical-path {
                filter: drop-shadow(0 0 8px rgba(214, 51, 132, 0.6)) drop-shadow(0 0 3px rgba(214, 51, 132, 0.8));
            }
            .node-critical-path polygon,
            .node-critical-path ellipse,
            .node-critical-path path {
                stroke: #d63384 !important;
                stroke-width: 2px !important;
            }
            .edge-critical-path path {
                stroke: #d63384 !important;
                stroke-width: 2.5px !important;
            }
            .edge-critical-path polygon {
                stroke: #d63384 !important;
                fill: #d63384 !important;
            }
            .node-costliest-path {
                filter: drop-shadow(0 0 8px rgba(102, 187, 106, 0.6)) drop-shadow(0 0 3px rgba(102, 187, 106, 0.8));
            }
            .node-costliest-path polygon,
            .node-costliest-path ellipse,
            .node-costliest-path path {
                stroke: #66bb6a !important;
                stroke-width: 2px !important;
            }
            .edge-costliest-path path {
                stroke: #66bb6a !important;
                stroke-width: 2.5px !important;
            }
            .edge-costliest-path polygon {
                stroke: #66bb6a !important;
                fill: #66bb6a !important;
            }
            .edge-highlighted {
                stroke: #7b1fa2 !important;
                stroke-width: 1.5px !important;
            }
            .edge-dimmed {
                opacity: 0.18 !important;
                transition: opacity 0.2s ease;
            }
            .cluster-highlighted > polygon,
            .cluster-highlighted > path {
                stroke: #e65100 !important;
                stroke-width: 3px !important;
                filter: drop-shadow(0 0 4px rgba(230, 81, 0, 0.4));
                fill: #fff3e0 !important;
            }
            .cluster-connected > polygon,
            .cluster-connected > path {
                stroke: #7b1fa2 !important;
                stroke-width: 1.5px !important;
            }
            .cluster-dimmed {
                opacity: 0.35 !important;
                transition: opacity 0.2s ease;
            }
            .node-tooltip {
                position: absolute;
                background: #000;
                color: #fff;
                padding: 6px 8px;
                font-size: 11px;
                pointer-events: none;
                z-index: 1000;
                max-width: 280px;
                white-space: pre-line;
            }
            .node {
                cursor: pointer;
                transition: all 0.2s ease;
            }
            .node:hover {
                stroke-width: 2px !important;
                filter: drop-shadow(0 0 4px rgba(0, 0, 0, 0.3));
            }
            .node:hover text {
                font-weight: normal !important;
                fill: #000 !important;
                stroke: none !important;
                stroke-width: 0 !important;
            }
            .node-details-panel {
                background: var(--bg-primary);
                padding: 1rem;
                min-height: 500px;
                max-height: 500px;
                overflow-y: auto;
                overflow-x: auto;
            }
            .node-details-panel .detail-value,
            .node-details-panel .lineage-link {
                white-space: nowrap;
            }
            .node-details-panel h5 {
                color: var(--text-primary);
                margin-bottom: 1rem;
                padding-bottom: 0.5rem;
                border-bottom: 1px solid var(--border-color);
                font-weight: bold;
                font-size: 13px;
            }
            .node-details-panel .detail-label {
                font-size: 10px;
                color: var(--text-muted);
                font-weight: bold;
                margin-bottom: 0.25rem;
            }
            .node-details-panel .detail-value {
                margin-bottom: 1rem;
                font-size: 12px;
                color: var(--text-primary);
            }
            .lineage-link {
                margin-bottom: 4px;
                cursor: pointer;
                color: #0366d6;
            }
            .lineage-link:hover {
                text-decoration: underline;
            }
            [data-theme='dark'] .lineage-link {
                color: #58a6ff;
            }
            .lineage-view-toggle {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 0.75rem;
                margin-top: 0.5rem;
                font-size: 10px;
                color: var(--text-muted);
            }
            .lineage-toggle-label {
                opacity: 0.6;
                transition: opacity 0.2s;
            }
            .lineage-toggle-label.active {
                opacity: 1;
                color: var(--text-primary);
            }
            .lineage-toggle-slider {
                position: relative;
                width: 32px;
                height: 16px;
                background: var(--border-color);
                border-radius: 8px;
                cursor: pointer;
                transition: background 0.2s;
            }
            .lineage-toggle-slider::after {
                content: '';
                position: absolute;
                top: 2px;
                left: 2px;
                width: 12px;
                height: 12px;
                background: var(--bg-primary);
                border-radius: 50%;
                transition: transform 0.2s;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            }
            .lineage-toggle-slider.json-active {
                background: var(--text-muted);
            }
            .lineage-toggle-slider.json-active::after {
                transform: translateX(16px);
            }
            .lineage-json-pre {
                font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
                font-size: 10px;
                line-height: 1.4;
                background: var(--bg-code);
                border: 1px solid var(--border-light);
                padding: 0.75rem;
                margin: 0;
                overflow-x: auto;
                white-space: pre;
                max-height: 400px;
                overflow-y: auto;
                color: var(--text-primary);
            }
            [data-theme='dark'] .lineage-json-pre {
                background: #1e1e1e;
                border-color: #333;
            }
            .export-format-btn.active {
                background: var(--text-primary) !important;
                color: var(--bg-primary) !important;
                border-color: var(--text-primary) !important;
            }
            .export-output-container {
                position: relative;
            }
            .export-output {
                font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
                font-size: 11px;
                line-height: 1.5;
                background: var(--bg-code);
                border: 1px solid var(--border-color);
                padding: 2.5rem 1rem 1rem 1rem;
                margin: 0;
                height: 520px;
                overflow: auto;
                white-space: pre;
                color: var(--text-primary);
            }
            .export-copy-btn {
                position: absolute;
                top: 8px;
                right: 8px;
                background: var(--bg-secondary);
                border: 1px solid var(--border-color);
                border-radius: 4px;
                padding: 4px 8px;
                cursor: pointer;
                opacity: 0.6;
                transition:
                    opacity 0.15s,
                    background 0.15s;
                color: var(--text-secondary);
                display: flex;
                align-items: center;
                gap: 4px;
                font-size: 10px;
            }
            .export-copy-btn:hover {
                opacity: 1;
                background: var(--bg-primary);
            }
            .export-copy-btn.copied {
                opacity: 1;
                color: #2e7d32;
            }
            .backfill-graph-container {
                border: 1px solid var(--border-color);
                background: var(--bg-primary);
                min-height: 450px;
                overflow: hidden;
            }
            .backfill-graph {
                width: 100%;
                height: 450px;
                overflow: hidden;
            }
            .backfill-graph svg {
                width: 100%;
                height: 100%;
            }
            .backfill-view-btn.active {
                background: var(--text-primary) !important;
                color: var(--bg-primary) !important;
                border-color: var(--text-primary) !important;
            }
            .backfill-hint {
                font-size: 11px;
                color: var(--text-muted);
                margin-bottom: 0.75rem;
                font-style: italic;
            }
            .backfill-pipeline-picker {
                position: relative;
            }
            @media (max-width: 768px) {
                .backfill-view-btn {
                    font-size: 11px !important;
                    padding: 4px 8px !important;
                }
            }
            @media (max-width: 576px) {
                #backfill-pane .card-body > .d-flex.justify-content-between {
                    flex-direction: column;
                    align-items: flex-start !important;
                    gap: 0.75rem;
                }
                #backfill-pane .card-body > .d-flex.justify-content-between > .d-flex {
                    width: 100%;
                    flex-wrap: wrap;
                    gap: 0.5rem;
                }
                #backfill-pane .btn-group {
                    width: 100%;
                    display: flex;
                }
                #backfill-pane .btn-group .backfill-view-btn {
                    flex: 1;
                    font-size: 10px !important;
                    padding: 6px 4px !important;
                    white-space: nowrap;
                }
                .backfill-pipeline-picker {
                    flex: 1;
                    min-width: 0;
                }
                .backfill-picker-dropdown {
                    position: fixed !important;
                    top: auto !important;
                    bottom: 0 !important;
                    left: 0 !important;
                    right: 0 !important;
                    min-width: 100% !important;
                    max-height: 55vh !important;
                    border-radius: 12px 12px 0 0 !important;
                }
            }
            .backfill-picker-dropdown {
                display: none;
                position: absolute;
                top: 100%;
                right: 0;
                background: var(--bg-primary);
                border: 1px solid var(--border-color);
                border-radius: 4px;
                width: 280px;
                max-height: 380px;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            }
            .backfill-picker-dropdown.show {
                display: block;
            }
            .backfill-picker-search {
                padding: 8px;
                border-bottom: 1px solid var(--border-light);
            }
            .backfill-picker-search input {
                width: 100%;
                padding: 6px 10px;
                border: 1px solid var(--border-color);
                border-radius: 4px;
                font-size: 12px;
                background: var(--bg-secondary);
                color: var(--text-primary);
            }
            .backfill-picker-search input:focus {
                outline: none;
                border-color: var(--accent-color);
            }
            .backfill-picker-search input::placeholder {
                color: var(--text-muted);
            }
            .backfill-picker-list {
                max-height: 260px;
                overflow-y: auto;
                padding: 0.25rem 0;
            }
            .backfill-picker-item {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 6px 12px;
                cursor: pointer;
                font-size: 12px;
                color: var(--text-primary);
                transition: background 0.1s;
            }
            .backfill-picker-item:hover {
                background: var(--bg-secondary);
            }
            .backfill-picker-item.hidden {
                display: none;
            }
            .backfill-picker-item input {
                margin: 0;
                cursor: pointer;
            }
            .picker-ds-tag {
                margin-left: auto;
                font-size: 9px;
                color: var(--text-muted);
                background: var(--bg-secondary);
                padding: 1px 5px;
                border-radius: 3px;
                opacity: 0.7;
            }
            .backfill-picker-group {
                font-size: 10px;
                font-weight: bold;
                color: var(--text-muted);
                padding: 8px 12px 4px;
                text-transform: uppercase;
            }
            .backfill-picker-group.hidden {
                display: none;
            }
            .backfill-picker-footer {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 6px 12px;
                border-top: 1px solid var(--border-light);
                font-size: 11px;
                color: var(--text-muted);
            }
            .backfill-picker-clear {
                background: none;
                border: none;
                color: var(--text-muted);
                font-size: 11px;
                cursor: pointer;
                padding: 2px 6px;
                border-radius: 3px;
            }
            .backfill-picker-clear:hover {
                color: var(--text-primary);
                background: var(--bg-secondary);
            }
            .node-details-panel .detail-value:last-child {
                margin-bottom: 0;
            }
            .node-details-panel .links-section {
                margin-top: 1rem;
                padding-top: 1rem;
                border-top: 1px solid #eee;
            }
            .node-details-panel .link-btn {
                display: inline-block;
                margin-right: 0.5rem;
                margin-bottom: 0.5rem;
                border-color: var(--border-color);
                color: var(--text-secondary);
                background: var(--bg-secondary);
            }
            .node-details-panel .link-btn:hover {
                background-color: var(--text-secondary);
                border-color: var(--text-secondary);
                color: var(--bg-primary);
            }
            [data-theme='dark'] .node-details-panel .link-btn {
                border-color: #666;
                color: #ccc;
                background: #333;
            }
            [data-theme='dark'] .node-details-panel .link-btn:hover {
                background-color: #888;
                border-color: #888;
                color: #fff;
            }
            .search-results-dropdown {
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: var(--bg-primary);
                border: 1px solid var(--border-color);
                border-top: none;
                max-height: 300px;
                overflow-y: auto;
                z-index: 100;
                display: none;
            }
            .search-results-dropdown.show {
                display: block;
            }
            .search-result-item {
                padding: 6px 10px;
                cursor: pointer;
                border-bottom: 1px solid var(--border-light);
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 12px;
                color: var(--text-primary);
            }
            .search-result-item:last-child {
                border-bottom: none;
            }
            .search-result-item:hover,
            .search-result-item.selected {
                background-color: var(--bg-secondary);
            }
            .search-result-item .result-type {
                font-size: 9px;
                padding: 2px 4px;
                text-transform: uppercase;
                font-weight: 600;
                letter-spacing: 0.5px;
            }
            .search-result-item .result-type.pipeline {
                background-color: #e3f2fd;
                color: #1565c0;
                border: 1px solid #1565c0;
            }
            .search-result-item .result-type.datasource {
                background-color: #f3e5f5;
                color: #7b1fa2;
                border: 1px solid #7b1fa2;
            }
            .search-result-item .result-name {
                font-weight: 400;
            }
            .search-result-item .result-match {
                color: #d84315;
                font-weight: 600;
            }
            .btn {
                border-radius: 0;
                font-size: 12px;
                font-weight: 400;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            .btn-primary {
                background-color: #333;
                border-color: #333;
                color: #fff;
            }
            .btn-primary:hover {
                background-color: #000;
                border-color: #000;
                color: #fff;
            }
            .btn-outline-primary {
                color: #333;
                border-color: #333;
            }
            .btn-outline-primary:hover {
                background-color: #333;
                border-color: #333;
                color: #fff;
            }
            .btn-outline-secondary {
                color: #666;
                border-color: #999;
            }
            .btn-outline-secondary:hover {
                background-color: #666;
                border-color: #666;
                color: #fff;
            }
            .btn-outline-warning {
                color: #b45309;
                border-color: #b45309;
            }
            .btn-outline-warning:hover {
                background-color: #b45309;
                border-color: #b45309;
                color: #fff;
            }
            .btn-outline-info {
                color: #0369a1;
                border-color: #0369a1;
            }
            .btn-outline-info:hover {
                background-color: #0369a1;
                border-color: #0369a1;
                color: #fff;
            }
            .hero-title {
                color: var(--text-primary);
                font-weight: bold;
                font-size: 2.5rem;
                margin-bottom: 0.5rem;
                letter-spacing: -0.5px;
            }
            .header-controls {
                display: flex;
                justify-content: flex-end;
                align-items: center;
                gap: 12px;
                margin-bottom: 0.5rem;
            }
            .link-icon {
                text-decoration: none;
                padding: 4px 8px;
                background: var(--bg-secondary);
                border: 1px solid var(--border-color);
                color: var(--text-secondary);
                font-size: 12px;
                margin: 2px;
                display: inline-block;
            }
            .link-icon:hover {
                background: #555;
                border-color: #555;
                color: #fff;
            }
            [data-theme='dark'] .link-icon {
                background: #333;
                border-color: #555;
                color: #ccc;
            }
            [data-theme='dark'] .link-icon:hover {
                background: #666;
                border-color: #666;
                color: #fff;
            }
            .form-control,
            .form-select {
                border-radius: 0;
                border: 1px solid var(--border-color);
                font-size: 13px;
                background-color: var(--bg-primary);
                color: var(--text-primary);
            }
            .form-control:focus,
            .form-select:focus {
                border-color: var(--text-muted);
                box-shadow: none;
                background-color: var(--bg-primary);
                color: var(--text-primary);
            }
            .form-control::placeholder {
                color: var(--text-muted);
            }
            .alert {
                border-radius: 0;
                font-size: 13px;
            }
            .alert-info {
                background-color: #f5f5f5;
                border: 1px solid #ccc;
                color: #333;
            }
            .alert-success {
                background-color: #e8f5e9;
                border: 1px solid #4caf50;
                color: #2e7d32;
            }
            .alert-danger {
                background-color: #ffebee;
                border: 1px solid #f44336;
                color: #c62828;
            }
            .alert-warning {
                background-color: #fff8e1;
                border: 1px solid #ff9800;
                color: #e65100;
            }
            .text-muted {
                color: var(--text-secondary) !important;
            }
            .lead {
                color: var(--text-muted);
                font-size: 12px;
            }
            .theme-toggle {
                background: none;
                border: 1px solid var(--border-color);
                padding: 4px 8px;
                font-size: 14px;
                cursor: pointer;
                border-radius: 0;
            }
            .theme-toggle:hover {
                background: var(--bg-secondary);
            }
            .drop-zone {
                position: relative;
                border: 1px dashed #999;
                transition: all 0.2s ease;
                cursor: pointer;
            }
            .drop-zone:hover {
                border-color: #333;
                background-color: #fafafa;
            }
            .drop-zone.dragover {
                border-color: #333;
                background-color: #f0f0f0;
                border-style: solid;
            }
            .modal-content {
                border-radius: 0;
                border: 1px solid var(--border-color);
                background: var(--bg-primary);
                color: var(--text-primary);
            }
            .modal-header {
                background: var(--bg-secondary);
                border-bottom: 1px solid var(--border-color);
                padding: 0.75rem 1rem;
            }
            .modal-title {
                font-size: 14px;
                font-weight: 600;
                color: var(--text-primary);
            }
            .modal-body {
                font-size: 13px;
                color: var(--text-primary);
            }
            .modal-body pre {
                background: #1a1a1a;
                color: #f0f0f0;
                padding: 12px;
                font-size: 12px;
                border: none;
                border-radius: 0;
            }
            .modal-body code {
                color: #d63384;
                background: var(--bg-code);
                padding: 1px 4px;
                font-size: 11px;
            }
            .modal-footer {
                border-top: 1px solid var(--border-color);
                padding: 0.5rem 1rem;
            }
            code {
                font-family: monospace;
                font-size: 12px;
            }
            .filter-group {
                display: inline-block;
                position: relative;
                margin-right: 0.5rem;
                vertical-align: top;
            }
            .filter-group-header {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                padding: 4px 10px;
                font-size: 11px;
                cursor: pointer;
                background: var(--bg-secondary);
                border: 1px solid var(--border-color);
                border-radius: 4px;
                color: var(--text-secondary);
                transition: all 0.15s ease;
            }
            .filter-group-header:hover {
                border-color: var(--text-muted);
                color: var(--text-primary);
                background: var(--bg-primary);
            }
            .filter-group-header .filter-group-label {
                font-weight: 500;
                color: var(--text-muted);
            }
            .filter-group-header .filter-group-count {
                font-size: 10px;
                color: var(--text-muted);
                background: var(--bg-primary);
                padding: 1px 5px;
                border-radius: 8px;
                min-width: 18px;
                text-align: center;
            }
            .filter-group-header.has-active {
                border-color: var(--text-primary);
                background: var(--text-primary);
                color: var(--bg-primary);
            }
            .filter-group-header.has-active .filter-group-label,
            .filter-group-header.has-active .filter-group-count {
                color: var(--bg-primary);
                background: transparent;
            }
            .filter-group-dropdown {
                display: none;
                position: absolute;
                top: 100%;
                left: 0;
                padding-top: 4px;
                z-index: 50;
            }
            .filter-group-dropdown-inner {
                background: var(--bg-primary);
                border: 1px solid var(--border-color);
                border-radius: 4px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
                min-width: 140px;
                max-height: 220px;
                overflow-y: auto;
                padding: 4px 0;
            }
            .filter-group:hover .filter-group-dropdown {
                display: block;
            }
            .filter-tag {
                display: block;
                padding: 5px 12px;
                font-size: 11px;
                cursor: pointer;
                color: var(--text-secondary);
                transition: background 0.1s;
                white-space: nowrap;
            }
            .filter-tag:hover {
                background: var(--bg-secondary);
                color: var(--text-primary);
            }
            .filter-tag.active {
                background: var(--text-primary);
                color: var(--bg-primary);
            }
            .filter-tag.active:hover {
                opacity: 0.9;
            }
            /* Dark mode graph text fix */
            [data-theme='dark'] #graph text,
            [data-theme='dark'] #splash-graph text,
            [data-theme='dark'] #attribute-graph text {
                fill: #e0e0e0 !important;
            }
            [data-theme='dark'] #graph .node text,
            [data-theme='dark'] #splash-graph .node text,
            [data-theme='dark'] #attribute-graph .node text {
                fill: #000;
            }
            /* Preserve schedule magenta color in nodes */
            [data-theme='dark'] #graph .node text[fill='#d63384'],
            [data-theme='dark'] #splash-graph .node text[fill='#d63384'],
            #graph .node text[fill='#d63384'],
            #splash-graph .node text[fill='#d63384'] {
                fill: #d63384 !important;
            }
            [data-theme='dark'] #graph .graph > polygon,
            [data-theme='dark'] #splash-graph .graph > polygon,
            [data-theme='dark'] #attribute-graph .graph > polygon {
                fill: transparent !important;
            }
            [data-theme='dark'] #graph .cluster > polygon,
            [data-theme='dark'] #graph .cluster > path,
            [data-theme='dark'] #attribute-graph .cluster > polygon,
            [data-theme='dark'] #attribute-graph .cluster > path {
                fill: #2a2a2a !important;
                stroke: #555 !important;
            }
            [data-theme='dark'] #graph .cluster text,
            [data-theme='dark'] #attribute-graph .cluster text {
                fill: #e0e0e0 !important;
            }
            /* Dark mode Bootstrap table overrides */
            [data-theme='dark'] .table {
                --bs-table-bg: var(--bg-primary);
                --bs-table-striped-bg: var(--bg-secondary);
                --bs-table-hover-bg: #333;
                --bs-table-color: var(--text-primary);
                --bs-table-striped-color: var(--text-primary);
                --bs-table-hover-color: var(--text-primary);
                color: var(--text-primary);
                border-color: var(--border-color);
            }
            [data-theme='dark'] .table > :not(caption) > * > * {
                background-color: var(--bg-primary);
                color: var(--text-primary);
                border-bottom-color: var(--border-light);
            }
            [data-theme='dark'] .table-striped > tbody > tr:nth-of-type(odd) > * {
                background-color: var(--bg-secondary);
            }
            [data-theme='dark'] .table th {
                background-color: #252525 !important;
                color: #e0e0e0 !important;
            }
            /* Dark mode for table link buttons */
            [data-theme='dark'] .table .btn-outline-primary {
                border-color: #666;
                color: #aaa;
            }
            [data-theme='dark'] .table .btn-outline-primary:hover {
                background-color: #555;
                border-color: #555;
                color: #fff;
            }
            /* Hero fade-in animations */
            @keyframes fadeInUp {
                from {
                    opacity: 0;
                    transform: translateY(12px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
            .hero-animate {
                opacity: 0;
                animation: fadeInUp 0.5s ease-out forwards;
            }
            .hero-animate-1 {
                animation-delay: 0.1s;
            }
            .hero-animate-2 {
                animation-delay: 0.3s;
            }
            .hero-animate-3 {
                animation-delay: 0.5s;
            }
            .hero-animate-4 {
                animation-delay: 0.7s;
            }
            /* Feature tiles grid */
            .feature-grid {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 1rem;
                margin-bottom: 2.5rem;
            }
            .superpowers-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 0.75rem 1.5rem;
                font-size: 13px;
                color: var(--text-secondary);
                line-height: 1.5;
            }
            @media (max-width: 992px) {
                .feature-grid {
                    grid-template-columns: repeat(2, 1fr);
                }
            }
            @media (max-width: 576px) {
                .feature-grid {
                    grid-template-columns: 1fr;
                }
                .superpowers-grid {
                    grid-template-columns: 1fr;
                }
            }
            /* Feature tiles */
            .feature-tile {
                padding: 0.875rem;
                background: var(--bg-secondary);
            }
            @media (max-width: 576px) {
                .feature-tile {
                    padding: 1rem 1.25rem;
                }
            }
            .feature-icon {
                color: var(--text-muted);
                margin-bottom: 0.5rem;
            }

            /* Stats Tab */
            .stats-summary {
                display: flex;
                gap: 1.5rem;
                font-size: 13px;
                color: var(--text-secondary);
                margin-bottom: 1.5rem;
                padding-bottom: 1rem;
                border-bottom: 1px solid var(--border-light);
            }
            .stats-summary strong {
                color: var(--text-primary);
                font-weight: 600;
            }
            .stats-row {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 1.5rem;
                margin-bottom: 1.5rem;
            }
            @media (max-width: 768px) {
                .stats-row {
                    grid-template-columns: 1fr;
                }
            }
            .stats-section {
                margin-bottom: 1.5rem;
            }
            .stats-section.all-good {
                color: #2e7d32;
            }
            .section-title {
                font-size: 10px;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                color: var(--text-muted);
                margin-bottom: 0.5rem;
                padding-bottom: 0.25rem;
                border-bottom: 1px solid var(--border-light);
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }
            .section-hint {
                font-weight: 400;
                text-transform: none;
                letter-spacing: 0;
            }
            .chart-box {
                padding: 0;
            }
            .chart-title {
                font-size: 10px;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                color: var(--text-muted);
                margin-bottom: 0.5rem;
                padding-bottom: 0.25rem;
                border-bottom: 1px solid var(--border-light);
            }

            /* Pie Charts */
            .pie-container {
                display: flex;
                align-items: flex-start;
                gap: 0.75rem;
            }
            .pie-container svg {
                flex-shrink: 0;
            }
            .pie-legend {
                flex: 1;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 10px;
            }
            .pie-legend-row {
                display: flex;
                align-items: center;
                gap: 0.4rem;
                padding: 0.15rem 0;
            }
            .pie-legend-dot {
                width: 8px;
                height: 8px;
                flex-shrink: 0;
            }
            .pie-legend-name {
                flex: 1;
                color: var(--text-secondary);
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            .pie-legend-val {
                color: var(--text-muted);
            }

            /* Coverage Bars */
            .coverage-bars {
                display: flex;
                flex-direction: column;
                gap: 0.5rem;
            }
            .coverage-row {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                font-size: 11px;
            }
            .coverage-row .coverage-label {
                min-width: 80px;
                color: var(--text-secondary);
            }
            .coverage-bar-wrap {
                flex: 1;
                height: 6px;
                background: var(--border-light);
                border-radius: 1px;
            }
            .coverage-bar-wrap .coverage-bar {
                height: 100%;
                border-radius: 1px;
            }
            .coverage-bar-wrap .coverage-bar.good {
                background: #7cb47c;
            }
            .coverage-bar-wrap .coverage-bar.okay {
                background: #d4a574;
            }
            .coverage-bar-wrap .coverage-bar.low {
                background: #c98b8b;
            }
            .coverage-pct {
                font-family: 'SF Mono', Monaco, monospace;
                min-width: 32px;
                text-align: right;
            }
            .coverage-pct.good {
                color: #5a9a5a;
            }
            .coverage-pct.okay {
                color: #b8885a;
            }
            .coverage-pct.low {
                color: #a86b6b;
            }

            /* Hubs */
            .hub-list {
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                max-height: 150px;
                overflow-y: auto;
            }
            .hub-row {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                padding: 0.25rem 0;
                border-bottom: 1px dotted var(--border-light);
            }
            .hub-row:last-child {
                border-bottom: none;
            }
            .hub-rank {
                font-size: 10px;
                color: var(--text-muted);
                min-width: 14px;
            }
            .hub-name {
                flex: 1;
                color: var(--text-primary);
            }
            .hub-name.pipeline {
                color: #e65100;
            }
            .hub-name.datasource {
                color: #7b1fa2;
            }
            .hub-name.group {
                color: #00838f;
            }
            .hub-stats {
                font-size: 10px;
                color: var(--text-muted);
            }

            /* Critical Path - Gantt-style */
            .critical-path-section {
                background: transparent;
                border-left: 3px solid #d63384;
                padding: 8px 0 8px 12px;
                margin-bottom: 12px;
            }
            .critical-path-section .section-title {
                color: var(--text-primary);
                font-size: 11px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                margin-bottom: 8px;
            }
            .critical-path-summary {
                display: flex;
                gap: 16px;
                margin-bottom: 12px;
                font-size: 11px;
                font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
            }
            .cp-stat {
                display: flex;
                flex-direction: column;
                gap: 1px;
            }
            .cp-stat-value {
                color: #d63384;
                font-weight: 600;
            }
            .cp-stat-label {
                color: var(--text-muted);
                font-size: 9px;
            }
            .cp-coverage {
                color: var(--text-muted);
                align-self: center;
            }
            .critical-path-gantt {
                display: flex;
                flex-direction: column;
                gap: 3px;
            }
            .cp-bar-row {
                display: flex;
                align-items: center;
                gap: 8px;
            }
            .cp-bar-label {
                font-size: 10px;
                font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
                color: var(--text-secondary);
                width: 140px;
                text-align: right;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            .cp-bar-track {
                flex: 1;
                height: 16px;
                background: var(--border-color);
                position: relative;
            }
            .cp-bar-fill {
                position: absolute;
                height: 100%;
                background: linear-gradient(90deg, #f8bbd9 0%, #f48fb1 100%);
                display: flex;
                align-items: center;
                justify-content: flex-end;
                padding-right: 4px;
                min-width: 24px;
            }
            .cp-bar-duration {
                font-size: 9px;
                font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
                color: #880e4f;
                font-weight: 500;
            }
            .cp-bar-cost {
                font-size: 9px;
                font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
                color: var(--text-muted);
                width: 60px;
                text-align: right;
            }
            .cp-bar-time {
                font-size: 9px;
                font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
                color: var(--text-muted);
                width: 50px;
                text-align: right;
            }
            [data-theme='dark'] .critical-path-section {
                border-left-color: #f48fb1;
            }
            [data-theme='dark'] .cp-stat-value {
                color: #f48fb1;
            }
            [data-theme='dark'] .cp-bar-fill {
                background: linear-gradient(90deg, #ad1457 0%, #d63384 100%);
            }
            [data-theme='dark'] .cp-bar-duration {
                color: #fff;
            }

            /* Costliest Path */
            .costliest-path-section {
                background: transparent;
                border-left: 3px solid #66bb6a;
                padding: 8px 0 8px 12px;
                margin-bottom: 12px;
            }
            [data-theme='dark'] .costliest-path-section {
                border-left-color: #81c784;
            }

            /* Cycles */
            .stats-section.cycles-warning {
                background: rgba(183, 28, 28, 0.08);
                border: 1px solid #c98b8b;
                border-radius: 4px;
                padding: 12px;
            }
            .stats-section.cycles-warning .section-title {
                color: #b71c1c;
            }
            .cycle-count {
                background: #c98b8b;
                color: #fff;
                padding: 1px 6px;
                border-radius: 8px;
                font-size: 9px;
                margin-left: 6px;
            }
            .cycle-list {
                margin-top: 10px;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
            }
            .cycle-item {
                display: flex;
                gap: 10px;
                padding: 6px 0;
                border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            }
            .cycle-item:last-child {
                border-bottom: none;
            }
            .cycle-label {
                color: #b71c1c;
                font-weight: 600;
                white-space: nowrap;
            }
            .cycle-path {
                color: #555;
                word-break: break-word;
            }
            [data-theme='dark'] .stats-section.cycles-warning {
                background: rgba(183, 28, 28, 0.15);
                border-color: #c98b8b;
            }
            [data-theme='dark'] .stats-section.cycles-warning .section-title {
                color: #ef9a9a;
            }
            [data-theme='dark'] .cycle-label {
                color: #ef9a9a;
            }
            [data-theme='dark'] .cycle-path {
                color: #aaa;
            }

            /* Missing/Needs Attention */
            .missing-scroll {
                max-height: 250px;
                overflow-y: auto;
                padding-right: 0.5rem;
            }
            .missing-block {
                margin-bottom: 0.75rem;
            }
            .missing-block:last-child {
                margin-bottom: 0;
            }
            .missing-header {
                font-size: 11px;
                color: var(--text-muted);
                margin-bottom: 0.25rem;
                display: flex;
                align-items: center;
                gap: 0.4rem;
            }
            .missing-count {
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 10px;
                background: var(--bg-secondary);
                padding: 1px 5px;
            }
            .missing-names {
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                line-height: 1.6;
                word-break: break-word;
            }
            .missing-names.pipeline {
                color: #e65100;
            }
            .missing-names.datasource {
                color: #7b1fa2;
            }
            .missing-names.orphan {
                color: #c62828;
            }
            [data-theme='dark'] .missing-names.orphan {
                color: #ef9a9a;
            }
            [data-theme='dark'] .missing-names.pipeline {
                color: #ffab91;
            }
            [data-theme='dark'] .missing-names.datasource {
                color: #ce93d8;
            }

            /* Scrollbars */
            .hub-list::-webkit-scrollbar,
            .missing-scroll::-webkit-scrollbar {
                width: 4px;
            }
            .hub-list::-webkit-scrollbar-track,
            .missing-scroll::-webkit-scrollbar-track {
                background: var(--bg-secondary);
            }
            .hub-list::-webkit-scrollbar-thumb,
            .missing-scroll::-webkit-scrollbar-thumb {
                background: var(--border-color);
                border-radius: 2px;
            }
            .hub-list::-webkit-scrollbar-thumb:hover,
            .missing-scroll::-webkit-scrollbar-thumb:hover {
                background: var(--text-muted);
            }
        </style>
      <script type="module" crossorigin>(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function renderSplashGraph() {
  const isDark = document.documentElement.getAttribute("data-theme") === "dark";
  const textColor = isDark ? "#e0e0e0" : "#000000";
  const dot = `digraph {
        rankdir=LR
        bgcolor="transparent"
        node [fontname="Arial" fontsize="10" fontcolor="${textColor}"]
        edge [color="#999999"]
        "raw_events" [shape=ellipse style=filled fillcolor="#f3e5f5" color="#7b1fa2"]
        "etl-job" [shape=box style="filled,rounded" fillcolor="#e3f2fd" color="#1976d2" fontname="Arial"]
        "cleaned_events" [shape=ellipse style=filled fillcolor="#f3e5f5" color="#7b1fa2"]
        "raw_events" -> "etl-job"
        "etl-job" -> "cleaned_events"
    }`;
  d3.select("#splash-graph").graphviz().width(260).height(110).fit(true).renderDot(dot);
}
const state = {
  currentConfig: null,
  lastRenderedConfigHash: null,
  graphviz: null,
  groupedView: true,
  pipelinesOnlyView: false,
  analysisMode: null,
  // null, 'critical-path'
  showCostLabels: false,
  expandedGroups: /* @__PURE__ */ new Set(),
  selectedNode: null,
  // Cached lineage maps for performance
  cachedUpstreamMap: {},
  cachedDownstreamMap: {},
  cachedLineage: {},
  // View state cache for snappy group expand/collapse
  viewStateCache: /* @__PURE__ */ new Map(),
  // Attribute graph state
  attributeGraphviz: null,
  attributeLastRenderedConfigHash: null,
  nestedClusterCount: 0,
  attributeLineageMap: {},
  datasourceLineageMap: {},
  selectedAttribute: null
};
function getConfigHash(config) {
  return JSON.stringify(config);
}
function getViewStateKey() {
  const isDark = document.documentElement.getAttribute("data-theme") === "dark";
  const expandedGroupsKey = Array.from(state.expandedGroups).sort().join(",");
  return `${state.groupedView}|${state.pipelinesOnlyView}|${isDark}|${expandedGroupsKey}`;
}
function clearViewStateCache() {
  state.viewStateCache.clear();
}
const MAX_VIEW_CACHE_SIZE = 50;
function addToViewCache(key, value) {
  if (state.viewStateCache.size >= MAX_VIEW_CACHE_SIZE) {
    const firstKey = state.viewStateCache.keys().next().value;
    state.viewStateCache.delete(firstKey);
  }
  state.viewStateCache.set(key, value);
}
const exampleConfig = {
  clusters: [
    {
      name: "user-processing",
      description: "User data processing and enrichment cluster"
    },
    {
      name: "order-management",
      description: "Order processing and validation cluster"
    },
    {
      name: "real-time",
      description: "Real-time streaming data cluster",
      parent: "order-management"
    },
    {
      name: "analytics",
      description: "Analytics and reporting cluster"
    }
  ],
  pipelines: [
    {
      name: "user-enrichment",
      description: "Enriches user data with behavioral signals and ML features",
      input_sources: ["raw_users", "user_events"],
      output_sources: ["enriched_users"],
      schedule: "Every 2 hours",
      duration: 45,
      cost: 18.5,
      tags: ["user-data", "ml", "enrichment"],
      cluster: "user-processing",
      links: {
        airflow: "https://airflow.company.com/dags/user_enrichment",
        monitoring: "https://grafana.company.com/d/user-enrichment",
        docs: "https://docs.company.com/pipelines/user-enrichment"
      },
      upstream_pipelines: []
    },
    {
      name: "order-processing",
      description: "Validates and processes incoming orders in real-time",
      input_sources: ["raw_orders", "inventory"],
      output_sources: ["processed_orders", "order_audit"],
      schedule: "Every 15 minutes",
      duration: 12,
      cost: 4.2,
      tags: ["orders", "real-time", "validation"],
      cluster: "real-time",
      links: {
        airflow: "https://airflow.company.com/dags/order_processing",
        monitoring: "https://grafana.company.com/d/orders",
        alerts: "https://pagerduty.company.com/services/orders"
      },
      upstream_pipelines: []
    },
    {
      name: "analytics-aggregation",
      description: "Daily aggregation of user metrics and business KPIs",
      input_sources: ["enriched_users", "processed_orders", "user_events"],
      output_sources: ["daily_metrics", "user_cohorts"],
      schedule: "Daily at 1:00 AM",
      duration: 90,
      cost: 42,
      tags: ["analytics", "aggregation", "daily"],
      cluster: "analytics",
      links: {
        airflow: "https://airflow.company.com/dags/analytics_agg",
        dashboard: "https://tableau.company.com/analytics-dashboard"
      },
      upstream_pipelines: ["user-enrichment", "order-processing"]
    },
    {
      name: "export-to-salesforce",
      description: "Sync user cohorts to Salesforce",
      input_sources: ["user_cohorts"],
      output_sources: ["salesforce_users"],
      group: "data-exports",
      cluster: "analytics",
      duration: 8,
      cost: 2.1,
      upstream_pipelines: ["analytics-aggregation"],
      links: {
        airflow: "https://airflow.company.com/dags/crm_exports"
      }
    },
    {
      name: "export-to-hubspot",
      description: "Sync user cohorts to HubSpot",
      input_sources: ["user_cohorts"],
      output_sources: ["hubspot_contacts"],
      group: "data-exports",
      cluster: "analytics",
      duration: 5,
      cost: 1.8,
      upstream_pipelines: ["analytics-aggregation"],
      links: {
        airflow: "https://airflow.company.com/dags/crm_exports"
      }
    },
    {
      name: "export-to-amplitude",
      description: "Sync daily metrics to Amplitude",
      input_sources: ["daily_metrics"],
      output_sources: ["amplitude_events"],
      group: "data-exports",
      cluster: "analytics",
      duration: 3,
      cost: 0.9,
      upstream_pipelines: ["analytics-aggregation"],
      links: {
        airflow: "https://airflow.company.com/dags/analytics_exports"
      }
    },
    {
      name: "weekly-rollup",
      description: "Aggregate daily metrics into weekly executive summary",
      input_sources: ["daily_metrics", "enriched_users"],
      output_sources: ["executive_summary"],
      schedule: "0 6 * * MON",
      duration: 120,
      cost: 65,
      cluster: "analytics",
      upstream_pipelines: ["analytics-aggregation", "user-enrichment"],
      links: {
        airflow: "https://airflow.company.com/dags/weekly_rollup"
      }
    }
  ],
  datasources: [
    {
      name: "raw_users",
      description: "Raw user registration and profile data from production database",
      type: "snowflake",
      owner: "data-platform@company.com",
      tags: ["pii", "users", "core-data"],
      cluster: "user-processing",
      attributes: [
        { name: "id" },
        { name: "first_name" },
        { name: "last_name" },
        { name: "email" },
        { name: "signup_date" },
        {
          name: "address",
          attributes: [
            { name: "city" },
            { name: "zip" },
            {
              name: "geo",
              attributes: [{ name: "lat" }, { name: "lng" }]
            }
          ]
        }
      ],
      metadata: {
        schema: "RAW_DATA",
        table: "USERS",
        size: "2.1TB",
        record_count: "45M",
        refresh_frequency: "real-time"
      },
      links: {
        snowflake: "https://company.snowflakecomputing.com/console#/data/databases/PROD/schemas/RAW_DATA/table/USERS",
        monitoring: "https://grafana.company.com/d/raw-users",
        docs: "https://docs.company.com/schemas/raw_users"
      }
    },
    {
      name: "user_events",
      description: "Clickstream and interaction events from all digital touchpoints",
      type: "s3",
      owner: "analytics-team@company.com",
      tags: ["events", "clickstream", "large-dataset"],
      cluster: "analytics",
      attributes: [
        { name: "event_id" },
        { name: "user_id", from: "raw_users::id" },
        { name: "event_type" },
        { name: "page_url" },
        { name: "timestamp" }
      ],
      metadata: {
        bucket: "company-events-prod",
        size: "15TB",
        record_count: "2.5B",
        file_format: "parquet"
      },
      links: {
        s3: "https://s3.console.aws.amazon.com/s3/buckets/company-events-prod",
        athena: "https://console.aws.amazon.com/athena/home#query"
      }
    },
    {
      name: "raw_orders",
      description: "Real-time order data from e-commerce platform",
      type: "api",
      owner: "platform-team@company.com",
      tags: ["orders", "real-time", "revenue"],
      cluster: "real-time",
      metadata: {
        endpoint: "https://api.company.com/v2/orders",
        rate_limit: "1000 req/min",
        record_count: "120M"
      },
      links: {
        api_docs: "https://docs.company.com/api/orders",
        monitoring: "https://grafana.company.com/d/orders-api"
      }
    },
    {
      name: "inventory",
      description: "Product inventory levels across all warehouses",
      type: "snowflake",
      owner: "supply-chain@company.com",
      tags: ["inventory", "warehouse", "operational"],
      cluster: "order-management",
      metadata: {
        schema: "INVENTORY",
        size: "150GB",
        refresh_frequency: "every 15 minutes"
      },
      links: {
        snowflake: "https://company.snowflakecomputing.com/console#/data/databases/PROD/schemas/INVENTORY",
        tableau: "https://tableau.company.com/views/inventory-dashboard"
      }
    },
    {
      name: "enriched_users",
      description: "Enriched user profiles with behavioral features",
      type: "delta",
      owner: "data-platform@company.com",
      tags: ["users", "enriched", "ml-ready"],
      cluster: "user-processing",
      attributes: [
        { name: "user_id", from: "raw_users::id" },
        { name: "full_name", from: ["raw_users::first_name", "raw_users::last_name"] },
        { name: "email", from: "raw_users::email" },
        { name: "event_count", from: "user_events::event_id" },
        { name: "last_active", from: "user_events::timestamp" },
        { name: "signup_date", from: "raw_users::signup_date" },
        {
          name: "location",
          from: "raw_users::address",
          attributes: [
            { name: "city", from: "raw_users::address::city" },
            { name: "zip", from: "raw_users::address::zip" },
            { name: "coords", from: "raw_users::address::geo" }
          ]
        }
      ]
    },
    {
      name: "daily_metrics",
      description: "Aggregated daily business metrics",
      type: "snowflake",
      owner: "analytics-team@company.com",
      tags: ["metrics", "daily", "kpi"],
      cluster: "analytics",
      attributes: [
        { name: "date" },
        { name: "active_users", from: "enriched_users::user_id" },
        { name: "total_events", from: "user_events::event_id" }
      ]
    },
    {
      name: "executive_summary",
      description: "Weekly executive dashboard metrics",
      type: "snowflake",
      cluster: "analytics",
      attributes: [
        { name: "week" },
        { name: "weekly_active_users", from: "daily_metrics::active_users" },
        { name: "weekly_events", from: "daily_metrics::total_events" },
        { name: "user_growth", from: ["daily_metrics::active_users", "enriched_users::signup_date"] }
      ]
    },
    {
      name: "user_cohorts",
      description: "User segmentation and cohort definitions",
      type: "snowflake",
      cluster: "analytics"
    },
    {
      name: "salesforce_users",
      description: "User data synced to Salesforce CRM",
      type: "api",
      cluster: "analytics"
    },
    {
      name: "hubspot_contacts",
      description: "Contact data synced to HubSpot",
      type: "api",
      cluster: "analytics"
    },
    {
      name: "amplitude_events",
      description: "Product analytics events sent to Amplitude",
      type: "api",
      cluster: "analytics"
    }
  ]
};
function generateAttributeDot() {
  if (!state.currentConfig) return "";
  const datasources = state.currentConfig.datasources || [];
  document.documentElement.getAttribute("data-theme") === "dark";
  const textColor = "#334155";
  const clusterBg = "#f1f5f9";
  const attrFill = "#ffffff";
  const attrBorder = "#94a3b8";
  let dot = `digraph AttributeLineage {
    rankdir=LR
    bgcolor="transparent"
    compound=true
    nodesep=0.15
    node [fontname="Arial" fontsize="10"]
    edge [fontsize="9" color="#94a3b8" arrowsize="0.6"]

`;
  const sourceRefs = /* @__PURE__ */ new Set();
  function collectSourceRefs(attrs) {
    attrs.forEach((attr) => {
      if (attr.from) {
        const sources = Array.isArray(attr.from) ? attr.from : [attr.from];
        sources.forEach((s) => sourceRefs.add(s));
      }
      if (attr.attributes) collectSourceRefs(attr.attributes);
    });
  }
  datasources.forEach((ds) => {
    if (ds.attributes) collectSourceRefs(ds.attributes);
  });
  function isSourceRef(dsName, attrPath) {
    const ref = `${dsName}::${attrPath.replace(/__/g, "::")}`;
    return sourceRefs.has(ref);
  }
  const structAttrs = /* @__PURE__ */ new Set();
  state.nestedClusterCount = 0;
  function renderAttributes(attrs, dsName, dsId, prefix = "", depth = 0) {
    let result = "";
    attrs.forEach((attr) => {
      const attrPath = prefix ? `${prefix}__${attr.name}` : attr.name;
      const attrId = `${dsId}__${attrPath.replace(/[^a-zA-Z0-9_]/g, "_")}`;
      const hasUpstream = attr.from ? true : false;
      const hasDownstream = isSourceRef(dsName, attrPath);
      const hasLineage = hasUpstream || hasDownstream;
      const hasChildren = attr.attributes && attr.attributes.length > 0;
      if (hasChildren) {
        structAttrs.add(attrId);
        state.nestedClusterCount++;
        const clusterId = `cluster_${attrId}`;
        const nestedBg = hasLineage ? "#dde5ed" : depth === 0 ? "#e8eef4" : "#dce4ec";
        result += `        subgraph ${clusterId} {
                    label="${attr.name}"
                    labelloc="t"
                    style=filled
                    fillcolor="${nestedBg}"
                    fontcolor="${hasLineage ? "#7b1fa2" : textColor}"
                    color="${hasLineage ? "#7b1fa2" : attrBorder}"
                    fontname="Arial"
                    fontsize="9"
                    margin="8"
`;
        result += `            "${attrId}" [label="" shape=point width=0 height=0 fixedsize=true style=invis];
`;
        result += renderAttributes(attr.attributes, dsName, dsId, attrPath, depth + 1);
        result += `                        }
`;
      } else {
        const fill = hasLineage ? "#e2e8f0" : attrFill;
        result += `            "${attrId}" [label="${attr.name}" shape=box style="filled,rounded" fillcolor="${fill}" color="${attrBorder}" fontcolor="${textColor}" fontsize="9" height="0.3"];
`;
      }
    });
    return result;
  }
  function collectLineage(attrs, dsId, prefix = "") {
    let edges = [];
    attrs.forEach((attr) => {
      const attrPath = prefix ? `${prefix}__${attr.name}` : attr.name;
      const targetId = `${dsId}__${attrPath.replace(/[^a-zA-Z0-9_]/g, "_")}`;
      const targetIsStruct = structAttrs.has(targetId);
      if (attr.from) {
        const sources = Array.isArray(attr.from) ? attr.from : [attr.from];
        sources.forEach((source) => {
          const parts = source.split("::");
          if (parts.length >= 2) {
            const sourceDs = parts[0].replace(/[^a-zA-Z0-9]/g, "_");
            const sourcePath = parts.slice(1).join("__").replace(/[^a-zA-Z0-9_]/g, "_");
            const sourceId = `${sourceDs}__${sourcePath}`;
            const sourceIsStruct = structAttrs.has(sourceId);
            let edgeAttrs = ['color="#7b1fa2"'];
            if (sourceIsStruct) {
              edgeAttrs.push(`ltail="cluster_${sourceId}"`);
            }
            if (targetIsStruct) {
              edgeAttrs.push(`lhead="cluster_${targetId}"`);
            }
            edges.push(`    "${sourceId}" -> "${targetId}" [${edgeAttrs.join(" ")}];
`);
          }
        });
      }
      if (attr.attributes && attr.attributes.length > 0) {
        edges = edges.concat(collectLineage(attr.attributes, dsId, attrPath));
      }
    });
    return edges;
  }
  datasources.forEach((ds) => {
    if (!ds.attributes || ds.attributes.length === 0) return;
    const dsId = ds.name.replace(/[^a-zA-Z0-9]/g, "_");
    dot += `    subgraph cluster_${dsId} {
        label="${ds.name}"
        style=filled
        fillcolor="${clusterBg}"
        fontcolor="${textColor}"
        color="${attrBorder}"
        fontname="Arial"
        fontsize="11"

`;
    dot += renderAttributes(ds.attributes, ds.name, dsId);
    dot += `    }

`;
  });
  datasources.forEach((ds) => {
    if (!ds.attributes) return;
    const dsId = ds.name.replace(/[^a-zA-Z0-9]/g, "_");
    const edges = collectLineage(ds.attributes, dsId);
    edges.forEach((edge) => {
      dot += edge;
    });
  });
  dot += `}`;
  return dot;
}
function renderAttributeGraph() {
  if (!state.currentConfig) return;
  const dot = generateAttributeDot();
  if (!dot) return;
  if (!state.attributeGraphviz) {
    document.getElementById("attribute-graph").innerHTML = "";
    state.attributeGraphviz = d3.select("#attribute-graph").graphviz().width(document.getElementById("attribute-graph").offsetWidth || 800).height(500).fit(true).zoom(true);
  }
  state.attributeGraphviz.renderDot(dot).on("end", function() {
    d3.select("#attribute-graph").selectAll(".node").on("click", function(event) {
      event.stopPropagation();
      const title = d3.select(this).select("title").text();
      if (title && state.attributeLineageMap[title]) {
        selectAttribute(title);
      }
    });
    d3.select("#attribute-graph").selectAll(".cluster").on("click", function(event) {
      event.stopPropagation();
      const title = d3.select(this).select("title").text();
      if (title && title.startsWith("cluster_")) {
        const id = title.substring(8);
        if (id.includes("__") && state.attributeLineageMap[id]) {
          selectAttribute(id);
        } else {
          const ds = (state.currentConfig.datasources || []).find(
            (d) => d.name.replace(/[^a-zA-Z0-9]/g, "_") === id
          );
          if (ds) showDatasourceInAttributePanel(ds);
        }
      }
    });
    d3.select("#attribute-graph svg").on("click", function(event) {
      if (event.target.tagName === "svg" || event.target.classList.contains("graph")) {
        clearAttributeSelection();
      }
    });
  });
}
function resetAttributeGraph() {
  if (state.attributeGraphviz) state.attributeGraphviz.resetZoom();
}
function buildAttributeLineageMap() {
  state.attributeLineageMap = {};
  if (!state.currentConfig) return;
  const datasources = state.currentConfig.datasources || [];
  function registerAttributes(attrs, dsName, dsId, prefix = "") {
    attrs.forEach((attr) => {
      const attrPath = prefix ? `${prefix}__${attr.name}` : attr.name;
      const attrId = `${dsId}__${attrPath.replace(/[^a-zA-Z0-9_]/g, "_")}`;
      const fullName = prefix ? `${dsName}::${prefix.replace(/__/g, "::")}::${attr.name}` : `${dsName}::${attr.name}`;
      state.attributeLineageMap[attrId] = {
        id: attrId,
        name: attr.name,
        datasource: dsName,
        fullName,
        upstream: [],
        downstream: []
      };
      if (attr.attributes && attr.attributes.length > 0) {
        registerAttributes(attr.attributes, dsName, dsId, attrPath);
      }
    });
  }
  function collectAttributeLineage(attrs, dsId, prefix = "") {
    attrs.forEach((attr) => {
      const attrPath = prefix ? `${prefix}__${attr.name}` : attr.name;
      const targetId = `${dsId}__${attrPath.replace(/[^a-zA-Z0-9_]/g, "_")}`;
      if (attr.from) {
        const sources = Array.isArray(attr.from) ? attr.from : [attr.from];
        sources.forEach((source) => {
          const parts = source.split("::");
          if (parts.length >= 2) {
            const sourceDs = parts[0].replace(/[^a-zA-Z0-9]/g, "_");
            const sourcePath = parts.slice(1).join("__").replace(/[^a-zA-Z0-9_]/g, "_");
            const sourceId = `${sourceDs}__${sourcePath}`;
            if (state.attributeLineageMap[targetId]) {
              state.attributeLineageMap[targetId].upstream.push(sourceId);
            }
            if (state.attributeLineageMap[sourceId]) {
              state.attributeLineageMap[sourceId].downstream.push(targetId);
            }
          }
        });
      }
      if (attr.attributes && attr.attributes.length > 0) {
        collectAttributeLineage(attr.attributes, dsId, attrPath);
      }
    });
  }
  datasources.forEach((ds) => {
    if (!ds.attributes) return;
    const dsId = ds.name.replace(/[^a-zA-Z0-9]/g, "_");
    registerAttributes(ds.attributes, ds.name, dsId);
  });
  datasources.forEach((ds) => {
    if (!ds.attributes) return;
    const dsId = ds.name.replace(/[^a-zA-Z0-9]/g, "_");
    collectAttributeLineage(ds.attributes, dsId);
  });
  function computeFullChain(attrId, direction, visited = /* @__PURE__ */ new Set(), depth = 1) {
    if (visited.has(attrId)) return [];
    visited.add(attrId);
    const attr = state.attributeLineageMap[attrId];
    if (!attr) return [];
    const next = direction === "upstream" ? attr.upstream : attr.downstream;
    let result = [];
    next.forEach((nextId) => {
      result.push({ id: nextId, depth });
      result.push(...computeFullChain(nextId, direction, visited, depth + 1));
    });
    return result;
  }
  Object.keys(state.attributeLineageMap).forEach((attrId) => {
    state.attributeLineageMap[attrId].fullUpstream = computeFullChain(attrId, "upstream", /* @__PURE__ */ new Set());
    state.attributeLineageMap[attrId].fullDownstream = computeFullChain(attrId, "downstream", /* @__PURE__ */ new Set());
  });
  var dsDirectUpstream = {};
  var dsDirectDownstream = {};
  datasources.forEach(function(ds) {
    var id = ds.name.replace(/[^a-zA-Z0-9]/g, "_");
    dsDirectUpstream[id] = /* @__PURE__ */ new Set();
    dsDirectDownstream[id] = /* @__PURE__ */ new Set();
  });
  Object.values(state.attributeLineageMap).forEach(function(attr) {
    if (!attr || !attr.datasource) return;
    var dsId = attr.datasource.replace(/[^a-zA-Z0-9]/g, "_");
    var upIds = attr.upstream || [];
    for (var i = 0; i < upIds.length; i++) {
      var upDs = upIds[i].split("__")[0];
      if (upDs && upDs !== dsId && dsDirectUpstream[dsId]) {
        dsDirectUpstream[dsId].add(upDs);
      }
    }
    var downIds = attr.downstream || [];
    for (var j = 0; j < downIds.length; j++) {
      var downDs = downIds[j].split("__")[0];
      if (downDs && downDs !== dsId && dsDirectDownstream[dsId]) {
        dsDirectDownstream[dsId].add(downDs);
      }
    }
  });
  function bfsProvenance(startId, getNeighbors) {
    var result = [];
    var visited = /* @__PURE__ */ new Set([startId]);
    var queue = [];
    var neighbors = getNeighbors(startId);
    neighbors.forEach(function(id) {
      queue.push({ id, depth: 1 });
      visited.add(id);
    });
    while (queue.length > 0) {
      var item = queue.shift();
      result.push(item);
      var next = getNeighbors(item.id);
      next.forEach(function(nextId) {
        if (!visited.has(nextId)) {
          visited.add(nextId);
          queue.push({ id: nextId, depth: item.depth + 1 });
        }
      });
    }
    result.sort(function(a, b) {
      return a.depth - b.depth;
    });
    return result;
  }
  state.datasourceLineageMap = {};
  datasources.forEach(function(ds) {
    var id = ds.name.replace(/[^a-zA-Z0-9]/g, "_");
    state.datasourceLineageMap[id] = {
      name: ds.name,
      upstream: bfsProvenance(id, function(x) {
        return dsDirectUpstream[x] || /* @__PURE__ */ new Set();
      }),
      downstream: bfsProvenance(id, function(x) {
        return dsDirectDownstream[x] || /* @__PURE__ */ new Set();
      })
    };
  });
}
function selectAttribute(attrId) {
  state.selectedAttribute = attrId;
  const attr = state.attributeLineageMap[attrId];
  if (!attr) return;
  d3.select("#attribute-graph").selectAll(".node").classed("node-highlighted", false).classed("node-connected", false).classed("node-dimmed", false);
  d3.select("#attribute-graph").selectAll(".cluster").classed("cluster-highlighted", false).classed("cluster-connected", false).classed("cluster-dimmed", false);
  d3.select("#attribute-graph").selectAll(".edge").classed("edge-highlighted", false).classed("edge-dimmed", false);
  const upstream = attr.fullUpstream || [];
  const downstream = attr.fullDownstream || [];
  const allConnected = /* @__PURE__ */ new Set([attrId, ...upstream.map((x) => x.id), ...downstream.map((x) => x.id)]);
  d3.select("#attribute-graph").selectAll(".node").each(function() {
    const node = d3.select(this);
    const title = node.select("title").text();
    if (title === attrId) {
      node.classed("node-highlighted", true).classed("node-dimmed", false);
    } else if (allConnected.has(title)) {
      node.classed("node-connected", true).classed("node-dimmed", false);
    } else {
      node.classed("node-dimmed", true);
    }
  });
  d3.select("#attribute-graph").selectAll(".cluster").each(function() {
    const cluster = d3.select(this);
    const title = cluster.select("title").text();
    if (title && title.startsWith("cluster_")) {
      const clusterId = title.substring(8);
      if (clusterId === attrId) {
        cluster.classed("cluster-highlighted", true).classed("cluster-dimmed", false);
      } else if (allConnected.has(clusterId)) {
        cluster.classed("cluster-connected", true).classed("cluster-dimmed", false);
      } else {
        cluster.classed("cluster-dimmed", true);
      }
    }
  });
  d3.select("#attribute-graph").selectAll(".edge").each(function() {
    const edge = d3.select(this);
    const title = edge.select("title").text();
    const [from, to] = title.split("->").map((s) => s.trim());
    if (allConnected.has(from) && allConnected.has(to)) {
      edge.classed("edge-highlighted", true).classed("edge-dimmed", false);
    } else {
      edge.classed("edge-dimmed", true);
    }
  });
  showAttributeDetails(attrId, upstream, downstream);
}
function showAttributeDetails(attrId, upstream, downstream) {
  const attr = state.attributeLineageMap[attrId];
  if (!attr) return;
  const col = document.getElementById("attribute-details-col");
  const graphCol = document.getElementById("attribute-graph-col");
  const content = document.getElementById("attribute-details-content");
  graphCol.classList.remove("col-md-12");
  graphCol.classList.add("col-md-8");
  col.style.display = "block";
  setTimeout(() => {
    if (state.attributeGraphviz) state.attributeGraphviz.fit(true);
  }, 50);
  let html = `<h5>${attr.name}</h5>`;
  html += `<div class="detail-label">DATASOURCE</div>`;
  html += `<div class="detail-value">${attr.datasource}</div>`;
  const childPrefix = attrId + "__";
  const children = Object.keys(state.attributeLineageMap).filter((id) => id.startsWith(childPrefix)).map((id) => {
    const child = state.attributeLineageMap[id];
    const relativePath = id.substring(childPrefix.length);
    const depth = (relativePath.match(/__/g) || []).length;
    return { id, name: child.name, relativePath, depth };
  }).sort((a, b) => a.relativePath.localeCompare(b.relativePath));
  if (children.length > 0) {
    html += `<div class="detail-label">CONTAINS (${children.length})</div>`;
    html += `<div class="detail-value">`;
    children.forEach((child) => {
      const indent = child.depth * 12;
      html += `<div class="lineage-link" data-attr-id="${child.id}" style="padding-left: ${indent}px;">${child.relativePath.replace(/__/g, ".")}</div>`;
    });
    html += `</div>`;
  }
  function dedupeAndSort(items) {
    const seen = /* @__PURE__ */ new Map();
    items.forEach((x) => {
      if (!seen.has(x.id) || seen.get(x.id).depth > x.depth) {
        seen.set(x.id, x);
      }
    });
    return [...seen.values()].sort((a, b) => a.depth - b.depth);
  }
  const sortedUpstream = dedupeAndSort(upstream);
  const sortedDownstream = dedupeAndSort(downstream);
  function getDatasourceMetadata(dsName) {
    const datasource = state.currentConfig?.datasources?.find((ds) => ds.name === dsName);
    if (!datasource) return null;
    const meta = {};
    if (datasource.description) meta.description = datasource.description;
    if (datasource.type) meta.source_type = datasource.type;
    if (datasource.cluster) meta.cluster = datasource.cluster;
    if (datasource.owner) meta.owner = datasource.owner;
    if (datasource.tags?.length) meta.tags = datasource.tags;
    if (datasource.links && Object.keys(datasource.links).length) meta.links = datasource.links;
    if (datasource.metadata && Object.keys(datasource.metadata).length) meta.metadata = datasource.metadata;
    return meta;
  }
  const allUpstreamIds = new Set(sortedUpstream.map((x) => x.id));
  const allDownstreamIds = new Set(sortedDownstream.map((x) => x.id));
  const upstreamEdges = [];
  allUpstreamIds.forEach((id) => {
    const upAttr = state.attributeLineageMap[id];
    if (upAttr && upAttr.downstream) {
      upAttr.downstream.forEach((downId) => {
        if (allUpstreamIds.has(downId) || downId === attrId) {
          upstreamEdges.push({ from: id, to: downId });
        }
      });
    }
  });
  const downstreamEdges = [];
  if (attr.downstream) {
    attr.downstream.forEach((downId) => {
      if (allDownstreamIds.has(downId)) {
        downstreamEdges.push({ from: attrId, to: downId });
      }
    });
  }
  allDownstreamIds.forEach((id) => {
    const downAttr = state.attributeLineageMap[id];
    if (downAttr && downAttr.downstream) {
      downAttr.downstream.forEach((nextId) => {
        if (allDownstreamIds.has(nextId)) {
          downstreamEdges.push({ from: id, to: nextId });
        }
      });
    }
  });
  const lineageJson = {
    attribute: attrId,
    name: attr.name,
    fullName: attr.fullName,
    datasource: attr.datasource,
    datasource_metadata: getDatasourceMetadata(attr.datasource),
    upstream: {
      attributes: sortedUpstream.map((x) => {
        const upAttr = state.attributeLineageMap[x.id];
        if (!upAttr) return null;
        return {
          id: x.id,
          depth: x.depth,
          name: upAttr.name,
          fullName: upAttr.fullName,
          datasource: upAttr.datasource,
          datasource_metadata: getDatasourceMetadata(upAttr.datasource)
        };
      }).filter((x) => x),
      edges: upstreamEdges
    },
    downstream: {
      attributes: sortedDownstream.map((x) => {
        const downAttr = state.attributeLineageMap[x.id];
        if (!downAttr) return null;
        return {
          id: x.id,
          depth: x.depth,
          name: downAttr.name,
          fullName: downAttr.fullName,
          datasource: downAttr.datasource,
          datasource_metadata: getDatasourceMetadata(downAttr.datasource)
        };
      }).filter((x) => x),
      edges: downstreamEdges
    },
    children: children.map((c) => ({
      id: c.id,
      name: c.name,
      relativePath: c.relativePath,
      depth: c.depth
    }))
  };
  const hasLineage = sortedUpstream.length > 0 || sortedDownstream.length > 0;
  if (hasLineage) {
    html += `<div class="lineage-view-toggle">
            <span class="lineage-toggle-label active" data-view="tree">Tree</span>
            <div class="lineage-toggle-slider"></div>
            <span class="lineage-toggle-label" data-view="json">JSON</span>
        </div>`;
  }
  html += `<div class="lineage-tree-view">`;
  if (sortedUpstream.length > 0) {
    html += `<div class="detail-label">UPSTREAM (${sortedUpstream.length})</div>`;
    html += `<div class="detail-value">`;
    sortedUpstream.forEach((x) => {
      const upAttr = state.attributeLineageMap[x.id];
      if (upAttr) {
        const indent = (x.depth - 1) * 12;
        const opacity = Math.max(0.5, 1 - (x.depth - 1) * 0.15);
        const prefix = x.depth > 1 ? " " : "";
        html += `<div class="lineage-link" data-attr-id="${x.id}" style="padding-left: ${indent}px; opacity: ${opacity};">${prefix}${upAttr.fullName}</div>`;
      }
    });
    html += `</div>`;
  }
  if (sortedDownstream.length > 0) {
    html += `<div class="detail-label">DOWNSTREAM (${sortedDownstream.length})</div>`;
    html += `<div class="detail-value">`;
    sortedDownstream.forEach((x) => {
      const downAttr = state.attributeLineageMap[x.id];
      if (downAttr) {
        const indent = (x.depth - 1) * 12;
        const opacity = Math.max(0.5, 1 - (x.depth - 1) * 0.15);
        const prefix = x.depth > 1 ? " " : "";
        html += `<div class="lineage-link" data-attr-id="${x.id}" style="padding-left: ${indent}px; opacity: ${opacity};">${prefix}${downAttr.fullName}</div>`;
      }
    });
    html += `</div>`;
  }
  if (sortedUpstream.length === 0 && sortedDownstream.length === 0) {
    html += `<div class="detail-value text-muted">No lineage connections</div>`;
  }
  html += `</div>`;
  html += `<div class="lineage-json-view" style="display: none;">
        <div class="detail-label">LINEAGE JSON</div>
        <pre class="lineage-json-pre">${JSON.stringify(lineageJson, null, 2)}</pre>
    </div>`;
  content.innerHTML = html;
  const slider = content.querySelector(".lineage-toggle-slider");
  if (slider) {
    slider.addEventListener("click", function() {
      const isJson = this.classList.toggle("json-active");
      const treeView = content.querySelector(".lineage-tree-view");
      const jsonView = content.querySelector(".lineage-json-view");
      const treeLabel = content.querySelector('.lineage-toggle-label[data-view="tree"]');
      const jsonLabel = content.querySelector('.lineage-toggle-label[data-view="json"]');
      if (isJson) {
        treeView.style.display = "none";
        jsonView.style.display = "block";
        treeLabel.classList.remove("active");
        jsonLabel.classList.add("active");
      } else {
        treeView.style.display = "block";
        jsonView.style.display = "none";
        treeLabel.classList.add("active");
        jsonLabel.classList.remove("active");
      }
    });
  }
  content.querySelectorAll(".lineage-link").forEach((el) => {
    el.addEventListener("click", function() {
      const attrId2 = this.getAttribute("data-attr-id");
      if (attrId2) selectAttribute(attrId2);
    });
  });
}
function showDatasourceInAttributePanel(ds) {
  state.selectedAttribute = null;
  var dsId = ds.name.replace(/[^a-zA-Z0-9]/g, "_");
  var dsLineage = state.datasourceLineageMap[dsId] || { upstream: [], downstream: [] };
  var upstreamList = dsLineage.upstream || [];
  var downstreamList = dsLineage.downstream || [];
  var connectedIds = /* @__PURE__ */ new Set();
  upstreamList.forEach(function(x) {
    connectedIds.add(x.id);
  });
  downstreamList.forEach(function(x) {
    connectedIds.add(x.id);
  });
  d3.select("#attribute-graph").selectAll(".node").classed("node-highlighted", false).classed("node-connected", false).classed("node-dimmed", false);
  d3.select("#attribute-graph").selectAll(".edge").classed("edge-highlighted", false).classed("edge-dimmed", false);
  d3.select("#attribute-graph").selectAll(".cluster").classed("cluster-highlighted", false).classed("cluster-connected", false).classed("cluster-dimmed", false);
  d3.select("#attribute-graph").selectAll(".cluster").each(function() {
    const cluster = d3.select(this);
    const title = cluster.select("title").text();
    if (title && title.startsWith("cluster_")) {
      const clusterId = title.substring(8);
      if (clusterId === dsId) {
        cluster.classed("cluster-highlighted", true);
      } else if (connectedIds.has(clusterId)) {
        cluster.classed("cluster-connected", true);
      }
    }
  });
  const col = document.getElementById("attribute-details-col");
  const graphCol = document.getElementById("attribute-graph-col");
  const content = document.getElementById("attribute-details-content");
  graphCol.classList.remove("col-md-12");
  graphCol.classList.add("col-md-8");
  col.style.display = "block";
  setTimeout(() => {
    if (state.attributeGraphviz) state.attributeGraphviz.fit(true);
  }, 50);
  let html = `<h5>${ds.name}</h5>`;
  if (ds.type) {
    html += `<div class="detail-label">TYPE</div>`;
    html += `<div class="detail-value"><span class="badge badge-${ds.type}">${ds.type.toUpperCase()}</span></div>`;
  }
  if (upstreamList.length > 0) {
    html += '<div class="detail-label">UPSTREAM (' + upstreamList.length + ")</div>";
    html += '<div class="detail-value">';
    upstreamList.forEach(function(item) {
      var depth = item.depth;
      var indent = (depth - 1) * 16;
      var opacity = Math.max(0.4, 1 - (depth - 1) * 0.2);
      var found = (state.currentConfig.datasources || []).find(function(d) {
        return d.name.replace(/[^a-zA-Z0-9]/g, "_") === item.id;
      });
      var name = found ? found.name : item.id;
      var prefix = depth > 1 ? " " : "";
      html += '<div class="lineage-link" data-ds-name="' + name + '" style="padding-left: ' + indent + "px; opacity: " + opacity + ';">' + prefix + name + "</div>";
    });
    html += "</div>";
  }
  if (downstreamList.length > 0) {
    html += '<div class="detail-label">DOWNSTREAM (' + downstreamList.length + ")</div>";
    html += '<div class="detail-value">';
    downstreamList.forEach(function(item) {
      var depth = item.depth;
      var indent = (depth - 1) * 16;
      var opacity = Math.max(0.4, 1 - (depth - 1) * 0.2);
      var found = (state.currentConfig.datasources || []).find(function(d) {
        return d.name.replace(/[^a-zA-Z0-9]/g, "_") === item.id;
      });
      var name = found ? found.name : item.id;
      var prefix = depth > 1 ? " " : "";
      html += '<div class="lineage-link" data-ds-name="' + name + '" style="padding-left: ' + indent + "px; opacity: " + opacity + ';">' + prefix + name + "</div>";
    });
    html += "</div>";
  }
  if (ds.description) {
    html += `<div class="detail-label">Description</div>`;
    html += `<div class="detail-value">${ds.description}</div>`;
  }
  if (ds.owner) {
    html += `<div class="detail-label">Owner</div>`;
    html += `<div class="detail-value">${ds.owner}</div>`;
  }
  if (ds.cluster) {
    html += `<div class="detail-label">Cluster</div>`;
    html += `<div class="detail-value"><span class="badge badge-cluster">${ds.cluster}</span></div>`;
  }
  if (ds.tags && ds.tags.length > 0) {
    html += `<div class="detail-label">Tags</div>`;
    html += `<div class="detail-value">${ds.tags.map((t) => `<span class="badge me-1 mb-1" style="background-color: #fff3cd; color: #856404;">${t}</span>`).join("")}</div>`;
  }
  if (ds.attributes && ds.attributes.length > 0) {
    let countAttrs2 = function(attrs) {
      attrs.forEach((attr) => {
        attrCount++;
        if (attr.attributes) countAttrs2(attr.attributes);
      });
    }, listAttrs2 = function(attrs, indent = 0) {
      attrs.forEach((attr) => {
        const hasChildren = attr.attributes && attr.attributes.length > 0;
        html += `<div class="small" style="padding-left: ${indent * 12}px;">${hasChildren ? " " : ""}${attr.name}</div>`;
        if (attr.attributes) listAttrs2(attr.attributes, indent + 1);
      });
    };
    var countAttrs = countAttrs2, listAttrs = listAttrs2;
    let attrCount = 0;
    countAttrs2(ds.attributes);
    html += `<div class="detail-label">Attributes (${attrCount})</div>`;
    html += `<div class="detail-value">`;
    listAttrs2(ds.attributes);
    html += `</div>`;
  }
  if (ds.metadata && Object.keys(ds.metadata).length) {
    html += `<div class="detail-label">Metadata</div>`;
    html += `<div class="detail-value">`;
    Object.entries(ds.metadata).forEach(([key, value]) => {
      html += `<div class="small"><strong>${key.replace(/_/g, " ")}:</strong> ${value}</div>`;
    });
    html += `</div>`;
  }
  if (ds.links && Object.keys(ds.links).length) {
    html += `<div class="links-section">`;
    html += `<div class="detail-label">Links</div>`;
    Object.entries(ds.links).forEach(([name, url]) => {
      html += `<a href="${url}" target="_blank" class="graph-ctrl-btn link-btn">${name}</a>`;
    });
    html += `</div>`;
  }
  content.innerHTML = html;
  content.querySelectorAll(".lineage-link[data-ds-name]").forEach((el) => {
    el.addEventListener("click", function() {
      const dsName = this.getAttribute("data-ds-name");
      const targetDs = (state.currentConfig.datasources || []).find((d) => d.name === dsName);
      if (targetDs) showDatasourceInAttributePanel(targetDs);
    });
  });
}
function clearAttributeSelection() {
  state.selectedAttribute = null;
  d3.select("#attribute-graph").selectAll(".node").classed("node-highlighted", false).classed("node-connected", false).classed("node-dimmed", false);
  d3.select("#attribute-graph").selectAll(".cluster").classed("cluster-highlighted", false).classed("cluster-connected", false).classed("cluster-dimmed", false);
  d3.select("#attribute-graph").selectAll(".edge").classed("edge-highlighted", false).classed("edge-dimmed", false);
  const col = document.getElementById("attribute-details-col");
  const graphCol = document.getElementById("attribute-graph-col");
  col.style.display = "none";
  graphCol.classList.remove("col-md-8");
  graphCol.classList.add("col-md-12");
  setTimeout(() => {
    if (state.attributeGraphviz) state.attributeGraphviz.fit(true);
  }, 50);
}
function searchAttributes(event) {
  const resultsDiv = document.getElementById("attribute-search-results");
  const items = resultsDiv.querySelectorAll(".search-result-item[data-id]");
  if (event.key === "ArrowDown" || event.key === "ArrowUp") {
    event.preventDefault();
    if (items.length === 0) return;
    const current = resultsDiv.querySelector(".search-result-item.selected");
    let index = current ? Array.from(items).indexOf(current) : -1;
    if (event.key === "ArrowDown") {
      index = index < items.length - 1 ? index + 1 : 0;
    } else {
      index = index > 0 ? index - 1 : items.length - 1;
    }
    items.forEach((item) => item.classList.remove("selected"));
    items[index].classList.add("selected");
    items[index].scrollIntoView({ block: "nearest" });
    return;
  }
  if (event.key === "Enter") {
    const selected = resultsDiv.querySelector(".search-result-item.selected");
    if (selected && selected.dataset.id) {
      selectAttributeFromSearch(selected.dataset.id);
    }
    return;
  }
  if (event.key === "Escape") {
    resultsDiv.classList.remove("show");
    resultsDiv.innerHTML = "";
    return;
  }
  const query = event.target.value.toLowerCase().trim();
  if (query.length < 2) {
    resultsDiv.classList.remove("show");
    return;
  }
  const matches = [];
  Object.values(state.attributeLineageMap).forEach((attr) => {
    if (attr.fullName.toLowerCase().includes(query) || attr.name.toLowerCase().includes(query)) {
      matches.push(attr);
    }
  });
  if (matches.length === 0) {
    resultsDiv.classList.remove("show");
    return;
  }
  let html = "";
  matches.slice(0, 10).forEach((attr, i) => {
    html += `<div class="search-result-item${i === 0 ? " selected" : ""}" data-id="${attr.id}" onclick="selectAttributeFromSearch('${attr.id}')">
            <span class="result-type datasource">${attr.datasource}</span>
            <span class="result-name">${attr.name}</span>
        </div>`;
  });
  resultsDiv.innerHTML = html;
  resultsDiv.classList.add("show");
}
function selectAttributeFromSearch(attrId) {
  document.getElementById("attribute-search-results").classList.remove("show");
  document.getElementById("attribute-search").value = "";
  selectAttribute(attrId);
}
document.addEventListener("click", function(e) {
  if (!e.target.closest("#attribute-search") && !e.target.closest("#attribute-search-results")) {
    document.getElementById("attribute-search-results")?.classList.remove("show");
  }
});
document.getElementById("attributes-tab")?.addEventListener("shown.bs.tab", function() {
  const newHash = getConfigHash(state.currentConfig);
  if (!state.attributeGraphviz || newHash !== state.attributeLastRenderedConfigHash) {
    setTimeout(() => {
      buildAttributeLineageMap();
      renderAttributeGraph();
      state.attributeLastRenderedConfigHash = newHash;
    }, 100);
  }
});
function generateBlastRadiusAnalysis(nodeName) {
  if (!state.currentConfig || !nodeName) return null;
  const pipelines = state.currentConfig.pipelines || [];
  const datasources = state.currentConfig.datasources || [];
  const groupMembers = pipelines.filter((p) => p.group === nodeName);
  const isGroup = groupMembers.length > 0;
  const downstream = /* @__PURE__ */ new Map();
  const nodeTypes = /* @__PURE__ */ new Map();
  pipelines.forEach((p) => {
    nodeTypes.set(p.name, "pipeline");
    if (!downstream.has(p.name)) downstream.set(p.name, /* @__PURE__ */ new Set());
    p.output_sources?.forEach((s) => {
      downstream.get(p.name).add(s);
      if (!nodeTypes.has(s)) nodeTypes.set(s, "datasource");
    });
    p.input_sources?.forEach((s) => {
      if (!downstream.has(s)) downstream.set(s, /* @__PURE__ */ new Set());
      downstream.get(s).add(p.name);
      if (!nodeTypes.has(s)) nodeTypes.set(s, "datasource");
    });
    p.upstream_pipelines?.forEach((u) => {
      if (!downstream.has(u)) downstream.set(u, /* @__PURE__ */ new Set());
      downstream.get(u).add(p.name);
    });
  });
  datasources.forEach((ds) => {
    if (!nodeTypes.has(ds.name)) nodeTypes.set(ds.name, "datasource");
  });
  const visited = /* @__PURE__ */ new Map();
  const edges = [];
  const startNodes = isGroup ? groupMembers.map((p) => p.name) : [nodeName];
  const groupMemberNames = new Set(startNodes);
  startNodes.forEach((startNode) => {
    if (!visited.has(startNode)) {
      visited.set(startNode, 0);
    }
  });
  const queue = startNodes.map((n) => [n, 0]);
  while (queue.length > 0) {
    const [current, depth] = queue.shift();
    const neighbors = downstream.get(current) || /* @__PURE__ */ new Set();
    for (const neighbor of neighbors) {
      if (isGroup && groupMemberNames.has(current) && groupMemberNames.has(neighbor)) {
        continue;
      }
      edges.push({ source: isGroup ? nodeName : current, target: neighbor });
      if (!visited.has(neighbor)) {
        visited.set(neighbor, depth + 1);
        queue.push([neighbor, depth + 1]);
      }
    }
  }
  const downstreamNodes = [];
  visited.forEach((depth, node) => {
    const isSourceOrMember = isGroup ? groupMemberNames.has(node) : node === nodeName;
    if (!isSourceOrMember) {
      const type = nodeTypes.get(node) || "unknown";
      const pipeline = pipelines.find((p) => p.name === node);
      const nodeInfo = { name: node, type, depth };
      if (pipeline) {
        if (pipeline.schedule) nodeInfo.schedule = pipeline.schedule;
        if (pipeline.cluster) nodeInfo.cluster = pipeline.cluster;
      }
      downstreamNodes.push(nodeInfo);
    }
  });
  downstreamNodes.sort((a, b) => a.depth - b.depth || a.name.localeCompare(b.name));
  const byDepth = {};
  downstreamNodes.forEach((n) => {
    if (!byDepth[n.depth]) byDepth[n.depth] = [];
    byDepth[n.depth].push(n);
  });
  const maxDepth = Math.max(...downstreamNodes.map((n) => n.depth), 0);
  const result = {
    source: nodeName,
    source_type: isGroup ? "group" : nodeTypes.get(nodeName) || "unknown",
    total_affected: downstreamNodes.length,
    max_depth: maxDepth,
    downstream: downstreamNodes,
    by_depth: byDepth,
    edges
  };
  if (isGroup) {
    result.group_members = groupMembers.map((p) => p.name);
    result.group_size = groupMembers.length;
  }
  return result;
}
function generateBlastRadiusDot(analysis) {
  if (!analysis || analysis.downstream.length === 0) return null;
  const isDark = document.documentElement.getAttribute("data-theme") === "dark";
  const bgColor = isDark ? "#1a1a1a" : "#ffffff";
  const textColor = isDark ? "#b0b0b0" : "#666666";
  const edgeColor = isDark ? "#666666" : "#999999";
  const depthColors = isDark ? [
    { fill: "#4a2a2a", border: "#c98b8b", text: "#e0e0e0" },
    // Source - warm red
    { fill: "#4a3a2a", border: "#d4a574", text: "#e0e0e0" },
    // Depth 1 - orange
    { fill: "#4a4a2a", border: "#c4c474", text: "#e0e0e0" },
    // Depth 2 - yellow
    { fill: "#2a4a3a", border: "#7cb47c", text: "#e0e0e0" },
    // Depth 3 - green
    { fill: "#2a3a4a", border: "#6b9dc4", text: "#e0e0e0" },
    // Depth 4 - blue
    { fill: "#3a2a4a", border: "#a88bc4", text: "#e0e0e0" }
    // Depth 5+ - purple
  ] : [
    { fill: "#fce4ec", border: "#c98b8b", text: "#495057" },
    // Source - warm red
    { fill: "#fff3e0", border: "#d4a574", text: "#495057" },
    // Depth 1 - orange
    { fill: "#fffde7", border: "#c4c474", text: "#495057" },
    // Depth 2 - yellow
    { fill: "#e8f5e9", border: "#7cb47c", text: "#495057" },
    // Depth 3 - green
    { fill: "#e3f2fd", border: "#6b9dc4", text: "#495057" },
    // Depth 4 - blue
    { fill: "#f3e5f5", border: "#a88bc4", text: "#495057" }
    // Depth 5+ - purple
  ];
  let dot = `digraph BlastRadius {
    rankdir=LR
    bgcolor="${bgColor}"
    fontname="Helvetica"
    node [fontname="Helvetica" fontsize="9" style="filled"]
    edge [color="${edgeColor}" arrowsize="0.6"]
    
`;
  const sourceColor = depthColors[0];
  const isGroup = analysis.source_type === "group";
  const sourceShape = analysis.source_type === "datasource" ? "ellipse" : "box";
  const sourceLabel = isGroup ? `${analysis.source}\\n(${analysis.group_size} pipelines)` : analysis.source;
  const sourceBorderColor = isGroup ? "#00897b" : sourceColor.border;
  dot += `    "${analysis.source}" [label="${sourceLabel}" shape="${sourceShape}" fillcolor="${sourceColor.fill}" color="${sourceBorderColor}" fontcolor="${sourceColor.text}" penwidth="2"]

`;
  Object.entries(analysis.by_depth).forEach(([depth, nodes]) => {
    const colorIdx = Math.min(parseInt(depth), depthColors.length - 1);
    const colors = depthColors[colorIdx];
    dot += `    subgraph cluster_depth${depth} {
        label="Depth ${depth}"
        fontname="Helvetica"
        style="dashed"
        color="${colors.border}"
        fontcolor="${textColor}"
        fontsize="9"
        
`;
    nodes.forEach((node) => {
      const shape = node.type === "datasource" ? "ellipse" : "box";
      dot += `        "${node.name}" [label="${node.name}" shape="${shape}" fillcolor="${colors.fill}" color="${colors.border}" fontcolor="${colors.text}"]
`;
    });
    dot += `    }

`;
  });
  const addedEdges = /* @__PURE__ */ new Set();
  analysis.edges.forEach((edge) => {
    const key = `${edge.source}|${edge.target}`;
    if (!addedEdges.has(key)) {
      addedEdges.add(key);
      dot += `    "${edge.source}" -> "${edge.target}"
`;
    }
  });
  dot += `}
`;
  return dot;
}
let cachedCriticalPath = null;
let cachedCriticalPathHash = null;
let cachedCostliestPath = null;
let cachedCostliestPathHash = null;
function getCachedCriticalPath() {
  if (!state.currentConfig) return null;
  const hash = JSON.stringify(state.currentConfig.pipelines?.map((p) => [p.name, p.duration]));
  if (cachedCriticalPathHash !== hash) {
    cachedCriticalPathHash = hash;
    cachedCriticalPath = computeCriticalPath(state.currentConfig.pipelines || []);
  }
  return cachedCriticalPath;
}
function getCachedCostliestPath() {
  if (!state.currentConfig) return null;
  const hash = JSON.stringify(state.currentConfig.pipelines?.map((p) => [p.name, p.cost]));
  if (cachedCostliestPathHash !== hash) {
    cachedCostliestPathHash = hash;
    cachedCostliestPath = computeCostliestPath(state.currentConfig.pipelines || []);
  }
  return cachedCostliestPath;
}
function getCriticalPathNodes() {
  const cp = getCachedCriticalPath();
  if (!cp || !cp.path) return /* @__PURE__ */ new Set();
  return new Set(cp.path.map((p) => p.name));
}
function getCriticalPathEdges() {
  const cp = getCachedCriticalPath();
  if (!cp || !cp.path || cp.path.length < 2) return /* @__PURE__ */ new Set();
  const edges = /* @__PURE__ */ new Set();
  for (let i = 0; i < cp.path.length - 1; i++) {
    edges.add(`${cp.path[i].name}|${cp.path[i + 1].name}`);
  }
  return edges;
}
function getCostliestPathNodes() {
  const cp = getCachedCostliestPath();
  if (!cp || !cp.path) return /* @__PURE__ */ new Set();
  return new Set(cp.path.map((p) => p.name));
}
function getCostliestPathEdges() {
  const cp = getCachedCostliestPath();
  if (!cp || !cp.path || cp.path.length < 2) return /* @__PURE__ */ new Set();
  const edges = /* @__PURE__ */ new Set();
  for (let i = 0; i < cp.path.length - 1; i++) {
    edges.add(`${cp.path[i].name}|${cp.path[i + 1].name}`);
  }
  return edges;
}
const COLORS = ["#6b9dc4", "#a88bc4", "#d4a574", "#7cb47c", "#c98b8b", "#6bb5b5", "#a89080", "#8a9aa8"];
function computeCriticalPath(pipelines) {
  const pipelineMap = /* @__PURE__ */ new Map();
  pipelines.forEach((p) => pipelineMap.set(p.name, p));
  const hasDurations = pipelines.some((p) => p.duration !== void 0 && p.duration !== null);
  if (!hasDurations) return null;
  const graph = /* @__PURE__ */ new Map();
  const inDegree = /* @__PURE__ */ new Map();
  const pipelineNames = new Set(pipelines.map((p) => p.name));
  pipelines.forEach((p) => {
    if (!graph.has(p.name)) graph.set(p.name, []);
    if (!inDegree.has(p.name)) inDegree.set(p.name, 0);
  });
  const outputToProducer = /* @__PURE__ */ new Map();
  pipelines.forEach((p) => {
    p.output_sources?.forEach((ds) => outputToProducer.set(ds, p.name));
  });
  pipelines.forEach((p) => {
    p.upstream_pipelines?.forEach((upstream) => {
      if (pipelineNames.has(upstream)) {
        graph.get(upstream).push(p.name);
        inDegree.set(p.name, inDegree.get(p.name) + 1);
      }
    });
    p.input_sources?.forEach((ds) => {
      const producer = outputToProducer.get(ds);
      if (producer && producer !== p.name && !p.upstream_pipelines?.includes(producer)) {
        graph.get(producer).push(p.name);
        inDegree.set(p.name, inDegree.get(p.name) + 1);
      }
    });
  });
  const est = /* @__PURE__ */ new Map();
  const eft = /* @__PURE__ */ new Map();
  const predecessor = /* @__PURE__ */ new Map();
  pipelines.forEach((p) => {
    if (inDegree.get(p.name) === 0) {
      est.set(p.name, 0);
      eft.set(p.name, p.duration || 0);
    }
  });
  const queue = pipelines.filter((p) => inDegree.get(p.name) === 0).map((p) => p.name);
  while (queue.length > 0) {
    const current2 = queue.shift();
    graph.get(current2).forEach((neighbor) => {
      const newEst = eft.get(current2);
      if (!est.has(neighbor) || newEst > est.get(neighbor)) {
        est.set(neighbor, newEst);
        predecessor.set(neighbor, current2);
      }
      const neighborPipeline = pipelineMap.get(neighbor);
      const neighborDuration = neighborPipeline?.duration || 0;
      eft.set(neighbor, est.get(neighbor) + neighborDuration);
      inDegree.set(neighbor, inDegree.get(neighbor) - 1);
      if (inDegree.get(neighbor) === 0) {
        queue.push(neighbor);
      }
    });
  }
  let maxEft = 0;
  let criticalEnd = null;
  eft.forEach((time, node) => {
    if (time > maxEft) {
      maxEft = time;
      criticalEnd = node;
    }
  });
  if (!criticalEnd) return null;
  const criticalPath = [];
  let current = criticalEnd;
  let totalCost = 0;
  while (current) {
    const pipeline = pipelineMap.get(current);
    const nodeCost = pipeline?.cost || 0;
    totalCost += nodeCost;
    criticalPath.unshift({
      name: current,
      duration: pipeline?.duration || 0,
      cost: nodeCost,
      est: est.get(current) || 0,
      eft: eft.get(current) || 0
    });
    current = predecessor.get(current);
  }
  const slack = /* @__PURE__ */ new Map();
  const criticalNodes = new Set(criticalPath.map((n) => n.name));
  pipelines.forEach((p) => {
    if (criticalNodes.has(p.name)) {
      slack.set(p.name, 0);
    } else if (est.has(p.name)) {
      slack.set(p.name, maxEft - eft.get(p.name));
    }
  });
  return {
    totalDuration: maxEft,
    totalCost,
    path: criticalPath,
    pipelinesWithDuration: pipelines.filter((p) => p.duration !== void 0).length,
    pipelinesWithCost: pipelines.filter((p) => p.cost !== void 0).length,
    totalPipelines: pipelines.length,
    slack
  };
}
function computeCostliestPath(pipelines) {
  const pipelineMap = /* @__PURE__ */ new Map();
  pipelines.forEach((p) => pipelineMap.set(p.name, p));
  const hasCosts = pipelines.some((p) => p.cost !== void 0 && p.cost !== null);
  if (!hasCosts) return null;
  const graph = /* @__PURE__ */ new Map();
  const inDegree = /* @__PURE__ */ new Map();
  const pipelineNames = new Set(pipelines.map((p) => p.name));
  pipelines.forEach((p) => {
    if (!graph.has(p.name)) graph.set(p.name, []);
    if (!inDegree.has(p.name)) inDegree.set(p.name, 0);
  });
  const outputToProducer = /* @__PURE__ */ new Map();
  pipelines.forEach((p) => {
    p.output_sources?.forEach((ds) => outputToProducer.set(ds, p.name));
  });
  pipelines.forEach((p) => {
    p.upstream_pipelines?.forEach((upstream) => {
      if (pipelineNames.has(upstream)) {
        graph.get(upstream).push(p.name);
        inDegree.set(p.name, inDegree.get(p.name) + 1);
      }
    });
    p.input_sources?.forEach((ds) => {
      const producer = outputToProducer.get(ds);
      if (producer && producer !== p.name && !p.upstream_pipelines?.includes(producer)) {
        graph.get(producer).push(p.name);
        inDegree.set(p.name, inDegree.get(p.name) + 1);
      }
    });
  });
  const costToNode = /* @__PURE__ */ new Map();
  const predecessor = /* @__PURE__ */ new Map();
  pipelines.forEach((p) => {
    if (inDegree.get(p.name) === 0) {
      costToNode.set(p.name, p.cost || 0);
    }
  });
  const queue = pipelines.filter((p) => inDegree.get(p.name) === 0).map((p) => p.name);
  const inDegreeCopy = new Map(inDegree);
  while (queue.length > 0) {
    const current2 = queue.shift();
    const currentCost = costToNode.get(current2) || 0;
    graph.get(current2).forEach((neighbor) => {
      const neighborPipeline = pipelineMap.get(neighbor);
      const neighborCost = neighborPipeline?.cost || 0;
      const newCost = currentCost + neighborCost;
      if (!costToNode.has(neighbor) || newCost > costToNode.get(neighbor)) {
        costToNode.set(neighbor, newCost);
        predecessor.set(neighbor, current2);
      }
      inDegreeCopy.set(neighbor, inDegreeCopy.get(neighbor) - 1);
      if (inDegreeCopy.get(neighbor) === 0) {
        queue.push(neighbor);
      }
    });
  }
  let maxCost = 0;
  let costliestEnd = null;
  costToNode.forEach((cost, node) => {
    if (cost > maxCost) {
      maxCost = cost;
      costliestEnd = node;
    }
  });
  if (!costliestEnd) return null;
  const costliestPath = [];
  let current = costliestEnd;
  let totalDuration = 0;
  while (current) {
    const pipeline = pipelineMap.get(current);
    totalDuration += pipeline?.duration || 0;
    costliestPath.unshift({
      name: current,
      cost: pipeline?.cost || 0,
      duration: pipeline?.duration || 0
    });
    current = predecessor.get(current);
  }
  return {
    totalCost: maxCost,
    totalDuration,
    path: costliestPath,
    pipelinesWithCost: pipelines.filter((p) => p.cost !== void 0).length,
    totalPipelines: pipelines.length
  };
}
function detectCycles(pipelines) {
  const graph = /* @__PURE__ */ new Map();
  const pipelineNames = /* @__PURE__ */ new Set();
  pipelines.forEach((p) => {
    const nodeName = p.group || p.name;
    pipelineNames.add(nodeName);
    if (!graph.has(nodeName)) graph.set(nodeName, /* @__PURE__ */ new Set());
  });
  pipelines.forEach((p) => {
    const nodeName = p.group || p.name;
    p.upstream_pipelines?.forEach((upstream) => {
      if (pipelineNames.has(upstream)) {
        if (!graph.has(upstream)) graph.set(upstream, /* @__PURE__ */ new Set());
        graph.get(upstream).add(nodeName);
      }
    });
  });
  const cycles = [];
  const visited = /* @__PURE__ */ new Set();
  const recStack = /* @__PURE__ */ new Set();
  function dfs(node, path) {
    visited.add(node);
    recStack.add(node);
    path.push(node);
    for (const neighbor of graph.get(node) || /* @__PURE__ */ new Set()) {
      if (!visited.has(neighbor)) {
        const result = dfs(neighbor, path);
        if (result) return result;
      } else if (recStack.has(neighbor)) {
        const cycleStart = path.indexOf(neighbor);
        const cycle = path.slice(cycleStart);
        cycle.push(neighbor);
        return cycle;
      }
    }
    path.pop();
    recStack.delete(node);
    return null;
  }
  for (const node of pipelineNames) {
    if (!visited.has(node)) {
      const cycle = dfs(node, []);
      if (cycle) {
        cycles.push(cycle);
        visited.clear();
        recStack.clear();
        cycle.forEach((n) => visited.add(n));
      }
    }
  }
  return cycles;
}
function computeStats() {
  if (!state.currentConfig) return null;
  const pipelines = state.currentConfig.pipelines || [];
  const datasources = state.currentConfig.datasources || [];
  const cycles = detectCycles(pipelines);
  const criticalPath = computeCriticalPath(pipelines);
  const costliestPath = computeCostliestPath(pipelines);
  const upstreamCounts = /* @__PURE__ */ new Map();
  const downstreamCounts = /* @__PURE__ */ new Map();
  const groups = /* @__PURE__ */ new Set();
  pipelines.forEach((p) => {
    if (p.group) groups.add(p.group);
  });
  pipelines.forEach((p) => {
    const nodeName = p.group || p.name;
    p.input_sources?.forEach((s) => {
      downstreamCounts.set(s, (downstreamCounts.get(s) || 0) + 1);
      upstreamCounts.set(nodeName, (upstreamCounts.get(nodeName) || 0) + 1);
    });
    p.output_sources?.forEach((s) => {
      downstreamCounts.set(nodeName, (downstreamCounts.get(nodeName) || 0) + 1);
      upstreamCounts.set(s, (upstreamCounts.get(s) || 0) + 1);
    });
    p.upstream_pipelines?.forEach((u) => {
      downstreamCounts.set(u, (downstreamCounts.get(u) || 0) + 1);
      upstreamCounts.set(nodeName, (upstreamCounts.get(nodeName) || 0) + 1);
    });
  });
  const pipelineNames = new Set(pipelines.map((p) => p.name));
  const allNodes = /* @__PURE__ */ new Set([...upstreamCounts.keys(), ...downstreamCounts.keys()]);
  const hubs = [...allNodes].map((name) => {
    let type = "datasource";
    if (groups.has(name)) type = "group";
    else if (pipelineNames.has(name)) type = "pipeline";
    return {
      name,
      type,
      upstream: upstreamCounts.get(name) || 0,
      downstream: downstreamCounts.get(name) || 0,
      total: (upstreamCounts.get(name) || 0) + (downstreamCounts.get(name) || 0)
    };
  }).sort((a, b) => b.total - a.total).slice(0, 8);
  const referencedSources = /* @__PURE__ */ new Set();
  pipelines.forEach((p) => {
    p.input_sources?.forEach((s) => referencedSources.add(s));
    p.output_sources?.forEach((s) => referencedSources.add(s));
  });
  const orphaned = datasources.filter((ds) => !referencedSources.has(ds.name)).map((ds) => ds.name);
  const clusterCounts = {};
  pipelines.forEach((p) => {
    const cluster = p.cluster || "unclustered";
    clusterCounts[cluster] = (clusterCounts[cluster] || 0) + 1;
  });
  const typeCounts = {};
  datasources.forEach((ds) => {
    const type = ds.type || "unknown";
    typeCounts[type] = (typeCounts[type] || 0) + 1;
  });
  return {
    counts: {
      pipelines: pipelines.length,
      datasources: datasources.length,
      clusters: Object.keys(clusterCounts).filter((c) => c !== "unclustered").length
    },
    cycles,
    criticalPath,
    costliestPath,
    hubs,
    orphaned,
    coverage: {
      schedules: {
        covered: pipelines.filter((p) => p.schedule).length,
        total: pipelines.length,
        missing: pipelines.filter((p) => !p.schedule).map((p) => p.name)
      },
      airflow: {
        covered: pipelines.filter((p) => p.links?.airflow).length,
        total: pipelines.length,
        missing: pipelines.filter((p) => !p.links?.airflow).map((p) => p.name)
      }
    },
    distributions: { clusters: clusterCounts, types: typeCounts }
  };
}
function renderStats() {
  const container = document.getElementById("stats-content");
  if (!container) return;
  const stats = computeStats();
  if (!stats) {
    container.innerHTML = '<div class="text-muted">Load a configuration to see statistics.</div>';
    return;
  }
  const clusterData = Object.entries(stats.distributions.clusters).sort((a, b) => b[1] - a[1]).map(([label, value]) => ({ label, value }));
  const typeData = Object.entries(stats.distributions.types).sort((a, b) => b[1] - a[1]).map(([label, value]) => ({ label, value }));
  let html = `
        <div class="stats-summary">
            <span><strong>${stats.counts.pipelines}</strong> pipelines</span>
            <span><strong>${stats.counts.datasources}</strong> datasources</span>
            <span><strong>${stats.counts.clusters}</strong> clusters</span>
        </div>
        <div class="stats-row">
            <div class="chart-box">
                <div class="chart-title">Pipelines by Cluster</div>
                <div class="pie-container">
                    ${renderPieChart(clusterData, 120)}
                    <div class="pie-legend">${renderPieLegend(clusterData)}</div>
                </div>
            </div>
            <div class="chart-box">
                <div class="chart-title">Datasources by Type</div>
                <div class="pie-container">
                    ${renderPieChart(typeData, 120)}
                    <div class="pie-legend">${renderPieLegend(typeData)}</div>
                </div>
            </div>
        </div>
        <div class="stats-row">
            <div class="stats-section">
                <div class="section-title">Coverage</div>
                <div class="coverage-bars">
                    ${renderCoverageBar("Schedules", stats.coverage.schedules)}
                    ${renderCoverageBar("Airflow Links", stats.coverage.airflow)}
                </div>
            </div>
            ${stats.hubs.length > 0 ? `
                <div class="stats-section">
                    <div class="section-title">Hubs <span class="section-hint">most connected</span></div>
                    <div class="hub-list">
                        ${stats.hubs.map(
    (h, i) => `
                            <div class="hub-row">
                                <span class="hub-rank">${i + 1}</span>
                                <span class="hub-name ${h.type}">${h.name}</span>
                                <span class="hub-stats">${h.upstream} ${h.downstream}</span>
                            </div>
                        `
  ).join("")}
                    </div>
                </div>
            ` : ""}
        </div>`;
  if (stats.criticalPath) {
    const cp = stats.criticalPath;
    const formatDuration = (mins) => {
      if (mins >= 60) {
        const hrs = Math.floor(mins / 60);
        const rem = mins % 60;
        return rem > 0 ? `${hrs}h${rem}m` : `${hrs}h`;
      }
      return `${mins}m`;
    };
    const formatTime = (mins) => {
      const hrs = Math.floor(mins / 60);
      const rem = mins % 60;
      return `${String(hrs).padStart(2, "0")}:${String(rem).padStart(2, "0")}`;
    };
    const formatCost = (cost) => cost > 0 ? `$${cost.toFixed(2)}` : "";
    html += `
            <div class="stats-section critical-path-section">
                <div class="section-title">Critical Path</div>
                <div class="critical-path-summary">
                    <div class="cp-stat">
                        <span class="cp-stat-value">${formatDuration(cp.totalDuration)}</span>
                        <span class="cp-stat-label">duration</span>
                    </div>
                    ${cp.totalCost > 0 ? `
                    <div class="cp-stat">
                        <span class="cp-stat-value">$${cp.totalCost.toFixed(2)}</span>
                        <span class="cp-stat-label">path cost</span>
                    </div>
                    ` : ""}
                    <span class="cp-coverage">${cp.pipelinesWithDuration}/${cp.totalPipelines} with duration</span>
                </div>
                <div class="critical-path-gantt">
                    ${cp.path.map(
      (node) => `
                        <div class="cp-bar-row">
                            <span class="cp-bar-label">${node.name}</span>
                            <div class="cp-bar-track">
                                <div class="cp-bar-fill" style="left: ${node.est / cp.totalDuration * 100}%; width: ${node.duration / cp.totalDuration * 100}%">
                                    <span class="cp-bar-duration">${formatDuration(node.duration)}</span>
                                </div>
                            </div>
                            <span class="cp-bar-cost">${formatCost(node.cost)}</span>
                            <span class="cp-bar-time">${formatTime(node.eft)}</span>
                        </div>
                    `
    ).join("")}
                </div>
            </div>`;
  }
  if (stats.costliestPath) {
    const costPath = stats.costliestPath;
    const critPath = stats.criticalPath;
    const isDifferent = !critPath || costPath.path.length !== critPath.path.length || costPath.path.some((n, i) => n.name !== critPath.path[i]?.name);
    if (isDifferent) {
      const formatDuration = (mins) => {
        if (mins >= 60) {
          const hrs = Math.floor(mins / 60);
          const rem = mins % 60;
          return rem > 0 ? `${hrs}h${rem}m` : `${hrs}h`;
        }
        return `${mins}m`;
      };
      html += `
            <div class="stats-section costliest-path-section">
                <div class="section-title">Costliest Path</div>
                <div class="critical-path-summary">
                    <div class="cp-stat">
                        <span class="cp-stat-value" style="color: #2e7d32;">$${costPath.totalCost.toFixed(2)}</span>
                        <span class="cp-stat-label">total cost</span>
                    </div>
                    ${costPath.totalDuration > 0 ? `
                    <div class="cp-stat">
                        <span class="cp-stat-value" style="color: #2e7d32;">${formatDuration(costPath.totalDuration)}</span>
                        <span class="cp-stat-label">duration</span>
                    </div>
                    ` : ""}
                    <span class="cp-coverage">${costPath.pipelinesWithCost}/${costPath.totalPipelines} with cost</span>
                </div>
                <div class="critical-path-gantt">
                    ${costPath.path.map((node, i) => {
        const cumCost = costPath.path.slice(0, i + 1).reduce((sum, n) => sum + n.cost, 0);
        return `
                        <div class="cp-bar-row">
                            <span class="cp-bar-label">${node.name}</span>
                            <div class="cp-bar-track">
                                <div class="cp-bar-fill" style="left: 0; width: ${cumCost / costPath.totalCost * 100}%; background: linear-gradient(90deg, #a5d6a7 0%, #66bb6a 100%);">
                                    <span class="cp-bar-duration" style="color: #1b5e20;">$${node.cost.toFixed(2)}</span>
                                </div>
                            </div>
                            <span class="cp-bar-cost">$${cumCost.toFixed(2)}</span>
                        </div>
                    `;
      }).join("")}
                </div>
            </div>`;
    }
  }
  if (stats.cycles.length > 0) {
    html += `
            <div class="stats-section cycles-warning">
                <div class="section-title"> Cycles Detected <span class="cycle-count">${stats.cycles.length}</span></div>
                <div class="section-hint">Circular dependencies in pipeline graph</div>
                <div class="cycle-list">
                    ${stats.cycles.map(
      (cycle, i) => `
                        <div class="cycle-item">
                            <span class="cycle-label">#${i + 1}</span>
                            <span class="cycle-path">${cycle.join(" > ")}</span>
                        </div>
                    `
    ).join("")}
                </div>
            </div>`;
  }
  const hasMissing = stats.coverage.schedules.missing.length > 0 || stats.coverage.airflow.missing.length > 0 || stats.orphaned.length > 0;
  if (hasMissing) {
    html += `
            <div class="stats-section">
                <div class="section-title">Needs Attention</div>
                <div class="missing-scroll">
                    ${renderMissingBlock("Missing Schedule", stats.coverage.schedules.missing, "pipeline")}
                    ${renderMissingBlock("Missing Airflow Link", stats.coverage.airflow.missing, "pipeline")}
                    ${renderMissingBlock("Orphaned", stats.orphaned, "orphan")}
                </div>
            </div>`;
  } else if (stats.cycles.length === 0) {
    html += `
            <div class="stats-section all-good">
                <div class="section-title"> All Good</div>
                <div class="section-hint">No cycles, coverage gaps, or orphaned nodes.</div>
            </div>`;
  }
  container.innerHTML = html;
}
function renderCoverageBar(label, data) {
  const pct = data.total > 0 ? Math.round(data.covered / data.total * 100) : 100;
  const color = pct >= 80 ? "good" : pct >= 50 ? "okay" : "low";
  return `<div class="coverage-row">
        <span class="coverage-label">${label}</span>
        <div class="coverage-bar-wrap"><div class="coverage-bar ${color}" style="width: ${pct}%"></div></div>
        <span class="coverage-pct ${color}">${pct}%</span>
    </div>`;
}
function renderMissingBlock(label, items, type) {
  if (items.length === 0) return "";
  return `<div class="missing-block">
        <div class="missing-header">${label} <span class="missing-count">${items.length}</span></div>
        <div class="missing-names ${type}">${items.join(", ")}</div>
    </div>`;
}
function renderPieChart(data, size = 80) {
  if (!data?.length) return "";
  const total = data.reduce((sum, d) => sum + d.value, 0);
  if (total === 0) return "";
  let currentAngle = -90;
  let paths = "";
  data.forEach((d, i) => {
    const angle = d.value / total * 360;
    const startRad = currentAngle * Math.PI / 180;
    const endRad = (currentAngle + angle) * Math.PI / 180;
    const r = size / 2 - 1, cx = size / 2, cy = size / 2;
    const x1 = cx + r * Math.cos(startRad), y1 = cy + r * Math.sin(startRad);
    const x2 = cx + r * Math.cos(endRad), y2 = cy + r * Math.sin(endRad);
    const color = COLORS[i % COLORS.length];
    paths += data.length === 1 ? `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${color}" />` : `<path d="M ${cx} ${cy} L ${x1} ${y1} A ${r} ${r} 0 ${angle > 180 ? 1 : 0} 1 ${x2} ${y2} Z" fill="${color}" />`;
    currentAngle += angle;
  });
  return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">${paths}</svg>`;
}
function renderPieLegend(data) {
  const total = data.reduce((sum, d) => sum + d.value, 0);
  return data.map((d, i) => {
    const pct = total > 0 ? Math.round(d.value / total * 100) : 0;
    return `<div class="pie-legend-row">
            <span class="pie-legend-dot" style="background:${COLORS[i % COLORS.length]}"></span>
            <span class="pie-legend-name">${d.label}</span>
            <span class="pie-legend-val">${d.value} (${pct}%)</span>
        </div>`;
  }).join("");
}
let blastRadiusGraphInstance = null;
function generateGraphvizDot() {
  if (!state.currentConfig) return "";
  const isDark = document.documentElement.getAttribute("data-theme") === "dark";
  const edgeColor = isDark ? "#b0b0b0" : "#555";
  let pipelines = state.currentConfig.pipelines || [];
  const datasources = state.currentConfig.datasources || [];
  const explicitClusters = state.currentConfig.clusters || [];
  {
    const groups = /* @__PURE__ */ new Map();
    const ungroupedPipelines = [];
    pipelines.forEach((p) => {
      if (p.group && !state.expandedGroups.has(p.group)) {
        if (!groups.has(p.group)) {
          groups.set(p.group, {
            name: p.group,
            description: `Grouped pipelines: ${p.group}`,
            input_sources: /* @__PURE__ */ new Set(),
            output_sources: /* @__PURE__ */ new Set(),
            upstream_pipelines: /* @__PURE__ */ new Set(),
            cluster: p.cluster,
            _isGroup: true,
            _members: []
          });
        }
        const group = groups.get(p.group);
        p.input_sources?.forEach((s) => group.input_sources.add(s));
        p.output_sources?.forEach((s) => group.output_sources.add(s));
        p.upstream_pipelines?.forEach((u) => group.upstream_pipelines.add(u));
        group._members.push(p.name);
      } else {
        ungroupedPipelines.push(p);
      }
    });
    const groupedPipelines = Array.from(groups.values()).map((g) => ({
      ...g,
      input_sources: Array.from(g.input_sources),
      output_sources: Array.from(g.output_sources),
      upstream_pipelines: Array.from(g.upstream_pipelines).filter((u) => !g._members.includes(u))
    }));
    pipelines = [...ungroupedPipelines, ...groupedPipelines];
  }
  const allDataSources = /* @__PURE__ */ new Map();
  datasources.forEach((ds) => allDataSources.set(ds.name, ds));
  pipelines.forEach((pipeline) => {
    pipeline.input_sources?.forEach((sourceName) => {
      if (!allDataSources.has(sourceName)) {
        allDataSources.set(sourceName, { name: sourceName, type: "auto-created" });
      }
    });
    pipeline.output_sources?.forEach((sourceName) => {
      if (!allDataSources.has(sourceName)) {
        allDataSources.set(sourceName, { name: sourceName, type: "auto-created" });
      }
    });
  });
  const allClusterNames = /* @__PURE__ */ new Set();
  pipelines.forEach((p) => {
    if (p.cluster) allClusterNames.add(p.cluster);
  });
  allDataSources.forEach((ds) => {
    if (ds.cluster) allClusterNames.add(ds.cluster);
  });
  const clusterDefinitions = /* @__PURE__ */ new Map();
  const clusterHierarchy = /* @__PURE__ */ new Map();
  const clusterChildren = /* @__PURE__ */ new Map();
  explicitClusters.forEach((cluster) => {
    clusterDefinitions.set(cluster.name, cluster);
    allClusterNames.add(cluster.name);
    if (cluster.parent) {
      clusterHierarchy.set(cluster.name, cluster.parent);
      if (!clusterChildren.has(cluster.parent)) {
        clusterChildren.set(cluster.parent, []);
      }
      clusterChildren.get(cluster.parent).push(cluster.name);
      allClusterNames.add(cluster.parent);
    }
  });
  allClusterNames.forEach((name) => {
    if (!clusterDefinitions.has(name)) {
      clusterDefinitions.set(name, { name, description: `Auto-generated cluster: ${name}` });
    }
  });
  let dot = `digraph PipevizGraph {
    rankdir=LR;
    bgcolor="transparent";
    node [fontsize=12];
    edge [fontsize=10];

`;
  const nodesByCluster = /* @__PURE__ */ new Map();
  pipelines.forEach((pipeline) => {
    const cluster = pipeline.cluster || "_unclustered";
    if (!nodesByCluster.has(cluster)) {
      nodesByCluster.set(cluster, []);
    }
    nodesByCluster.get(cluster).push({ type: "pipeline", node: pipeline });
  });
  allDataSources.forEach((ds) => {
    const cluster = ds.cluster || "_unclustered";
    if (!nodesByCluster.has(cluster)) {
      nodesByCluster.set(cluster, []);
    }
    nodesByCluster.get(cluster).push({ type: "datasource", node: ds });
  });
  const rootClusters = [];
  clusterDefinitions.forEach((cluster, name) => {
    if (!clusterHierarchy.has(name) && nodesByCluster.has(name)) {
      rootClusters.push(name);
    }
  });
  function renderCluster(clusterName, depth = 0) {
    const cluster = clusterDefinitions.get(clusterName);
    if (!cluster) return "";
    const nodesInCluster = nodesByCluster.get(clusterName) || [];
    const children = clusterChildren.get(clusterName) || [];
    const hasNodes = nodesInCluster.length > 0;
    const hasChildrenWithNodes = children.some(
      (child) => nodesByCluster.has(child) && nodesByCluster.get(child).length > 0
    );
    if (!hasNodes && !hasChildrenWithNodes) return "";
    let result = `${"    ".repeat(depth + 1)}subgraph cluster_${clusterName.replace(/[^a-zA-Z0-9]/g, "_")} {
${"    ".repeat(depth + 2)}label="${clusterName}";
${"    ".repeat(depth + 2)}style="dotted";
${"    ".repeat(depth + 2)}color="#666666";
${"    ".repeat(depth + 2)}fontsize=11;
${"    ".repeat(depth + 2)}fontname="Arial";

`;
    nodesInCluster.forEach((item) => {
      if (item.type === "pipeline") {
        const pipeline = item.node;
        const isGroup = pipeline._isGroup;
        const memberCount = pipeline._members?.length || 0;
        const label = isGroup ? `<${pipeline.name}<BR/><FONT POINT-SIZE="9" COLOR="#666">(${memberCount} pipelines)</FONT>>` : pipeline.schedule ? `<${pipeline.name}<BR/><FONT POINT-SIZE="9" COLOR="#d63384"><I>${pipeline.schedule}</I></FONT>>` : `"${pipeline.name}"`;
        const fillColor = isGroup ? "#e0f2f1" : "#e3f2fd";
        const borderColor = isGroup ? "#00897b" : "#1976d2";
        const penWidth = isGroup ? "2" : "1";
        result += `${"    ".repeat(depth + 2)}"${pipeline.name}" [shape=box, style="filled,rounded",
${"    ".repeat(depth + 3)}fillcolor="${fillColor}", color="${borderColor}", penwidth=${penWidth},
${"    ".repeat(depth + 3)}fontname="Arial",
${"    ".repeat(depth + 3)}label=${label}];
`;
      } else if (item.type === "datasource" && !state.pipelinesOnlyView) {
        const ds = item.node;
        result += `${"    ".repeat(depth + 2)}"${ds.name}" [shape=ellipse, style=filled,
${"    ".repeat(depth + 3)}fillcolor="#f3e5f5", color="#7b1fa2",
${"    ".repeat(depth + 3)}fontname="Arial", fontsize=10];
`;
      }
    });
    children.forEach((childName) => {
      result += renderCluster(childName, depth + 1);
    });
    result += `${"    ".repeat(depth + 1)}}

`;
    return result;
  }
  rootClusters.forEach((clusterName) => {
    dot += renderCluster(clusterName);
  });
  const unclusteredNodes = nodesByCluster.get("_unclustered") || [];
  unclusteredNodes.forEach((item) => {
    if (item.type === "pipeline") {
      const pipeline = item.node;
      const isGroup = pipeline._isGroup;
      const memberCount = pipeline._members?.length || 0;
      const label = isGroup ? `<${pipeline.name}<BR/><FONT POINT-SIZE="9" COLOR="#666">(${memberCount} pipelines)</FONT>>` : pipeline.schedule ? `<${pipeline.name}<BR/><FONT POINT-SIZE="9" COLOR="#d63384"><I>${pipeline.schedule}</I></FONT>>` : `"${pipeline.name}"`;
      const fillColor = isGroup ? "#e0f2f1" : "#e3f2fd";
      const borderColor = isGroup ? "#00897b" : "#1976d2";
      const penWidth = isGroup ? "2" : "1";
      dot += `    "${pipeline.name}" [shape=box, style="filled,rounded",
        fillcolor="${fillColor}", color="${borderColor}", penwidth=${penWidth},
        fontname="Arial",
        label=${label}];
`;
    } else if (item.type === "datasource" && !state.pipelinesOnlyView) {
      const ds = item.node;
      dot += `    "${ds.name}" [shape=ellipse, style=filled,
        fillcolor="#f3e5f5", color="#7b1fa2",
        fontname="Arial", fontsize=10];
`;
    }
  });
  if (!state.pipelinesOnlyView) {
    dot += "\n";
    pipelines.forEach((pipeline) => {
      pipeline.input_sources?.forEach((source) => {
        dot += `    "${source}" -> "${pipeline.name}" [color="${edgeColor}", arrowsize=0.8];
`;
      });
      pipeline.output_sources?.forEach((source) => {
        dot += `    "${pipeline.name}" -> "${source}" [color="${edgeColor}", arrowsize=0.8];
`;
      });
    });
  }
  const validNodeNames = new Set(pipelines.map((p) => p.name));
  dot += "\n";
  pipelines.forEach((pipeline) => {
    pipeline.upstream_pipelines?.forEach((upstream) => {
      if (validNodeNames.has(upstream)) {
        dot += `    "${upstream}" -> "${pipeline.name}" [color="#ff6b35", style="solid", arrowsize=0.8];
`;
      }
    });
  });
  dot += "\n    overlap=false; splines=true;\n}";
  return dot;
}
let graphTabListenerAdded = false;
function renderGraph() {
  if (!state.currentConfig) return;
  const currentHash = getConfigHash(state.currentConfig);
  if (!graphTabListenerAdded) {
    document.getElementById("graph-tab").addEventListener("shown.bs.tab", function() {
      const newHash = getConfigHash(state.currentConfig);
      if (!state.graphviz) {
        setTimeout(initializeGraph, 100);
        state.lastRenderedConfigHash = newHash;
      } else if (newHash !== state.lastRenderedConfigHash) {
        updateGraph();
        state.lastRenderedConfigHash = newHash;
      }
    });
    graphTabListenerAdded = true;
  }
  if (document.getElementById("graph-tab").classList.contains("active")) {
    setTimeout(initializeGraph, 100);
    state.lastRenderedConfigHash = currentHash;
  }
}
function initializeGraph() {
  try {
    document.getElementById("graph").innerHTML = "";
    state.graphviz = d3.select("#graph").graphviz().width(document.getElementById("graph").clientWidth).height(500).fit(true);
    updateGraph();
  } catch (error) {
    console.error("Graphviz initialization error:", error);
    document.getElementById("graph").innerHTML = `
            <div class="alert alert-warning m-3">
                <strong>Graph rendering issue detected.</strong><br>
                Please check the Raw DOT tab to see the generated code.<br>
                <small>Error: ${error.message}</small>
            </div>
        `;
  }
}
let isRendering = false;
let pendingUpdate = false;
let renderTimeout = null;
function updateGraph() {
  if (!state.graphviz) return;
  if (isRendering) {
    pendingUpdate = true;
    return;
  }
  const viewKey = getViewStateKey();
  let cached = state.viewStateCache.get(viewKey);
  let dotSrc;
  if (cached?.dot) {
    dotSrc = cached.dot;
  } else {
    dotSrc = generateGraphvizDot();
    if (!cached) {
      cached = { dot: dotSrc };
      addToViewCache(viewKey, cached);
    } else {
      cached.dot = dotSrc;
    }
  }
  isRendering = true;
  const container = d3.select("#graph");
  container.style("opacity", 0.6);
  if (renderTimeout) clearTimeout(renderTimeout);
  renderTimeout = setTimeout(() => {
    if (isRendering) {
      container.style("opacity", 1);
      isRendering = false;
      if (pendingUpdate) {
        pendingUpdate = false;
        updateGraph();
      }
    }
  }, 3e3);
  state.graphviz.transition(() => d3.transition().duration(150)).renderDot(dotSrc).on("end", () => {
    if (renderTimeout) clearTimeout(renderTimeout);
    container.style("opacity", 1);
    isRendering = false;
    setupGraphInteractivity(true);
    applyCriticalPathHighlighting();
    if (state.showCostLabels) showCostLabels();
    if (pendingUpdate) {
      pendingUpdate = false;
      updateGraph();
    } else {
      setTimeout(() => precomputeAdjacentStates(), 100);
    }
  });
}
function applyCriticalPathHighlighting() {
  if (!state.analysisMode) return;
  let pathNodes, pathEdges, nodeClass, edgeClass;
  if (state.analysisMode === "critical-path") {
    pathNodes = getCriticalPathNodes();
    pathEdges = getCriticalPathEdges();
    nodeClass = "node-critical-path";
    edgeClass = "edge-critical-path";
  } else if (state.analysisMode === "costliest-path") {
    pathNodes = getCostliestPathNodes();
    pathEdges = getCostliestPathEdges();
    nodeClass = "node-costliest-path";
    edgeClass = "edge-costliest-path";
  } else {
    return;
  }
  if (pathNodes.size === 0) return;
  d3.select("#graph").selectAll(".node").each(function() {
    const node = d3.select(this);
    const title = node.select("title").text();
    if (pathNodes.has(title)) {
      node.classed(nodeClass, true);
    } else {
      node.classed("node-dimmed", true);
    }
  });
  d3.select("#graph").selectAll(".edge").each(function() {
    const edge = d3.select(this);
    const title = edge.select("title").text();
    const match = title.match(/^(.+?)(?:->|--)\s*(.+?)$/);
    if (match) {
      const edgeKey = `${match[1]}|${match[2]}`;
      if (pathEdges.has(edgeKey)) {
        edge.classed(edgeClass, true);
      } else {
        edge.classed("edge-dimmed", true);
      }
    }
  });
}
function precomputeAdjacentStates() {
  if (!state.currentConfig?.pipelines) return;
  const groupNames = [];
  state.currentConfig.pipelines.forEach((p) => {
    if (p.group && !groupNames.includes(p.group)) groupNames.push(p.group);
  });
  const currentExpanded = new Set(state.expandedGroups);
  const isDark = document.documentElement.getAttribute("data-theme") === "dark";
  let index = 0;
  function processNext() {
    if (index >= groupNames.length) return;
    const groupName = groupNames[index++];
    const wasExpanded = currentExpanded.has(groupName);
    const altExpanded = new Set(currentExpanded);
    if (wasExpanded) {
      altExpanded.delete(groupName);
    } else {
      altExpanded.add(groupName);
    }
    const altExpandedKey = Array.from(altExpanded).sort().join(",");
    const altKey = `${state.groupedView}|${state.pipelinesOnlyView}|${isDark}|${altExpandedKey}`;
    if (!state.viewStateCache.has(altKey)) {
      const savedExpanded = state.expandedGroups;
      state.expandedGroups = altExpanded;
      const altDot = generateGraphvizDot();
      state.expandedGroups = savedExpanded;
      addToViewCache(altKey, { dot: altDot });
    }
    if (index < groupNames.length) {
      setTimeout(processNext, 10);
    }
  }
  processNext();
}
function setupGraphInteractivity(forceRebuild = false) {
  const viewKey = getViewStateKey();
  let cached = state.viewStateCache.get(viewKey);
  if (!forceRebuild && cached?.lineage && Object.keys(cached.lineage.nodeLineage).length > 0) {
    state.cachedUpstreamMap = cached.lineage.upstreamMap;
    state.cachedDownstreamMap = cached.lineage.downstreamMap;
    state.cachedLineage = cached.lineage.nodeLineage;
  } else {
    let getFullChain2 = function(node, map, visited = /* @__PURE__ */ new Set(), depth = 1) {
      if (visited.has(node)) return [];
      visited.add(node);
      const neighbors = map[node] || [];
      let result = [];
      neighbors.forEach((n) => {
        result.push({ name: n, depth });
        result.push(...getFullChain2(n, map, visited, depth + 1));
      });
      return result;
    };
    var getFullChain = getFullChain2;
    state.cachedUpstreamMap = {};
    state.cachedDownstreamMap = {};
    state.cachedLineage = {};
    d3.select("#graph").selectAll(".edge").each(function() {
      const edge = d3.select(this);
      const title = edge.select("title").text();
      const match = title.match(/^(.+?)(?:->|--)\s*(.+?)$/);
      if (match) {
        const source = match[1];
        const target = match[2];
        if (!state.cachedDownstreamMap[source]) state.cachedDownstreamMap[source] = [];
        if (!state.cachedUpstreamMap[target]) state.cachedUpstreamMap[target] = [];
        state.cachedDownstreamMap[source].push(target);
        state.cachedUpstreamMap[target].push(source);
      }
    });
    d3.select("#graph").selectAll(".node").each(function() {
      const nodeName = d3.select(this).select("title").text();
      state.cachedLineage[nodeName] = {
        upstream: getFullChain2(nodeName, state.cachedUpstreamMap, /* @__PURE__ */ new Set()),
        downstream: getFullChain2(nodeName, state.cachedDownstreamMap, /* @__PURE__ */ new Set())
      };
    });
    if (Object.keys(state.cachedLineage).length > 0) {
      if (!cached) {
        cached = {
          lineage: {
            upstreamMap: state.cachedUpstreamMap,
            downstreamMap: state.cachedDownstreamMap,
            nodeLineage: state.cachedLineage
          }
        };
        addToViewCache(viewKey, cached);
      } else {
        cached.lineage = {
          upstreamMap: state.cachedUpstreamMap,
          downstreamMap: state.cachedDownstreamMap,
          nodeLineage: state.cachedLineage
        };
      }
    }
  }
  if (document.getElementById("node-tooltip")) {
    document.getElementById("node-tooltip").remove();
  }
  const tooltip = document.createElement("div");
  tooltip.id = "node-tooltip";
  tooltip.className = "node-tooltip";
  tooltip.style.display = "none";
  document.body.appendChild(tooltip);
  d3.select("#graph").selectAll(".node").style("cursor", "pointer").on("click", function(event, d) {
    event.stopPropagation();
    const nodeName = d3.select(this).select("title").text();
    selectNode(nodeName, this);
  }).on("dblclick", function(event, d) {
    event.stopPropagation();
    const nodeName = d3.select(this).select("title").text();
    if (state.currentConfig?.pipelines) {
      const isGroupNode = state.currentConfig.pipelines.some((p) => p.group === nodeName);
      if (isGroupNode) {
        toggleGroup(nodeName);
      }
    }
  }).on("mouseover", function(event, d) {
    const nodeName = d3.select(this).select("title").text();
    showNodeTooltip(event, nodeName);
  }).on("mousemove", function(event, d) {
    tooltip.style.left = event.pageX + 10 + "px";
    tooltip.style.top = event.pageY - 10 + "px";
  }).on("mouseout", function(event, d) {
    hideNodeTooltip();
  });
  d3.select("#graph").on("click", function(event) {
    if (event.target.tagName === "svg" || event.target === event.currentTarget || event.target.classList.contains("graph-container") || !event.target.closest(".node")) {
      clearSelection();
    }
  });
}
function showNodeTooltip(event, nodeName) {
  const tooltip = document.getElementById("node-tooltip");
  if (!tooltip || !state.currentConfig) return;
  let content = "";
  {
    const groupMembers = state.currentConfig.pipelines?.filter((p) => p.group === nodeName);
    if (groupMembers?.length > 0) {
      content = `${nodeName} (${groupMembers.length} pipelines)`;
      content += `
Click for details`;
      content += `
Members: ${groupMembers.map((p) => p.name).join(", ")}`;
      tooltip.textContent = content;
      tooltip.style.display = "block";
      tooltip.style.left = event.pageX + 10 + "px";
      tooltip.style.top = event.pageY - 10 + "px";
      return;
    }
  }
  const pipeline = state.currentConfig.pipelines?.find((p) => p.name === nodeName);
  if (pipeline) {
    content = `${pipeline.name}`;
    if (pipeline.description) content += `
Description: ${pipeline.description}`;
    if (pipeline.schedule) content += `
Schedule: ${pipeline.schedule}`;
    if (pipeline.cluster) content += `
Cluster: ${pipeline.cluster}`;
    if (pipeline.tags && pipeline.tags.length > 0) content += `
Tags: ${pipeline.tags.join(", ")}`;
    if (pipeline.input_sources && pipeline.input_sources.length > 0)
      content += `
Inputs: ${pipeline.input_sources.join(", ")}`;
    if (pipeline.output_sources && pipeline.output_sources.length > 0)
      content += `
Outputs: ${pipeline.output_sources.join(", ")}`;
  }
  const datasource = state.currentConfig.datasources?.find((ds) => ds.name === nodeName);
  if (datasource) {
    content = `${datasource.name}`;
    if (datasource.type) content += `
Type: ${datasource.type.toUpperCase()}`;
    if (datasource.description) content += `
Description: ${datasource.description}`;
    if (datasource.owner) content += `
Owner: ${datasource.owner}`;
    if (datasource.cluster) content += `
Cluster: ${datasource.cluster}`;
    if (datasource.tags && datasource.tags.length > 0) content += `
Tags: ${datasource.tags.join(", ")}`;
    if (datasource.metadata) {
      const keyFields = ["size", "record_count", "refresh_frequency", "environment"];
      keyFields.forEach((field) => {
        if (datasource.metadata[field]) {
          content += `
${field.replace(/_/g, " ")}: ${datasource.metadata[field]}`;
        }
      });
    }
  }
  if (content) {
    tooltip.textContent = content;
    tooltip.style.display = "block";
    tooltip.style.left = event.pageX + 10 + "px";
    tooltip.style.top = event.pageY - 10 + "px";
  }
}
function hideNodeTooltip() {
  const tooltip = document.getElementById("node-tooltip");
  if (tooltip) {
    tooltip.style.display = "none";
  }
}
function selectNode(nodeName, nodeElement) {
  state.selectedNode = nodeName;
  clearHighlights();
  d3.select(nodeElement).classed("node-highlighted", true);
  const lineage = state.cachedLineage[nodeName] || { upstream: [], downstream: [] };
  const upstream = lineage.upstream;
  const downstream = lineage.downstream;
  const allConnected = /* @__PURE__ */ new Set([...upstream.map((x) => x.name), ...downstream.map((x) => x.name)]);
  d3.select("#graph").selectAll(".node").each(function() {
    const node = d3.select(this);
    const nodeTitle = node.select("title").text();
    if (allConnected.has(nodeTitle)) {
      node.classed("node-connected", true);
    } else if (nodeTitle !== nodeName) {
      node.classed("node-dimmed", true);
    }
  });
  d3.select("#graph").selectAll(".edge").each(function() {
    const edge = d3.select(this);
    const title = edge.select("title").text();
    const match = title.match(/^(.+?)(?:->|--)\s*(.+?)$/);
    if (match) {
      const source = match[1];
      const target = match[2];
      const sourceInChain = source === nodeName || allConnected.has(source);
      const targetInChain = target === nodeName || allConnected.has(target);
      if (sourceInChain && targetInChain) {
        edge.classed("edge-highlighted", true);
      } else {
        edge.classed("edge-dimmed", true);
      }
    }
  });
  showNodeDetails(nodeName, upstream, downstream);
}
function showNodeDetails(nodeName, upstream = [], downstream = []) {
  const col = document.getElementById("node-details-col");
  const content = document.getElementById("node-details-content");
  if (!state.currentConfig) return;
  let html = "";
  let nodeData = null;
  let nodeType = "";
  const pipeline = state.currentConfig.pipelines?.find((p) => p.name === nodeName);
  if (pipeline) {
    nodeData = pipeline;
    nodeType = "Pipeline";
  }
  if (!nodeData && state.groupedView) {
    const groupMembers = state.currentConfig.pipelines?.filter((p) => p.group === nodeName);
    if (groupMembers?.length > 0) {
      const allInputs = /* @__PURE__ */ new Set();
      const allOutputs = /* @__PURE__ */ new Set();
      groupMembers.forEach((p) => {
        p.input_sources?.forEach((s) => allInputs.add(s));
        p.output_sources?.forEach((s) => allOutputs.add(s));
      });
      nodeData = {
        name: nodeName,
        description: `Group containing ${groupMembers.length} pipelines`,
        input_sources: Array.from(allInputs),
        output_sources: Array.from(allOutputs),
        cluster: groupMembers[0].cluster,
        _members: groupMembers.map((p) => p.name)
      };
      nodeType = "Pipeline Group";
    }
  }
  const datasource = state.currentConfig.datasources?.find((ds) => ds.name === nodeName);
  if (datasource) {
    nodeData = datasource;
    nodeType = "Data Source";
  }
  if (!nodeData) {
    const allSources = /* @__PURE__ */ new Set();
    state.currentConfig.pipelines?.forEach((p) => {
      p.input_sources?.forEach((s) => allSources.add(s));
      p.output_sources?.forEach((s) => allSources.add(s));
    });
    if (allSources.has(nodeName)) {
      nodeData = { name: nodeName, description: "Auto-created from pipeline references" };
      nodeType = "Data Source";
    }
  }
  if (!nodeData) {
    col.style.display = "none";
    return;
  }
  html = `<h5>${nodeData.name}</h5>`;
  html += `<div class="detail-label">Type</div>`;
  html += `<div class="detail-value"><span class="badge bg-secondary">${nodeType}</span></div>`;
  html += `<div class="node-actions">`;
  html += `<button class="graph-ctrl-btn danger" onclick="showBlastRadius('${nodeName.replace(/'/g, "\\'")}')"> Blast Radius</button>`;
  if (nodeType === "Pipeline Group") {
    const isExpanded = state.expandedGroups.has(nodeName);
    html += `<button class="graph-ctrl-btn" onclick="toggleGroup('${nodeName}')">${isExpanded ? "Collapse" : "Expand"}</button>`;
  }
  if (nodeType === "Pipeline" && nodeData.group && state.expandedGroups.has(nodeData.group)) {
    html += `<button class="graph-ctrl-btn" onclick="toggleGroup('${nodeData.group}')">Collapse ${nodeData.group}</button>`;
  }
  html += `</div>`;
  if (nodeData.description) {
    html += `<div class="detail-label">Description</div>`;
    html += `<div class="detail-value">${nodeData.description}</div>`;
  }
  if (nodeData.schedule) {
    html += `<div class="detail-label">Schedule</div>`;
    html += `<div class="detail-value"><code class="text-success">${nodeData.schedule}</code></div>`;
  }
  if (nodeType === "Pipeline" || nodeType === "Pipeline Group") {
    const hasDuration = nodeData.duration !== void 0;
    const hasCost = nodeData.cost !== void 0;
    if (hasDuration || hasCost) {
      html += `<div class="detail-label">Runtime</div>`;
      html += `<div class="detail-value">`;
      if (hasDuration) {
        const mins = nodeData.duration;
        const formatted = mins >= 60 ? `${Math.floor(mins / 60)}h${mins % 60 > 0 ? mins % 60 + "m" : ""}` : `${mins}m`;
        html += `<span class="badge me-2" style="background-color: #f8bbd9; color: #880e4f;">${formatted}</span>`;
      }
      if (hasCost) {
        html += `<span class="badge" style="background-color: #e8f5e8; color: #2e7d32;">$${nodeData.cost.toFixed(2)}</span>`;
      }
      html += `</div>`;
    }
    if (upstream && upstream.length > 0) {
      const pipelineMap = /* @__PURE__ */ new Map();
      state.currentConfig.pipelines?.forEach((p) => pipelineMap.set(p.name, p));
      const seen = /* @__PURE__ */ new Set();
      let upstreamCost = 0;
      let upstreamDuration = 0;
      let upstreamCount = 0;
      upstream.forEach((u) => {
        if (seen.has(u.name)) return;
        seen.add(u.name);
        const p = pipelineMap.get(u.name);
        if (p) {
          upstreamCount++;
          if (p.cost !== void 0) upstreamCost += p.cost;
          if (p.duration !== void 0) upstreamDuration += p.duration;
        }
      });
      if (upstreamCount > 0 && (upstreamCost > 0 || upstreamDuration > 0)) {
        html += `<div class="detail-label">Upstream Total</div>`;
        html += `<div class="detail-value">`;
        if (upstreamDuration > 0) {
          const mins = upstreamDuration;
          const formatted = mins >= 60 ? `${Math.floor(mins / 60)}h${mins % 60 > 0 ? mins % 60 + "m" : ""}` : `${mins}m`;
          html += `<span class="badge me-2" style="background-color: #fce4ec; color: #ad1457;">${formatted}</span>`;
        }
        if (upstreamCost > 0) {
          html += `<span class="badge" style="background-color: #e0f2f1; color: #00695c;">$${upstreamCost.toFixed(2)}</span>`;
        }
        html += `<span class="text-muted ms-2" style="font-size: 10px;">(${upstreamCount} pipelines)</span>`;
        html += `</div>`;
      }
    }
  }
  if (nodeData.type) {
    html += `<div class="detail-label">Source Type</div>`;
    html += `<div class="detail-value"><span class="badge badge-${nodeData.type}">${nodeData.type.toUpperCase()}</span></div>`;
  }
  if (nodeData.owner) {
    html += `<div class="detail-label">Owner</div>`;
    html += `<div class="detail-value">${nodeData.owner}</div>`;
  }
  if (nodeData.cluster) {
    html += `<div class="detail-label">Cluster</div>`;
    html += `<div class="detail-value"><span class="badge badge-cluster">${nodeData.cluster}</span></div>`;
  }
  if (nodeData.input_sources?.length) {
    html += `<div class="detail-label">Input Sources</div>`;
    html += `<div class="detail-value">${nodeData.input_sources.map((s) => `<span class="badge me-1 mb-1" style="background-color: #e3f2fd; color: #1565c0;">${s}</span>`).join("")}</div>`;
  }
  if (nodeData.output_sources?.length) {
    html += `<div class="detail-label">Output Sources</div>`;
    html += `<div class="detail-value">${nodeData.output_sources.map((s) => `<span class="badge me-1 mb-1" style="background-color: #e8f5e8; color: #2e7d32;">${s}</span>`).join("")}</div>`;
  }
  if (nodeData.upstream_pipelines?.length) {
    html += `<div class="detail-label">Upstream Pipelines</div>`;
    html += `<div class="detail-value">${nodeData.upstream_pipelines.map((p) => `<span class="badge me-1 mb-1" style="background-color: #fff3e0; color: #e65100;">${p}</span>`).join("")}</div>`;
  }
  if (nodeData._members?.length) {
    html += `<div class="detail-label">Member Pipelines</div>`;
    html += `<div class="detail-value">${nodeData._members.map((p) => `<span class="badge me-1 mb-1" style="background-color: #e0f2f1; color: #00897b;">${p}</span>`).join("")}</div>`;
  }
  if (nodeData.tags?.length) {
    html += `<div class="detail-label">Tags</div>`;
    html += `<div class="detail-value">${nodeData.tags.map((t) => `<span class="badge me-1 mb-1" style="background-color: #fff3cd; color: #856404;">${t}</span>`).join("")}</div>`;
  }
  if (nodeData.metadata && Object.keys(nodeData.metadata).length) {
    html += `<div class="detail-label">Metadata</div>`;
    html += `<div class="detail-value">`;
    Object.entries(nodeData.metadata).forEach(([key, value]) => {
      html += `<div class="small"><strong>${key.replace(/_/g, " ")}:</strong> ${value}</div>`;
    });
    html += `</div>`;
  }
  if (nodeData.links && Object.keys(nodeData.links).length) {
    html += `<div class="links-section">`;
    html += `<div class="detail-label">Links</div><div class="node-actions">`;
    Object.entries(nodeData.links).forEach(([name, url]) => {
      html += `<a href="${url}" target="_blank" class="graph-ctrl-btn link-btn">${name}</a>`;
    });
    html += `</div></div>`;
  }
  const pipelineNames = new Set((state.currentConfig.pipelines || []).map((p) => p.name));
  {
    (state.currentConfig.pipelines || []).forEach((p) => {
      if (p.group) pipelineNames.add(p.group);
    });
  }
  function dedupeAndSort(items, filterFn) {
    const seen = /* @__PURE__ */ new Map();
    items.filter((x) => filterFn(x.name)).forEach((x) => {
      if (!seen.has(x.name) || seen.get(x.name).depth > x.depth) {
        seen.set(x.name, x);
      }
    });
    return [...seen.values()].sort((a, b) => a.depth - b.depth);
  }
  const upstreamPipelines = dedupeAndSort(upstream, (n) => pipelineNames.has(n));
  const upstreamSources = dedupeAndSort(upstream, (n) => !pipelineNames.has(n));
  const downstreamPipelines = dedupeAndSort(downstream, (n) => pipelineNames.has(n));
  const downstreamSources = dedupeAndSort(downstream, (n) => !pipelineNames.has(n));
  function renderLineageList(items, label) {
    if (items.length === 0) return "";
    let out = `<div class="detail-label">${label} (${items.length})</div><div class="detail-value">`;
    items.forEach((x) => {
      const indent = (x.depth - 1) * 12;
      const opacity = Math.max(0.5, 1 - (x.depth - 1) * 0.15);
      const prefix = x.depth > 1 ? " " : "";
      out += `<div class="lineage-link" data-node-name="${x.name}" style="padding-left: ${indent}px; opacity: ${opacity};">${prefix}${x.name}</div>`;
    });
    out += `</div>`;
    return out;
  }
  function getNodeMetadata(name) {
    const pipeline2 = state.currentConfig.pipelines?.find((p) => p.name === name);
    if (pipeline2) {
      const meta = { name, type: "pipeline", depth: void 0 };
      if (pipeline2.description) meta.description = pipeline2.description;
      if (pipeline2.schedule) meta.schedule = pipeline2.schedule;
      if (pipeline2.cluster) meta.cluster = pipeline2.cluster;
      if (pipeline2.group) meta.group = pipeline2.group;
      if (pipeline2.owner) meta.owner = pipeline2.owner;
      if (pipeline2.tags?.length) meta.tags = pipeline2.tags;
      if (pipeline2.input_sources?.length) meta.input_sources = pipeline2.input_sources;
      if (pipeline2.output_sources?.length) meta.output_sources = pipeline2.output_sources;
      if (pipeline2.upstream_pipelines?.length) meta.upstream_pipelines = pipeline2.upstream_pipelines;
      if (pipeline2.links && Object.keys(pipeline2.links).length) meta.links = pipeline2.links;
      if (pipeline2.metadata && Object.keys(pipeline2.metadata).length) meta.metadata = pipeline2.metadata;
      return meta;
    }
    const datasource2 = state.currentConfig.datasources?.find((ds) => ds.name === name);
    if (datasource2) {
      const meta = { name, type: "datasource", depth: void 0 };
      if (datasource2.description) meta.description = datasource2.description;
      if (datasource2.type) meta.source_type = datasource2.type;
      if (datasource2.cluster) meta.cluster = datasource2.cluster;
      if (datasource2.owner) meta.owner = datasource2.owner;
      if (datasource2.tags?.length) meta.tags = datasource2.tags;
      if (datasource2.links && Object.keys(datasource2.links).length) meta.links = datasource2.links;
      if (datasource2.metadata && Object.keys(datasource2.metadata).length) meta.metadata = datasource2.metadata;
      return meta;
    }
    return { name, type: "datasource" };
  }
  const allUpstreamNodes = new Set([...upstreamPipelines, ...upstreamSources].map((x) => x.name));
  const allDownstreamNodes = new Set([...downstreamPipelines, ...downstreamSources].map((x) => x.name));
  const upstreamEdges = [];
  allUpstreamNodes.forEach((node) => {
    const downstreamNeighbors = state.cachedDownstreamMap[node] || [];
    downstreamNeighbors.forEach((neighbor) => {
      if (allUpstreamNodes.has(neighbor) || neighbor === nodeName) {
        upstreamEdges.push({ from: node, to: neighbor });
      }
    });
  });
  const downstreamEdges = [];
  downstreamEdges.push(
    ...(state.cachedDownstreamMap[nodeName] || []).filter((n) => allDownstreamNodes.has(n)).map((n) => ({ from: nodeName, to: n }))
  );
  allDownstreamNodes.forEach((node) => {
    const downstreamNeighbors = state.cachedDownstreamMap[node] || [];
    downstreamNeighbors.forEach((neighbor) => {
      if (allDownstreamNodes.has(neighbor)) {
        downstreamEdges.push({ from: node, to: neighbor });
      }
    });
  });
  const lineageJson = {
    node: nodeName,
    type: nodeType,
    ...getNodeMetadata(nodeName),
    upstream: {
      pipelines: upstreamPipelines.map((x) => ({ ...getNodeMetadata(x.name), depth: x.depth })),
      sources: upstreamSources.map((x) => ({ ...getNodeMetadata(x.name), depth: x.depth })),
      edges: upstreamEdges
    },
    downstream: {
      pipelines: downstreamPipelines.map((x) => ({ ...getNodeMetadata(x.name), depth: x.depth })),
      sources: downstreamSources.map((x) => ({ ...getNodeMetadata(x.name), depth: x.depth })),
      edges: downstreamEdges
    }
  };
  const hasLineage = upstreamPipelines.length > 0 || upstreamSources.length > 0 || downstreamPipelines.length > 0 || downstreamSources.length > 0;
  if (hasLineage) {
    html += `<div class="lineage-view-toggle">
            <span class="lineage-toggle-label active" data-view="tree">Tree</span>
            <div class="lineage-toggle-slider"></div>
            <span class="lineage-toggle-label" data-view="json">JSON</span>
        </div>`;
  }
  html += `<div class="lineage-tree-view">`;
  html += renderLineageList(upstreamPipelines, "UPSTREAM PIPELINES");
  html += renderLineageList(upstreamSources, "UPSTREAM SOURCES");
  html += renderLineageList(downstreamPipelines, "DOWNSTREAM PIPELINES");
  html += renderLineageList(downstreamSources, "DOWNSTREAM SOURCES");
  html += `</div>`;
  html += `<div class="lineage-json-view" style="display: none;">
        <div class="detail-label">LINEAGE JSON</div>
        <pre class="lineage-json-pre">${JSON.stringify(lineageJson, null, 2)}</pre>
    </div>`;
  const graphCol = document.getElementById("graph-col");
  graphCol.classList.remove("col-md-12");
  graphCol.classList.add("col-md-8");
  col.style.display = "block";
  content.innerHTML = html;
  const slider = content.querySelector(".lineage-toggle-slider");
  if (slider) {
    slider.addEventListener("click", function() {
      const isJson = this.classList.toggle("json-active");
      const treeView = content.querySelector(".lineage-tree-view");
      const jsonView = content.querySelector(".lineage-json-view");
      const treeLabel = content.querySelector('.lineage-toggle-label[data-view="tree"]');
      const jsonLabel = content.querySelector('.lineage-toggle-label[data-view="json"]');
      if (isJson) {
        treeView.style.display = "none";
        jsonView.style.display = "block";
        treeLabel.classList.remove("active");
        jsonLabel.classList.add("active");
      } else {
        treeView.style.display = "block";
        jsonView.style.display = "none";
        treeLabel.classList.add("active");
        jsonLabel.classList.remove("active");
      }
    });
  }
  content.querySelectorAll(".lineage-link").forEach((el) => {
    el.addEventListener("click", function() {
      const targetName = this.getAttribute("data-node-name");
      if (targetName) {
        d3.select("#graph").selectAll(".node").each(function() {
          const nodeTitle = d3.select(this).select("title").text();
          if (nodeTitle === targetName) {
            selectNode(targetName, this);
          }
        });
      }
    });
  });
}
function clearSelection() {
  state.selectedNode = null;
  clearHighlights();
  applyCriticalPathHighlighting();
  const col = document.getElementById("node-details-col");
  const graphCol = document.getElementById("graph-col");
  if (col) col.style.display = "none";
  if (graphCol) {
    graphCol.classList.remove("col-md-8");
    graphCol.classList.add("col-md-12");
  }
}
function clearHighlights() {
  d3.select("#graph").selectAll(".node").classed("node-highlighted node-connected node-dimmed node-critical-path node-costliest-path", false);
  d3.select("#graph").selectAll(".edge").classed("edge-highlighted edge-dimmed edge-critical-path edge-costliest-path", false);
}
function fuzzyMatch(text, query) {
  text = text.toLowerCase();
  query = query.toLowerCase();
  if (text.includes(query)) {
    return { match: true, score: query.length / text.length + 0.5 };
  }
  let queryIdx = 0;
  let score = 0;
  let lastMatchIdx = -1;
  for (let i = 0; i < text.length && queryIdx < query.length; i++) {
    if (text[i] === query[queryIdx]) {
      score += 1;
      if (lastMatchIdx === i - 1) score += 0.5;
      if (i === 0 || text[i - 1] === "_" || text[i - 1] === "-" || text[i - 1] === " ") score += 0.3;
      lastMatchIdx = i;
      queryIdx++;
    }
  }
  if (queryIdx === query.length) {
    return { match: true, score: score / text.length };
  }
  return { match: false, score: 0 };
}
function highlightMatch(text, query) {
  const lowerText = text.toLowerCase();
  const lowerQuery = query.toLowerCase();
  const idx = lowerText.indexOf(lowerQuery);
  if (idx !== -1) {
    return text.substring(0, idx) + '<span class="result-match">' + text.substring(idx, idx + query.length) + "</span>" + text.substring(idx + query.length);
  }
  let result = "";
  let queryIdx = 0;
  for (let i = 0; i < text.length; i++) {
    if (queryIdx < query.length && text[i].toLowerCase() === lowerQuery[queryIdx]) {
      result += '<span class="result-match">' + text[i] + "</span>";
      queryIdx++;
    } else {
      result += text[i];
    }
  }
  return result;
}
function searchNodes(event) {
  const dropdown = document.getElementById("graph-search-results");
  const items = dropdown.querySelectorAll(".search-result-item[data-name]");
  if (event.key === "ArrowDown" || event.key === "ArrowUp") {
    event.preventDefault();
    if (items.length === 0) return;
    const current = dropdown.querySelector(".search-result-item.selected");
    let index = current ? Array.from(items).indexOf(current) : -1;
    if (event.key === "ArrowDown") {
      index = index < items.length - 1 ? index + 1 : 0;
    } else {
      index = index > 0 ? index - 1 : items.length - 1;
    }
    items.forEach((item) => item.classList.remove("selected"));
    items[index].classList.add("selected");
    items[index].scrollIntoView({ block: "nearest" });
    return;
  }
  if (event.key === "Enter") {
    const selected = dropdown.querySelector(".search-result-item.selected");
    if (selected && selected.dataset.name) {
      selectSearchResult(selected.dataset.name);
    }
    return;
  }
  if (event.key === "Escape") {
    dropdown.classList.remove("show");
    dropdown.innerHTML = "";
    return;
  }
  const query = event.target.value.trim();
  if (!query || query.length < 1 || !state.currentConfig) {
    dropdown.classList.remove("show");
    dropdown.innerHTML = "";
    return;
  }
  const results = [];
  state.currentConfig.pipelines?.forEach((p) => {
    const nameMatch = fuzzyMatch(p.name, query);
    const descMatch = p.description ? fuzzyMatch(p.description, query) : { match: false, score: 0 };
    if (nameMatch.match || descMatch.match) {
      results.push({
        name: p.name,
        type: "pipeline",
        score: Math.max(nameMatch.score * 1.5, descMatch.score)
      });
    }
  });
  state.currentConfig.datasources?.forEach((ds) => {
    const nameMatch = fuzzyMatch(ds.name, query);
    const descMatch = ds.description ? fuzzyMatch(ds.description, query) : { match: false, score: 0 };
    if (nameMatch.match || descMatch.match) {
      results.push({
        name: ds.name,
        type: "datasource",
        score: Math.max(nameMatch.score * 1.5, descMatch.score)
      });
    }
  });
  const autoSources = /* @__PURE__ */ new Set();
  state.currentConfig.pipelines?.forEach((p) => {
    p.input_sources?.forEach((s) => autoSources.add(s));
    p.output_sources?.forEach((s) => autoSources.add(s));
  });
  autoSources.forEach((name) => {
    if (!state.currentConfig.datasources?.find((ds) => ds.name === name)) {
      const nameMatch = fuzzyMatch(name, query);
      if (nameMatch.match) {
        results.push({
          name,
          type: "datasource",
          score: nameMatch.score * 1.5
        });
      }
    }
  });
  results.sort((a, b) => b.score - a.score);
  const topResults = results.slice(0, 8);
  if (topResults.length === 0) {
    dropdown.innerHTML = '<div class="search-result-item text-muted">No matches found</div>';
    dropdown.classList.add("show");
    return;
  }
  dropdown.innerHTML = topResults.map(
    (r, i) => `
        <div class="search-result-item${i === 0 ? " selected" : ""}" data-name="${r.name}" onclick="selectSearchResult('${r.name}')">
            <span class="result-type ${r.type}">${r.type === "pipeline" ? "Pipeline" : "Source"}</span>
            <span class="result-name">${highlightMatch(r.name, query)}</span>
        </div>
    `
  ).join("");
  dropdown.classList.add("show");
}
function selectSearchResult(nodeName) {
  const dropdown = document.getElementById("graph-search-results");
  const searchInput = document.getElementById("graph-search");
  dropdown.classList.remove("show");
  searchInput.value = "";
  let found = false;
  d3.select("#graph").selectAll(".node").each(function() {
    const node = d3.select(this);
    const nodeTitle = node.select("title").text();
    if (nodeTitle === nodeName) {
      found = true;
      selectNode(nodeName, this);
    }
  });
  if (!found) {
    showNodeDetails(nodeName);
  }
}
document.addEventListener("click", function(e) {
  const dropdown = document.getElementById("graph-search-results");
  const searchInput = document.getElementById("graph-search");
  if (dropdown && !dropdown.contains(e.target) && e.target !== searchInput) {
    dropdown.classList.remove("show");
  }
});
function resetGraph() {
  if (state.graphviz) state.graphviz.resetZoom();
}
function collapseAllGroups() {
  state.expandedGroups.clear();
  updateGraph();
}
function toggleCollapseAll() {
  const allGroups = getAllGroupNames();
  const btn = document.getElementById("collapse-all-btn");
  const allCollapsed = state.expandedGroups.size === 0;
  if (allCollapsed) {
    allGroups.forEach((g) => state.expandedGroups.add(g));
    btn.classList.remove("active");
    btn.textContent = "Collapse All";
  } else {
    state.expandedGroups.clear();
    btn.classList.add("active");
    btn.textContent = "Expand All";
  }
  updateGraph();
}
function getAllGroupNames() {
  if (!state.currentConfig?.pipelines) return [];
  const groups = /* @__PURE__ */ new Set();
  state.currentConfig.pipelines.forEach((p) => {
    if (p.group) groups.add(p.group);
  });
  return Array.from(groups);
}
function togglePipelinesOnly() {
  state.pipelinesOnlyView = !state.pipelinesOnlyView;
  const btn = document.getElementById("pipelines-only-btn");
  btn.classList.toggle("active", state.pipelinesOnlyView);
  updateGraph();
}
function setAnalysisMode(mode) {
  state.analysisMode = mode || null;
  clearCriticalPathHighlighting();
  applyCriticalPathHighlighting();
}
function toggleAnalysisMode(mode, checkbox) {
  if (checkbox.checked) {
    setAnalysisMode(mode);
  } else {
    setAnalysisMode(null);
  }
}
function toggleCostLabels(show) {
  state.showCostLabels = show;
  if (show) {
    showCostLabels();
  } else {
    hideCostLabels();
  }
}
function showCostLabels() {
  const pipelines = state.currentConfig?.pipelines || [];
  const pipelineMap = /* @__PURE__ */ new Map();
  pipelines.forEach((p) => pipelineMap.set(p.name, p));
  d3.select("#graph").selectAll(".node").each(function() {
    const node = d3.select(this);
    const title = node.select("title").text();
    const pipeline = pipelineMap.get(title);
    if (pipeline?.cost !== void 0) {
      const bbox = this.getBBox();
      const cost = pipeline.cost;
      const costText = cost >= 1 ? `$${cost.toFixed(0)}` : `$${cost.toFixed(2)}`;
      node.append("text").attr("class", "cost-label").attr("x", bbox.x + bbox.width / 2).attr("y", bbox.y - 4).attr("text-anchor", "middle").attr("font-size", "10px").attr("font-weight", "600").attr("fill", "#2e7d32").text(costText);
    }
  });
}
function hideCostLabels() {
  d3.select("#graph").selectAll(".cost-label").remove();
}
function clearCriticalPathHighlighting() {
  d3.select("#graph").selectAll(".node").classed("node-critical-path node-costliest-path node-dimmed", false);
  d3.select("#graph").selectAll(".edge").classed("edge-critical-path edge-costliest-path edge-dimmed", false);
}
function toggleGroup(groupName) {
  if (state.expandedGroups.has(groupName)) {
    state.expandedGroups.delete(groupName);
  } else {
    state.expandedGroups.add(groupName);
  }
  updateGraph();
  showNodeDetails(groupName);
}
function showBlastRadius(nodeName) {
  const modal = document.getElementById("blastRadiusModal");
  const graphContainer = document.getElementById("blast-radius-graph");
  const summaryContainer = document.getElementById("blast-radius-summary");
  const nodeNameEl = document.getElementById("blast-radius-node-name");
  if (!modal || !graphContainer || !summaryContainer) return;
  graphContainer.innerHTML = "";
  blastRadiusGraphInstance = null;
  nodeNameEl.textContent = nodeName;
  const analysis = generateBlastRadiusAnalysis(nodeName);
  if (!analysis || analysis.downstream.length === 0) {
    summaryContainer.innerHTML = `
            <div class="text-center" style="padding: 2rem; color: var(--text-muted);">
                <div style="font-size: 2rem; margin-bottom: 1rem;"></div>
                <div>No downstream dependencies</div>
                <div class="small mt-2">This node has no downstream impact.</div>
            </div>
        `;
    graphContainer.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-muted);">
                No downstream dependencies to visualize
            </div>
        `;
    const bsModal2 = new bootstrap.Modal(modal);
    bsModal2.show();
    return;
  }
  const isGroup = analysis.source_type === "group";
  let summaryHtml = `
        <div class="lineage-view-toggle" style="margin-bottom: 0.75rem;">
            <span class="lineage-toggle-label active" data-view="tree">Summary</span>
            <div class="lineage-toggle-slider" id="blast-radius-toggle"></div>
            <span class="lineage-toggle-label" data-view="json">JSON</span>
        </div>
        <div id="blast-radius-tree-view">
    `;
  if (isGroup && analysis.group_members) {
    summaryHtml += `
            <div class="mb-3">
                <div style="font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; margin-bottom: 0.25rem;">Group Members (${analysis.group_size})</div>
                <div style="display: flex; flex-wrap: wrap; gap: 0.25rem;">
                    ${analysis.group_members.map((m) => `<span style="font-size: 0.75rem; padding: 0.15rem 0.4rem; background: var(--bg-secondary); border-radius: 3px; border-left: 2px solid #00897b;"> ${m}</span>`).join("")}
                </div>
            </div>
        `;
  }
  summaryHtml += `
            <div class="mb-3">
                <div style="font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; margin-bottom: 0.25rem;">Impact Summary</div>
                <div style="display: flex; gap: 1rem;">
                    <div style="text-align: center; padding: 0.5rem 1rem; background: var(--bg-secondary); border-radius: 4px;">
                        <div style="font-size: 1.5rem; font-weight: bold; color: #c98b8b;">${analysis.total_affected}</div>
                        <div style="font-size: 0.7rem; color: var(--text-muted);">Total Affected</div>
                    </div>
                    <div style="text-align: center; padding: 0.5rem 1rem; background: var(--bg-secondary); border-radius: 4px;">
                        <div style="font-size: 1.5rem; font-weight: bold; color: #6b9dc4;">${analysis.max_depth}</div>
                        <div style="font-size: 0.7rem; color: var(--text-muted);">Max Depth</div>
                    </div>
                </div>
            </div>
    `;
  Object.entries(analysis.by_depth).forEach(([depth, nodes]) => {
    const depthColors = ["#c98b8b", "#d4a574", "#c4c474", "#7cb47c", "#6b9dc4", "#a88bc4"];
    const color = depthColors[Math.min(parseInt(depth), depthColors.length - 1)];
    summaryHtml += `
            <div class="mb-2">
                <div style="font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; margin-bottom: 0.25rem;">
                    Depth ${depth} <span style="color: ${color};"></span>
                </div>
                <div style="display: flex; flex-wrap: wrap; gap: 0.25rem;">
        `;
    nodes.forEach((node) => {
      const icon = node.type === "pipeline" ? "" : "";
      summaryHtml += `<span style="font-size: 0.75rem; padding: 0.15rem 0.4rem; background: var(--bg-secondary); border-radius: 3px; border-left: 2px solid ${color};">${icon} ${node.name}</span>`;
    });
    summaryHtml += `</div></div>`;
  });
  summaryHtml += `</div>`;
  summaryHtml += `
        <div id="blast-radius-json-view" style="display: none;">
            <pre style="font-size: 0.7rem; max-height: 400px; overflow: auto; background: var(--bg-code); color: var(--text-primary); padding: 0.75rem; border-radius: 4px; margin: 0; border: 1px solid var(--border-color);">${JSON.stringify(analysis, null, 2)}</pre>
        </div>
    `;
  summaryContainer.innerHTML = summaryHtml;
  const toggle = document.getElementById("blast-radius-toggle");
  if (toggle) {
    toggle.addEventListener("click", function() {
      const isJson = this.classList.toggle("json-active");
      const treeView = document.getElementById("blast-radius-tree-view");
      const jsonView = document.getElementById("blast-radius-json-view");
      const treeLabel = summaryContainer.querySelector('.lineage-toggle-label[data-view="tree"]');
      const jsonLabel = summaryContainer.querySelector('.lineage-toggle-label[data-view="json"]');
      if (isJson) {
        treeView.style.display = "none";
        jsonView.style.display = "block";
        treeLabel.classList.remove("active");
        jsonLabel.classList.add("active");
      } else {
        treeView.style.display = "block";
        jsonView.style.display = "none";
        treeLabel.classList.add("active");
        jsonLabel.classList.remove("active");
      }
    });
  }
  const bsModal = new bootstrap.Modal(modal);
  modal.addEventListener(
    "shown.bs.modal",
    function onShown() {
      modal.removeEventListener("shown.bs.modal", onShown);
      const dot = generateBlastRadiusDot(analysis);
      if (dot) {
        try {
          graphContainer.innerHTML = "";
          const width = graphContainer.clientWidth || 600;
          const height = 500;
          blastRadiusGraphInstance = d3.select("#blast-radius-graph").graphviz().width(width).height(height).fit(true).zoom(false).on("end", function() {
            const svg = d3.select("#blast-radius-graph svg");
            const g = svg.select("g");
            const zoom = d3.zoom().scaleExtent([0.1, 4]).on("zoom", function(event) {
              g.attr("transform", event.transform);
            });
            svg.call(zoom);
            svg.on("dblclick.zoom", function() {
              svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity);
            });
          });
          blastRadiusGraphInstance.renderDot(dot);
        } catch (e) {
          console.error("Blast radius graph error:", e);
          graphContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-muted);">
                        Error rendering graph
                    </div>
                `;
        }
      }
    },
    { once: true }
  );
  bsModal.show();
}
function toggleTheme() {
  const html = document.documentElement;
  const btn = document.getElementById("theme-toggle");
  if (html.getAttribute("data-theme") === "dark") {
    html.removeAttribute("data-theme");
    btn.textContent = "";
    localStorage.setItem("pipeviz-theme", "light");
  } else {
    html.setAttribute("data-theme", "dark");
    btn.textContent = "";
    localStorage.setItem("pipeviz-theme", "dark");
  }
  renderSplashGraph();
  updateGraph();
}
function initTheme() {
  const saved = localStorage.getItem("pipeviz-theme");
  if (saved === "dark") {
    document.documentElement.setAttribute("data-theme", "dark");
    document.getElementById("theme-toggle").textContent = "";
  }
}
function setupTabs() {
  document.querySelectorAll("#dashboardTabs button").forEach((tab) => {
    tab.addEventListener("shown.bs.tab", function(e) {
      const tabs = document.getElementById("dashboardTabs");
      const tabName = e.target.id.replace("-tab", "");
      if (e.target.id === "home-tab") {
        tabs.classList.add("hidden-on-home");
        history.replaceState(null, "", window.location.pathname + window.location.search);
      } else {
        tabs.classList.remove("hidden-on-home");
        history.replaceState(null, "", "#" + tabName);
      }
    });
  });
}
function activateTabFromHash() {
  const hash = window.location.hash.slice(1);
  if (hash) {
    const tab = document.getElementById(hash + "-tab");
    if (tab) {
      tab.click();
    }
  }
}
function renderPipelines() {
  if (!state.currentConfig || !state.currentConfig.pipelines) return;
  const container = document.getElementById("pipelines-table-container");
  let html = `
        <div class="table-container">
        <table class="table table-striped table-hover">
            <thead>
                <tr>
                    <th>Pipeline</th>
                    <th>Description</th>
                    <th>Schedule</th>
                    <th>Input Sources</th>
                    <th>Output Sources</th>
                    <th>Cluster</th>
                    <th>Tags</th>
                    <th>Links</th>
                </tr>
            </thead>
            <tbody>
    `;
  state.currentConfig.pipelines.forEach((pipeline) => {
    const inputSources = pipeline.input_sources?.map(
      (s) => `<span class="badge me-1 mb-1" style="background-color: #e3f2fd; color: #1565c0; font-size: 0.85em;">${s}</span>`
    ).join("") || "";
    const outputSources = pipeline.output_sources?.map(
      (s) => `<span class="badge me-1 mb-1" style="background-color: #e8f5e8; color: #2e7d32; font-size: 0.85em;">${s}</span>`
    ).join("") || "";
    const cluster = pipeline.cluster ? `<span class="badge badge-cluster me-1 mb-1">${pipeline.cluster}</span>` : "";
    const tags = pipeline.tags?.map(
      (t) => `<span class="badge me-1 mb-1" style="background-color: #fff3cd; color: #856404; font-size: 0.85em;">${t}</span>`
    ).join("") || "";
    const links = pipeline.links ? `<div class="links-scroll">${Object.entries(pipeline.links).map(
      ([name, url]) => `<a href="${url}" target="_blank" class="graph-ctrl-btn" style="font-size: 0.7em; padding: 2px 6px;">${name}</a>`
    ).join("")}</div>` : "";
    html += `
            <tr class="pipeline-row"
                data-name="${pipeline.name.toLowerCase()}"
                data-description="${(pipeline.description || "").toLowerCase()}"
                data-cluster="${(pipeline.cluster || "").toLowerCase()}"
                data-tags="${(pipeline.tags || []).join(",").toLowerCase()}">
                <td class="col-name"><div><strong>${pipeline.name}</strong></div></td>
                <td class="col-desc"><div>${pipeline.description || ""}</div></td>
                <td class="col-schedule"><div><code class="text-success">${pipeline.schedule || ""}</code></div></td>
                <td class="col-sources"><div>${inputSources}</div></td>
                <td class="col-sources"><div>${outputSources}</div></td>
                <td class="col-cluster"><div>${cluster}</div></td>
                <td class="col-tags"><div>${tags}</div></td>
                <td class="col-links"><div>${links}</div></td>
            </tr>
        `;
  });
  html += "</tbody></table></div>";
  container.innerHTML = html;
}
function renderDatasources() {
  if (!state.currentConfig || !state.currentConfig.pipelines) {
    const container2 = document.getElementById("datasources-table-container");
    container2.innerHTML = '<p class="text-muted text-center">Load a configuration to see your data sources</p>';
    return;
  }
  const allDataSources = /* @__PURE__ */ new Map();
  if (state.currentConfig.datasources) {
    state.currentConfig.datasources.forEach((ds) => {
      allDataSources.set(ds.name, ds);
    });
  }
  state.currentConfig.pipelines.forEach((pipeline) => {
    pipeline.input_sources?.forEach((sourceName) => {
      if (!allDataSources.has(sourceName)) {
        allDataSources.set(sourceName, {
          name: sourceName,
          type: "auto-created",
          description: "Auto-created from pipeline references",
          isAutoCreated: true
        });
      }
    });
    pipeline.output_sources?.forEach((sourceName) => {
      if (!allDataSources.has(sourceName)) {
        allDataSources.set(sourceName, {
          name: sourceName,
          type: "auto-created",
          description: "Auto-created from pipeline references",
          isAutoCreated: true
        });
      }
    });
  });
  const container = document.getElementById("datasources-table-container");
  if (allDataSources.size === 0) {
    container.innerHTML = '<p class="text-muted text-center">No data sources found</p>';
    return;
  }
  let html = `
        <div class="table-container">
        <table class="table table-striped table-hover">
            <thead>
                <tr>
                    <th>Name & Type</th>
                    <th>Description</th>
                    <th>Owner</th>
                    <th>Metadata</th>
                    <th>Cluster</th>
                    <th>Tags</th>
                    <th>Links</th>
                </tr>
            </thead>
            <tbody>
    `;
  allDataSources.forEach((ds) => {
    const typeBadge = `<span class="badge badge-${ds.type || "secondary"}">${(ds.type || "unknown").toUpperCase()}</span>`;
    const metadata = ds.metadata ? Object.entries(ds.metadata).map(
      ([k, v]) => `<div class="small text-muted mb-1"><span style="font-weight: 500;">${k.replace(/_/g, " ")}:</span> ${v}</div>`
    ).join("") : "";
    const cluster = ds.cluster ? `<span class="badge badge-cluster me-1 mb-1">${ds.cluster}</span>` : "";
    const tags = ds.tags?.map(
      (t) => `<span class="badge me-1 mb-1" style="background-color: #fff3cd; color: #856404; font-size: 0.85em;">${t}</span>`
    ).join("") || "";
    const links = ds.links ? `<div class="links-scroll">${Object.entries(ds.links).map(
      ([name, url]) => `<a href="${url}" target="_blank" class="graph-ctrl-btn" style="font-size: 0.7em; padding: 2px 6px;">${name}</a>`
    ).join("")}</div>` : "";
    html += `
            <tr class="datasource-row"
                data-name="${ds.name.toLowerCase()}"
                data-type="${(ds.type || "").toLowerCase()}"
                data-cluster="${(ds.cluster || "").toLowerCase()}"
                data-tags="${(ds.tags || []).join(",").toLowerCase()}"
                data-search="${(ds.name + " " + (ds.description || "") + " " + (ds.owner || "")).toLowerCase()}">
                <td class="col-name"><div><strong>${ds.name}</strong><br>${typeBadge}</div></td>
                <td class="col-desc"><div>${ds.isAutoCreated ? `<span class="text-secondary fst-italic">${ds.description}</span>` : ds.description || ""}</div></td>
                <td class="col-owner"><div class="small text-muted">${ds.owner || ""}</div></td>
                <td class="col-metadata"><div>${metadata}</div></td>
                <td class="col-cluster"><div>${cluster}</div></td>
                <td class="col-tags"><div>${tags}</div></td>
                <td class="col-links"><div>${links}</div></td>
            </tr>
        `;
  });
  html += "</tbody></table></div>";
  container.innerHTML = html;
}
const activeFilters = {
  pipelineTags: /* @__PURE__ */ new Set(),
  pipelineClusters: /* @__PURE__ */ new Set(),
  datasourceTypes: /* @__PURE__ */ new Set(),
  datasourceTags: /* @__PURE__ */ new Set(),
  datasourceClusters: /* @__PURE__ */ new Set()
};
function buildFilterGroup(label, type, values) {
  if (values.length === 0) return "";
  const activeCount = activeFilters[type].size;
  const hasActive = activeCount > 0;
  let html = `<span class="filter-group" data-filter-type="${type}">`;
  html += `<span class="filter-group-header${hasActive ? " has-active" : ""}">`;
  html += `<span class="filter-group-label">${label}</span>`;
  html += `<span class="filter-group-count">${hasActive ? activeCount : values.length}</span>`;
  html += `</span>`;
  html += `<div class="filter-group-dropdown"><div class="filter-group-dropdown-inner">`;
  html += values.map(
    (v) => `<span class="filter-tag${activeFilters[type].has(v) ? " active" : ""}" data-type="${type}" data-value="${v}">${v}</span>`
  ).join("");
  html += `</div></div></span>`;
  return html;
}
function updateFilterGroupHeaders() {
  document.querySelectorAll(".filter-group").forEach((group) => {
    const type = group.dataset.filterType;
    if (!type) return;
    const header = group.querySelector(".filter-group-header");
    const countEl = group.querySelector(".filter-group-count");
    const tags = group.querySelectorAll(".filter-tag");
    const activeCount = activeFilters[type].size;
    if (header) {
      header.classList.toggle("has-active", activeCount > 0);
    }
    if (countEl) {
      countEl.textContent = activeCount > 0 ? activeCount : tags.length;
    }
  });
}
function updateFilters() {
  if (!state.currentConfig) return;
  const pipelineTags = [...new Set(state.currentConfig.pipelines?.flatMap((p) => p.tags || []) || [])].sort();
  const pipelineClusters = [
    ...new Set(state.currentConfig.pipelines?.map((p) => p.cluster).filter((c) => c) || [])
  ].sort();
  let pipelineHtml = "";
  pipelineHtml += buildFilterGroup("cluster", "pipelineClusters", pipelineClusters);
  pipelineHtml += buildFilterGroup("tag", "pipelineTags", pipelineTags);
  document.getElementById("pipeline-filters").innerHTML = pipelineHtml;
  const datasourceTypes = [
    ...new Set(state.currentConfig.datasources?.map((ds) => ds.type || "unknown") || [])
  ].sort();
  const datasourceTags = [...new Set(state.currentConfig.datasources?.flatMap((ds) => ds.tags || []) || [])].sort();
  const datasourceClusters = [
    ...new Set(state.currentConfig.datasources?.map((ds) => ds.cluster).filter((c) => c) || [])
  ].sort();
  let datasourceHtml = "";
  datasourceHtml += buildFilterGroup("type", "datasourceTypes", datasourceTypes);
  datasourceHtml += buildFilterGroup("cluster", "datasourceClusters", datasourceClusters);
  datasourceHtml += buildFilterGroup("tag", "datasourceTags", datasourceTags);
  document.getElementById("datasource-filters").innerHTML = datasourceHtml;
  document.querySelectorAll(".filter-tag").forEach((tag) => {
    tag.addEventListener("click", function(e) {
      e.stopPropagation();
      const type = this.dataset.type;
      const value = this.dataset.value;
      if (activeFilters[type].has(value)) {
        activeFilters[type].delete(value);
        this.classList.remove("active");
      } else {
        activeFilters[type].add(value);
        this.classList.add("active");
      }
      updateFilterGroupHeaders();
      if (type.startsWith("pipeline")) {
        filterPipelines();
      } else {
        filterDatasources();
      }
    });
  });
}
function filterPipelines() {
  const searchTerm = document.getElementById("pipeline-search").value.toLowerCase();
  const rows = document.querySelectorAll(".pipeline-row");
  rows.forEach((row) => {
    const name = row.getAttribute("data-name");
    const description = row.getAttribute("data-description");
    const tags = row.getAttribute("data-tags").split(",").filter((t) => t);
    const cluster = row.getAttribute("data-cluster");
    const matchesSearch = !searchTerm || name.includes(searchTerm) || description.includes(searchTerm);
    const matchesTag = activeFilters.pipelineTags.size === 0 || tags.some((t) => activeFilters.pipelineTags.has(t));
    const matchesCluster = activeFilters.pipelineClusters.size === 0 || activeFilters.pipelineClusters.has(cluster);
    row.style.display = matchesSearch && matchesTag && matchesCluster ? "" : "none";
  });
}
function filterDatasources() {
  const searchTerm = document.getElementById("datasource-search").value.toLowerCase();
  const rows = document.querySelectorAll(".datasource-row");
  rows.forEach((row) => {
    const searchContent = row.getAttribute("data-search");
    const type = row.getAttribute("data-type");
    const tags = row.getAttribute("data-tags").split(",").filter((t) => t);
    const cluster = row.getAttribute("data-cluster");
    const matchesSearch = !searchTerm || searchContent.includes(searchTerm);
    const matchesType = activeFilters.datasourceTypes.size === 0 || activeFilters.datasourceTypes.has(type);
    const matchesTag = activeFilters.datasourceTags.size === 0 || tags.some((t) => activeFilters.datasourceTags.has(t));
    const matchesCluster = activeFilters.datasourceClusters.size === 0 || activeFilters.datasourceClusters.has(cluster);
    row.style.display = matchesSearch && matchesType && matchesTag && matchesCluster ? "" : "none";
  });
}
function updateDotView() {
  const dotOutput = document.getElementById("dot-output");
  if (dotOutput) {
    dotOutput.value = generateGraphvizDot();
  }
}
function copyDotToClipboard(event) {
  const dotOutput = document.getElementById("dot-output");
  if (dotOutput) {
    navigator.clipboard.writeText(dotOutput.value).then(() => {
      const btn = event?.target || document.activeElement;
      const originalText = btn.textContent;
      btn.textContent = "Copied!";
      setTimeout(() => {
        btn.textContent = originalText;
      }, 2e3);
    }).catch(() => {
      dotOutput.select();
      dotOutput.setSelectionRange(0, 99999);
    });
  }
}
const WAVE_COLORS = [
  { fill: "#e8f5e9", border: "#81c784", text: "#495057" },
  { fill: "#e3f2fd", border: "#64b5f6", text: "#495057" },
  { fill: "#f3e5f5", border: "#ba68c8", text: "#495057" },
  { fill: "#fff3e0", border: "#ffb74d", text: "#495057" },
  { fill: "#e0f7fa", border: "#4dd0e1", text: "#495057" },
  { fill: "#fce4ec", border: "#f48fb1", text: "#495057" }
];
const WAVE_COLORS_DARK = [
  { fill: "#2a4a3a", border: "#81c784", text: "#e0e0e0" },
  { fill: "#2a3a4a", border: "#64b5f6", text: "#e0e0e0" },
  { fill: "#3a2a4a", border: "#ba68c8", text: "#e0e0e0" },
  { fill: "#4a3a2a", border: "#ffb74d", text: "#e0e0e0" },
  { fill: "#2a4a4a", border: "#4dd0e1", text: "#e0e0e0" },
  { fill: "#4a2a3a", border: "#f48fb1", text: "#e0e0e0" }
];
const WAVE0_COLOR = { fill: "#fef3e2", border: "#d4915c", text: "#495057" };
const WAVE0_COLOR_DARK = { fill: "#4a3a2a", border: "#d4915c", text: "#e0e0e0" };
let currentExportFormat = "json";
let currentBackfillView = "pipeline";
let backfillGraphInstance = null;
let selectedBackfillPipelines = [];
function generateGraphExport() {
  if (!state.currentConfig) return null;
  const nodes = [];
  const edges = [];
  const nodeIds = /* @__PURE__ */ new Set();
  const pipelines = state.currentConfig.pipelines || [];
  pipelines.forEach((p) => {
    const node = {
      id: p.name,
      type: "pipeline"
    };
    if (p.description) node.description = p.description;
    if (p.schedule) node.schedule = p.schedule;
    if (p.cluster) node.cluster = p.cluster;
    if (p.group) node.group = p.group;
    if (p.owner) node.owner = p.owner;
    if (p.tags?.length) node.tags = p.tags;
    if (p.links && Object.keys(p.links).length) node.links = p.links;
    if (p.metadata && Object.keys(p.metadata).length) node.metadata = p.metadata;
    nodes.push(node);
    nodeIds.add(p.name);
    p.input_sources?.forEach((source) => {
      edges.push({ source, target: p.name, type: "data_flow" });
    });
    p.output_sources?.forEach((source) => {
      edges.push({ source: p.name, target: source, type: "data_flow" });
    });
    if (p.upstream_pipelines) {
      p.upstream_pipelines.forEach((upstream) => {
        edges.push({ source: upstream, target: p.name, type: "pipeline_dependency" });
      });
    }
  });
  const datasources = state.currentConfig.datasources || [];
  datasources.forEach((ds) => {
    const node = {
      id: ds.name,
      type: "datasource"
    };
    if (ds.description) node.description = ds.description;
    if (ds.type) node.source_type = ds.type;
    if (ds.cluster) node.cluster = ds.cluster;
    if (ds.owner) node.owner = ds.owner;
    if (ds.tags?.length) node.tags = ds.tags;
    if (ds.links && Object.keys(ds.links).length) node.links = ds.links;
    if (ds.metadata && Object.keys(ds.metadata).length) node.metadata = ds.metadata;
    nodes.push(node);
    nodeIds.add(ds.name);
  });
  const referencedSources = /* @__PURE__ */ new Set();
  pipelines.forEach((p) => {
    p.input_sources?.forEach((s) => referencedSources.add(s));
    p.output_sources?.forEach((s) => referencedSources.add(s));
  });
  referencedSources.forEach((source) => {
    if (!nodeIds.has(source)) {
      nodes.push({
        id: source,
        type: "datasource",
        implicit: true
      });
      nodeIds.add(source);
    }
  });
  const clusters = state.currentConfig.clusters || [];
  return {
    nodes,
    edges,
    clusters: clusters.map((c) => ({
      id: c.name,
      description: c.description,
      parent: c.parent
    })),
    meta: {
      node_count: nodes.length,
      edge_count: edges.length,
      pipeline_count: pipelines.length,
      datasource_count: nodes.filter((n) => n.type === "datasource").length,
      generated_at: (/* @__PURE__ */ new Date()).toISOString()
    }
  };
}
function generateMermaidExport() {
  if (!state.currentConfig) return null;
  const pipelines = state.currentConfig.pipelines || [];
  const datasources = state.currentConfig.datasources || [];
  const nodeIds = /* @__PURE__ */ new Set();
  const pipelineIds = /* @__PURE__ */ new Set();
  pipelines.forEach((p) => {
    nodeIds.add(p.name);
    pipelineIds.add(p.name);
  });
  datasources.forEach((ds) => nodeIds.add(ds.name));
  pipelines.forEach((p) => {
    p.input_sources?.forEach((s) => nodeIds.add(s));
    p.output_sources?.forEach((s) => nodeIds.add(s));
  });
  const sanitize = (id) => id.replace(/[^a-zA-Z0-9]/g, "_");
  let mermaid = "flowchart LR\n";
  mermaid += "    %% Nodes\n";
  nodeIds.forEach((id) => {
    const sId = sanitize(id);
    if (pipelineIds.has(id)) {
      mermaid += `    ${sId}[["${id}"]]
`;
    } else {
      mermaid += `    ${sId}[("${id}")]
`;
    }
  });
  mermaid += "\n    %% Edges\n";
  const edges = /* @__PURE__ */ new Set();
  pipelines.forEach((p) => {
    const pId = sanitize(p.name);
    p.input_sources?.forEach((source) => {
      const edge = `    ${sanitize(source)} --> ${pId}`;
      edges.add(edge);
    });
    p.output_sources?.forEach((source) => {
      const edge = `    ${pId} --> ${sanitize(source)}`;
      edges.add(edge);
    });
    p.upstream_pipelines?.forEach((upstream) => {
      const edge = `    ${sanitize(upstream)} -.-> ${pId}`;
      edges.add(edge);
    });
  });
  edges.forEach((edge) => {
    mermaid += edge + "\n";
  });
  mermaid += "\n    %% Styling\n";
  mermaid += "    classDef pipeline fill:#fff3e0,stroke:#e65100,stroke-width:2px\n";
  mermaid += "    classDef datasource fill:#e3f2fd,stroke:#1565c0,stroke-width:2px\n";
  const pipelineList = [...pipelineIds].map(sanitize).join(",");
  const datasourceList = [...nodeIds].filter((id) => !pipelineIds.has(id)).map(sanitize).join(",");
  if (pipelineList) mermaid += `    class ${pipelineList} pipeline
`;
  if (datasourceList) mermaid += `    class ${datasourceList} datasource
`;
  return mermaid;
}
function generateBackfillAnalysis(nodeNames) {
  if (!state.currentConfig) return null;
  const sourceNodes = Array.isArray(nodeNames) ? nodeNames : [nodeNames];
  if (sourceNodes.length === 0) return null;
  const pipelines = state.currentConfig.pipelines || [];
  const pipelineNames = new Set(pipelines.map((p) => p.name));
  const invalidNodes = sourceNodes.filter((n) => !pipelineNames.has(n));
  if (invalidNodes.length > 0) {
    return {
      nodes: sourceNodes,
      message: `Backfill planning is only available for pipelines. Invalid: ${invalidNodes.join(", ")}`,
      waves: []
    };
  }
  const downstreamMap = {};
  pipelines.forEach((p) => {
    if (p.upstream_pipelines) {
      p.upstream_pipelines.forEach((upstream) => {
        if (!downstreamMap[upstream]) downstreamMap[upstream] = [];
        downstreamMap[upstream].push(p.name);
      });
    }
  });
  const outputToProducer = {};
  pipelines.forEach((p) => {
    if (p.output_sources) {
      p.output_sources.forEach((ds) => {
        outputToProducer[ds] = p.name;
      });
    }
  });
  pipelines.forEach((p) => {
    if (p.input_sources) {
      p.input_sources.forEach((ds) => {
        const producer = outputToProducer[ds];
        if (producer && producer !== p.name) {
          if (!downstreamMap[producer]) downstreamMap[producer] = [];
          if (!downstreamMap[producer].includes(p.name)) {
            downstreamMap[producer].push(p.name);
          }
        }
      });
    }
  });
  function getReachable(startNode) {
    const reachable = /* @__PURE__ */ new Set();
    const q = [startNode];
    while (q.length > 0) {
      const curr = q.shift();
      const children = downstreamMap[curr] || [];
      for (const child of children) {
        if (!reachable.has(child)) {
          reachable.add(child);
          q.push(child);
        }
      }
    }
    return reachable;
  }
  new Set(sourceNodes);
  const reachableFromSources = /* @__PURE__ */ new Map();
  sourceNodes.forEach((node) => {
    reachableFromSources.set(node, getReachable(node));
  });
  const trueSources = sourceNodes.filter((node) => {
    for (const otherNode of sourceNodes) {
      if (otherNode !== node && reachableFromSources.get(otherNode).has(node)) {
        return false;
      }
    }
    return true;
  });
  const downstreamSelectedNodes = sourceNodes.filter((node) => !trueSources.includes(node));
  const visited = new Set(trueSources);
  const allDownstream = [];
  const queue = trueSources.map((n) => ({ name: n, depth: 0 }));
  while (queue.length > 0) {
    const current = queue.shift();
    const children = downstreamMap[current.name] || [];
    children.forEach((child) => {
      if (!visited.has(child)) {
        visited.add(child);
        allDownstream.push({ name: child, depth: current.depth + 1 });
        queue.push({ name: child, depth: current.depth + 1 });
      }
    });
  }
  downstreamSelectedNodes.forEach((node) => {
    if (!allDownstream.find((d) => d.name === node)) {
      allDownstream.push({ name: node, depth: 1 });
    }
  });
  if (allDownstream.length === 0 && trueSources.length === sourceNodes.length) {
    return {
      nodes: sourceNodes,
      message: "No downstream pipelines to backfill.",
      waves: []
    };
  }
  const downstreamNames = new Set(allDownstream.map((d) => d.name));
  const edges = [];
  trueSources.forEach((sourceNode) => {
    const directDownstream = downstreamMap[sourceNode] || [];
    directDownstream.forEach((target) => {
      if (downstreamNames.has(target)) {
        edges.push({ source: sourceNode, target });
      }
    });
  });
  downstreamNames.forEach((node) => {
    const children = downstreamMap[node] || [];
    children.forEach((target) => {
      if (downstreamNames.has(target)) {
        edges.push({ source: node, target });
      }
    });
  });
  const inDegree = {};
  const graph = {};
  downstreamNames.forEach((node) => {
    inDegree[node] = 0;
    graph[node] = [];
  });
  edges.forEach(({ source, target }) => {
    if (downstreamNames.has(source) && downstreamNames.has(target)) {
      graph[source].push(target);
      inDegree[target]++;
    }
  });
  let waveQueue = Object.keys(inDegree).filter((n) => inDegree[n] === 0);
  const waves = [];
  while (waveQueue.length > 0) {
    const waveNodes = waveQueue.map((name) => {
      const pipeline = pipelines.find((p) => p.name === name);
      const nodeInfo = { name };
      if (pipeline) {
        if (pipeline.schedule) nodeInfo.schedule = pipeline.schedule;
        if (pipeline.owner) nodeInfo.owner = pipeline.owner;
        if (pipeline.cluster) nodeInfo.cluster = pipeline.cluster;
      }
      return nodeInfo;
    });
    waves.push(waveNodes);
    const nextQueue = [];
    waveQueue.forEach((node) => {
      graph[node].forEach((neighbor) => {
        inDegree[neighbor]--;
        if (inDegree[neighbor] === 0) {
          nextQueue.push(neighbor);
        }
      });
    });
    waveQueue = nextQueue;
  }
  const wave0Pipelines = trueSources.map((nodeName) => {
    const pipeline = pipelines.find((p) => p.name === nodeName);
    const nodeInfo = { name: nodeName };
    if (pipeline) {
      if (pipeline.schedule) nodeInfo.schedule = pipeline.schedule;
      if (pipeline.owner) nodeInfo.owner = pipeline.owner;
      if (pipeline.cluster) nodeInfo.cluster = pipeline.cluster;
    }
    return nodeInfo;
  });
  const allWaves = [
    { wave: 0, parallel_count: wave0Pipelines.length, pipelines: wave0Pipelines },
    ...waves.map((nodes, idx) => ({
      wave: idx + 1,
      parallel_count: nodes.length,
      pipelines: nodes
    }))
  ];
  return {
    nodes: sourceNodes,
    total_downstream_pipelines: allDownstream.length,
    total_waves: allWaves.length,
    max_parallelism: Math.max(...allWaves.map((w) => w.parallel_count), 1),
    waves: allWaves,
    edges
  };
}
function setExportFormat(format) {
  currentExportFormat = format;
  updateExportView();
  document.querySelectorAll(".export-format-btn").forEach((btn) => {
    btn.classList.toggle("active", btn.dataset.format === format);
  });
}
function updateExportView() {
  const output = document.getElementById("export-output");
  if (!output) return;
  let content = "";
  if (currentExportFormat === "mermaid") {
    content = generateMermaidExport() || "Load a configuration to see the Mermaid export...";
  } else if (currentExportFormat === "dot") {
    content = generateGraphvizDot() || "Load a configuration to see the DOT export...";
  } else {
    const graphExport = generateGraphExport();
    content = graphExport ? JSON.stringify(graphExport, null, 2) : "Load a configuration to see the graph export...";
  }
  output.textContent = content;
}
function copyExportToClipboard(event) {
  const output = document.getElementById("export-output");
  if (!output) return;
  const btn = event.target.closest(".export-copy-btn");
  navigator.clipboard.writeText(output.textContent).then(() => {
    if (btn) {
      btn.classList.add("copied");
      btn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
      setTimeout(() => {
        btn.classList.remove("copied");
        btn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
      }, 1500);
    }
  });
}
function populateBackfillSelect() {
  const list = document.getElementById("backfill-picker-list");
  if (!list) return;
  list.innerHTML = "";
  selectedBackfillPipelines = [];
  updatePickerButton();
  updatePickerCount();
  const filterInput = document.getElementById("backfill-picker-filter");
  if (filterInput) filterInput.value = "";
  if (filterInput) {
    filterInput.placeholder = currentBackfillView === "blast" ? "Filter nodes..." : "Filter pipelines...";
  }
  if (!state.currentConfig) return;
  const pipelines = state.currentConfig.pipelines || [];
  const datasources = state.currentConfig.datasources || [];
  const isBlastMode = currentBackfillView === "blast";
  const grouped = {};
  pipelines.forEach((p) => {
    const group = p.cluster || p.group || "Pipelines";
    if (!grouped[group]) grouped[group] = [];
    grouped[group].push({ name: p.name, type: "pipeline" });
  });
  if (isBlastMode) {
    datasources.forEach((ds) => {
      const group = ds.cluster || "Datasources";
      if (!grouped[group]) grouped[group] = [];
      grouped[group].push({ name: ds.name, type: "datasource" });
    });
  }
  const sortedGroups = Object.keys(grouped).sort();
  sortedGroups.forEach((groupName) => {
    const groupLabel = document.createElement("div");
    groupLabel.className = "backfill-picker-group";
    groupLabel.textContent = groupName;
    groupLabel.dataset.group = groupName;
    list.appendChild(groupLabel);
    grouped[groupName].forEach((item) => {
      const itemEl = document.createElement("label");
      itemEl.className = "backfill-picker-item";
      itemEl.dataset.pipeline = item.name.toLowerCase();
      itemEl.dataset.group = groupName;
      const input = document.createElement("input");
      input.type = isBlastMode ? "radio" : "checkbox";
      input.name = isBlastMode ? "blast-node" : "";
      input.value = item.name;
      input.addEventListener("change", handlePipelineCheckChange);
      itemEl.appendChild(input);
      itemEl.appendChild(document.createTextNode(item.name));
      if (item.type === "datasource") {
        const tag = document.createElement("span");
        tag.className = "picker-ds-tag";
        tag.textContent = "ds";
        itemEl.appendChild(tag);
      }
      list.appendChild(itemEl);
    });
  });
}
function handlePipelineCheckChange(e) {
  const value = e.target.value;
  const isBlastMode = currentBackfillView === "blast";
  if (isBlastMode) {
    selectedBackfillPipelines = [value];
  } else {
    if (e.target.checked) {
      if (!selectedBackfillPipelines.includes(value)) {
        selectedBackfillPipelines.push(value);
      }
    } else {
      selectedBackfillPipelines = selectedBackfillPipelines.filter((p) => p !== value);
    }
  }
  updatePickerButton();
  updatePickerCount();
  updateBackfillPlan();
}
function filterBackfillPipelines(query) {
  const list = document.getElementById("backfill-picker-list");
  if (!list) return;
  const lowerQuery = query.toLowerCase().trim();
  const visibleGroups = /* @__PURE__ */ new Set();
  list.querySelectorAll(".backfill-picker-item").forEach((item) => {
    const pipelineName = item.dataset.pipeline || "";
    const matches = !lowerQuery || pipelineName.includes(lowerQuery);
    item.classList.toggle("hidden", !matches);
    if (matches) {
      visibleGroups.add(item.dataset.group);
    }
  });
  list.querySelectorAll(".backfill-picker-group").forEach((label) => {
    label.classList.toggle("hidden", !visibleGroups.has(label.dataset.group));
  });
}
function toggleBackfillPicker() {
  const dropdown = document.getElementById("backfill-picker-dropdown");
  if (dropdown) {
    const isOpen = dropdown.classList.toggle("show");
    if (isOpen) {
      const filterInput = document.getElementById("backfill-picker-filter");
      if (filterInput) {
        setTimeout(() => filterInput.focus(), 0);
      }
      setTimeout(() => {
        document.addEventListener("click", closePickerOnClickOutside);
      }, 0);
    }
  }
}
function closePickerOnClickOutside(e) {
  const picker = document.querySelector(".backfill-pipeline-picker");
  const viewBtns = document.querySelectorAll(".backfill-view-btn");
  const isViewBtn = Array.from(viewBtns).some((btn) => btn.contains(e.target));
  if (picker && !picker.contains(e.target) && !isViewBtn) {
    const dropdown = document.getElementById("backfill-picker-dropdown");
    if (dropdown) dropdown.classList.remove("show");
    document.removeEventListener("click", closePickerOnClickOutside);
  }
}
function clearBackfillSelection() {
  const list = document.getElementById("backfill-picker-list");
  if (list) {
    list.querySelectorAll('input[type="checkbox"]').forEach((cb) => {
      cb.checked = false;
    });
  }
  selectedBackfillPipelines = [];
  updatePickerButton();
  updatePickerCount();
  updateBackfillPlan();
}
function updatePickerButton() {
  const btn = document.getElementById("backfill-picker-btn");
  if (!btn) return;
  const isBlast = currentBackfillView === "blast";
  if (selectedBackfillPipelines.length === 0) {
    btn.textContent = isBlast ? "Select a node..." : "Select pipelines...";
  } else if (selectedBackfillPipelines.length === 1) {
    btn.textContent = selectedBackfillPipelines[0];
  } else {
    btn.textContent = isBlast ? selectedBackfillPipelines[0] : `${selectedBackfillPipelines.length} pipelines selected`;
  }
}
function updatePickerCount() {
  const countEl = document.getElementById("backfill-picker-count");
  if (countEl) {
    const count = selectedBackfillPipelines.length;
    countEl.textContent = count === 0 ? "None selected" : count === 1 ? "1 selected" : `${count} selected`;
  }
}
function generateBackfillDot(analysis) {
  if (!analysis || !analysis.waves || analysis.waves.length === 0) return null;
  const isDark = document.documentElement.getAttribute("data-theme") === "dark";
  const bgColor = isDark ? "#1a1a1a" : "#ffffff";
  const textColor = isDark ? "#b0b0b0" : "#666666";
  const edgeColor = isDark ? "#666666" : "#999999";
  const waveColors = isDark ? WAVE_COLORS_DARK : WAVE_COLORS;
  const wave0Color = isDark ? WAVE0_COLOR_DARK : WAVE0_COLOR;
  let dot = `digraph BackfillPlan {
    rankdir=LR
    bgcolor="${bgColor}"
    fontname="Helvetica"
    node [fontname="Helvetica" fontsize="9" style="filled,rounded" shape="box"]
    edge [color="${edgeColor}" arrowsize="0.6"]
    
`;
  analysis.waves.forEach((wave) => {
    const colors = wave.wave === 0 ? wave0Color : waveColors[(wave.wave - 1) % waveColors.length];
    const pipelines = wave.pipelines || wave.nodes || [];
    dot += `    subgraph cluster_wave${wave.wave} {
        label="Wave ${wave.wave}"
        fontname="Helvetica"
        style="dashed"
        color="${colors.border}"
        fontcolor="${textColor}"
        fontsize="9"
        
`;
    pipelines.forEach((node) => {
      dot += `        "${node.name}" [label="${node.name}" fillcolor="${colors.fill}" color="${colors.border}" fontcolor="${colors.text}"]
`;
    });
    dot += `    }

`;
  });
  analysis.edges.forEach((edge) => {
    dot += `    "${edge.source}" -> "${edge.target}"
`;
  });
  dot += `}
`;
  return dot;
}
const VIEW_HINTS = {
  pipeline: "Select pipelines to plan execution order",
  airflow: "Maps pipelines to Airflow DAGs",
  blast: "Select a node to see all downstream dependencies affected by changes"
};
function setBackfillView(view) {
  currentBackfillView = view;
  document.querySelectorAll(".backfill-view-btn").forEach((btn) => {
    btn.classList.toggle("active", btn.dataset.view === view);
  });
  const hint = document.getElementById("backfill-hint");
  if (hint) hint.textContent = VIEW_HINTS[view] || "";
  backfillGraphInstance = null;
  const graphContainer = document.getElementById("backfill-graph");
  if (graphContainer && graphContainer.parentNode) {
    const parent = graphContainer.parentNode;
    const newContainer = document.createElement("div");
    newContainer.id = "backfill-graph";
    newContainer.className = "backfill-graph";
    parent.replaceChild(newContainer, graphContainer);
  }
  populateBackfillSelect();
  updatePickerButton();
  updateBackfillPlan();
  const dropdown = document.getElementById("backfill-picker-dropdown");
  if (dropdown && !dropdown.classList.contains("show")) {
    dropdown.classList.add("show");
    const filterInput = document.getElementById("backfill-picker-filter");
    if (filterInput) {
      setTimeout(() => filterInput.focus(), 0);
    }
    setTimeout(() => {
      document.addEventListener("click", closePickerOnClickOutside);
    }, 0);
  }
}
function extractAirflowDag(airflowUrl) {
  if (!airflowUrl) return null;
  const match = airflowUrl.match(/\/dags\/([^\/\?#]+)/);
  return match ? match[1] : airflowUrl;
}
function generateAirflowAnalysis(pipelineAnalysis) {
  if (!pipelineAnalysis || !pipelineAnalysis.waves) return null;
  const pipelines = state.currentConfig?.pipelines || [];
  const pipelineToDag = {};
  pipelineAnalysis.waves.forEach((wave) => {
    wave.pipelines.forEach((p) => {
      const pipeline = pipelines.find((pl) => pl.name === p.name);
      const airflowUrl = pipeline?.links?.airflow;
      if (!airflowUrl) {
        pipelineToDag[p.name] = {
          dag: p.name,
          airflow_url: null,
          missing: true
        };
      } else {
        pipelineToDag[p.name] = {
          dag: extractAirflowDag(airflowUrl),
          airflow_url: airflowUrl,
          missing: false
        };
      }
    });
  });
  const airflowWaves = pipelineAnalysis.waves.map((wave) => {
    const dagMap = /* @__PURE__ */ new Map();
    wave.pipelines.forEach((p) => {
      const dagInfo = pipelineToDag[p.name];
      if (dagInfo) {
        const key = dagInfo.missing ? `missing_${p.name}` : dagInfo.dag;
        if (!dagMap.has(key)) {
          dagMap.set(key, {
            dag: dagInfo.dag,
            airflow_url: dagInfo.airflow_url,
            pipelines: [],
            missing: dagInfo.missing
          });
        }
        dagMap.get(key).pipelines.push(p.name);
      }
    });
    return {
      wave: wave.wave,
      parallel_count: dagMap.size,
      dags: [...dagMap.values()]
    };
  });
  const edgeSet = /* @__PURE__ */ new Set();
  const dedupedEdges = [];
  pipelineAnalysis.edges.forEach((e) => {
    const sourceDag = pipelineToDag[e.source]?.dag || e.source;
    const targetDag = pipelineToDag[e.target]?.dag || e.target;
    const edgeKey = `${sourceDag}|${targetDag}`;
    if (!edgeSet.has(edgeKey) && sourceDag !== targetDag) {
      edgeSet.add(edgeKey);
      dedupedEdges.push({
        source_dag: sourceDag,
        target_dag: targetDag
      });
    }
  });
  return {
    node: pipelineAnalysis.node,
    node_dag: pipelineToDag[pipelineAnalysis.node]?.dag || pipelineAnalysis.node,
    view: "airflow",
    total_dags: new Set(Object.values(pipelineToDag).map((d) => d.dag)).size,
    total_waves: airflowWaves.length,
    waves: airflowWaves,
    edges: dedupedEdges
  };
}
function generateAirflowBackfillDot(analysis) {
  if (!analysis || !analysis.waves || analysis.waves.length === 0) return null;
  const isDark = document.documentElement.getAttribute("data-theme") === "dark";
  const bgColor = isDark ? "#1a1a1a" : "#ffffff";
  const textColor = isDark ? "#b0b0b0" : "#666666";
  const edgeColor = isDark ? "#666666" : "#999999";
  const missingColor = isDark ? { fill: "#2a2a2a", border: "#555555", text: "#888888" } : { fill: "#f5f5f5", border: "#cccccc", text: "#999999" };
  const wave0Color = isDark ? WAVE0_COLOR_DARK : WAVE0_COLOR;
  const waveColors = isDark ? WAVE_COLORS_DARK : WAVE_COLORS;
  let dot = `digraph AirflowBackfill {
    rankdir=LR
    bgcolor="${bgColor}"
    fontname="Helvetica"
    node [fontname="Helvetica" fontsize="9" style="filled,rounded" shape="box"]
    edge [color="${edgeColor}" arrowsize="0.6"]
    
`;
  analysis.waves.forEach((wave) => {
    const colors = wave.wave === 0 ? wave0Color : waveColors[(wave.wave - 1) % waveColors.length];
    dot += `    subgraph cluster_wave${wave.wave} {
        label="Stage ${wave.wave}"
        fontname="Helvetica"
        style="dashed"
        color="${colors.border}"
        fontcolor="${textColor}"
        fontsize="9"
        
`;
    wave.dags.forEach((d) => {
      if (d.missing) {
        const label = `${d.dag}\\n?`;
        dot += `        "${d.dag}" [label="${label}" fillcolor="${missingColor.fill}" color="${missingColor.border}" fontcolor="${missingColor.text}" style="filled,rounded,dashed"]
`;
      } else {
        dot += `        "${d.dag}" [label="${d.dag}" fillcolor="${colors.fill}" color="${colors.border}" fontcolor="${colors.text}" href="${d.airflow_url}" target="_blank" tooltip="Open in Airflow"]
`;
      }
    });
    dot += `    }

`;
  });
  analysis.edges.forEach((edge) => {
    dot += `    "${edge.source_dag}" -> "${edge.target_dag}"
`;
  });
  dot += `}
`;
  return dot;
}
function updateBackfillPlan() {
  const output = document.getElementById("backfill-output");
  const graphContainer = document.getElementById("backfill-graph");
  if (!output) return;
  if (selectedBackfillPipelines.length === 0) {
    output.textContent = "Select pipelines to see the backfill plan...";
    if (graphContainer) {
      graphContainer.innerHTML = '<div style="color: var(--text-muted); font-size: 12px; padding: 2rem; text-align: center;">Select pipelines to see the execution plan...</div>';
    }
    return;
  }
  const pipelineAnalysis = generateBackfillAnalysis(selectedBackfillPipelines);
  if (!pipelineAnalysis) {
    output.textContent = "Unable to generate backfill plan. Make sure a configuration is loaded.";
    if (graphContainer) {
      graphContainer.innerHTML = '<div style="color: var(--text-muted); font-size: 12px; padding: 2rem; text-align: center;">Unable to generate plan</div>';
    }
    return;
  }
  if (currentBackfillView === "airflow") {
    const airflowAnalysis = generateAirflowAnalysis(pipelineAnalysis);
    if (airflowAnalysis.error) {
      output.textContent = JSON.stringify(airflowAnalysis, null, 2);
      if (graphContainer) {
        graphContainer.innerHTML = `<div style="color: var(--text-muted); font-size: 12px; padding: 2rem; text-align: center;">${airflowAnalysis.message}</div>`;
      }
      return;
    }
    output.textContent = JSON.stringify(airflowAnalysis, null, 2);
    if (graphContainer && airflowAnalysis.waves && airflowAnalysis.waves.length > 0) {
      const dot = generateAirflowBackfillDot(airflowAnalysis);
      if (dot) {
        try {
          if (!backfillGraphInstance) {
            graphContainer.innerHTML = "";
            backfillGraphInstance = d3.select("#backfill-graph").graphviz().width(graphContainer.clientWidth).height(450).fit(true).zoom(true).transition(function() {
              return d3.transition().duration(300);
            });
          }
          backfillGraphInstance.renderDot(dot);
        } catch (e) {
          graphContainer.innerHTML = '<div style="color: var(--text-muted); font-size: 12px; padding: 2rem; text-align: center;">Error rendering graph</div>';
        }
      }
    }
    return;
  }
  if (currentBackfillView === "blast") {
    const sourceNode = selectedBackfillPipelines[0];
    const blastAnalysis = generateBlastRadiusAnalysis(sourceNode);
    if (!blastAnalysis || blastAnalysis.downstream.length === 0) {
      output.textContent = JSON.stringify(
        { node: sourceNode, downstream: [], message: "No downstream dependencies" },
        null,
        2
      );
      if (graphContainer) {
        graphContainer.innerHTML = '<div style="color: var(--text-muted); font-size: 12px; padding: 2rem; text-align: center;">No downstream dependencies for this node</div>';
      }
      return;
    }
    output.textContent = JSON.stringify(blastAnalysis, null, 2);
    if (graphContainer) {
      const dot = generateBlastRadiusDot(blastAnalysis);
      if (dot) {
        try {
          if (!backfillGraphInstance) {
            graphContainer.innerHTML = "";
            backfillGraphInstance = d3.select("#backfill-graph").graphviz().width(graphContainer.clientWidth).height(450).fit(true).zoom(true).transition(function() {
              return d3.transition().duration(300);
            });
          }
          backfillGraphInstance.renderDot(dot);
        } catch (e) {
          graphContainer.innerHTML = '<div style="color: var(--text-muted); font-size: 12px; padding: 2rem; text-align: center;">Error rendering graph</div>';
        }
      }
    }
    return;
  }
  output.textContent = JSON.stringify(pipelineAnalysis, null, 2);
  if (graphContainer && pipelineAnalysis.waves && pipelineAnalysis.waves.length > 0) {
    const dot = generateBackfillDot(pipelineAnalysis);
    if (dot) {
      try {
        if (!backfillGraphInstance) {
          graphContainer.innerHTML = "";
          backfillGraphInstance = d3.select("#backfill-graph").graphviz().width(graphContainer.clientWidth).height(450).fit(true).zoom(true).transition(function() {
            return d3.transition().duration(300);
          });
        }
        backfillGraphInstance.renderDot(dot);
      } catch (e) {
        graphContainer.innerHTML = '<div style="color: var(--text-muted); font-size: 12px; padding: 2rem; text-align: center;">Error rendering graph</div>';
      }
    }
  } else if (graphContainer) {
    graphContainer.innerHTML = '<div style="color: var(--text-muted); font-size: 12px; padding: 2rem; text-align: center;">No downstream dependencies to visualize</div>';
  }
}
function copyBackfillToClipboard(event) {
  const output = document.getElementById("backfill-output");
  if (!output) return;
  const btn = event.target.closest(".export-copy-btn");
  navigator.clipboard.writeText(output.textContent).then(() => {
    if (btn) {
      btn.classList.add("copied");
      btn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
      setTimeout(() => {
        btn.classList.remove("copied");
        btn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
      }, 1500);
    }
  });
}
function loadExample() {
  document.getElementById("json-input").value = JSON.stringify(exampleConfig, null, 2);
  loadJson();
}
function generateShareableUrl() {
  if (!state.currentConfig) {
    alert("No configuration loaded to share");
    return;
  }
  const configJson = JSON.stringify(state.currentConfig);
  const encodedConfig = btoa(configJson);
  const currentUrl = window.location.origin + window.location.pathname;
  const shareableUrl = `${currentUrl}?config=${encodedConfig}`;
  navigator.clipboard.writeText(shareableUrl).then(() => {
    const statusDiv = document.getElementById("json-status");
    statusDiv.innerHTML = '<div class="alert alert-success">Shareable URL copied to clipboard!</div>';
    setTimeout(() => {
      statusDiv.innerHTML = "";
    }, 3e3);
  }).catch(() => {
    prompt("Copy this shareable URL:", shareableUrl);
  });
}
async function tryLoadPipevizJson() {
  try {
    const response = await fetch("pipeviz.json");
    if (response.ok) {
      const configText = await response.text();
      const parsed = JSON.parse(configText);
      document.getElementById("json-input").value = JSON.stringify(parsed, null, 2);
      loadJson();
      const statusDiv = document.getElementById("json-status");
      statusDiv.innerHTML = '<div class="alert alert-success">Loaded pipeviz.json</div>';
      setTimeout(() => {
        statusDiv.innerHTML = "";
      }, 3e3);
      return true;
    }
  } catch (error) {
  }
  return false;
}
async function loadFromUrl() {
  const urlParams = new URLSearchParams(window.location.search);
  const configParam = urlParams.get("config");
  const viewParam = urlParams.get("view");
  if (configParam) {
    try {
      const decodedConfig = atob(configParam);
      const parsed = JSON.parse(decodedConfig);
      document.getElementById("json-input").value = JSON.stringify(parsed, null, 2);
      loadJson();
      const targetView = viewParam || "graph";
      document.getElementById(targetView + "-tab")?.click();
      return;
    } catch (error) {
      console.error("Error decoding config parameter:", error);
    }
  }
  const urlParam = urlParams.get("url");
  const autoView = urlParams.get("view") || (urlParam ? "graph" : null);
  if (urlParam) {
    fetch(urlParam).then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return response.text();
    }).then((configText) => {
      try {
        const parsed = JSON.parse(configText);
        document.getElementById("json-input").value = JSON.stringify(parsed, null, 2);
        loadJson();
        if (autoView) {
          document.getElementById(autoView + "-tab")?.click();
        }
      } catch (error) {
        document.getElementById("json-input").value = configText;
        loadJson();
      }
    }).catch((error) => {
      const statusDiv = document.getElementById("json-status");
      statusDiv.innerHTML = `<div class="alert alert-danger">Error loading from URL: ${error.message}</div>`;
      if (!state.currentConfig) {
        loadExample();
      }
    });
    return;
  }
  const loaded = await tryLoadPipevizJson();
  if (!loaded && !state.currentConfig) {
    loadExample();
  }
}
function setupDragDrop() {
  const dropZone = document.getElementById("drop-zone");
  const textarea = document.getElementById("json-input");
  ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
    dropZone.addEventListener(eventName, preventDefaults, false);
  });
  function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
  }
  ["dragenter", "dragover"].forEach((eventName) => {
    dropZone.addEventListener(eventName, () => dropZone.classList.add("dragover"), false);
  });
  ["dragleave", "drop"].forEach((eventName) => {
    dropZone.addEventListener(eventName, () => dropZone.classList.remove("dragover"), false);
  });
  dropZone.addEventListener("drop", handleDrop, false);
  function handleDrop(e) {
    const files = e.dataTransfer.files;
    if (files.length > 0) {
      const file = files[0];
      if (file.type === "application/json" || file.name.endsWith(".json")) {
        const reader = new FileReader();
        reader.onload = function(e2) {
          try {
            const parsed = JSON.parse(e2.target.result);
            textarea.value = JSON.stringify(parsed, null, 2);
            loadJson();
          } catch (error) {
            textarea.value = e2.target.result;
            loadJson();
          }
        };
        reader.readAsText(file);
      } else {
        const statusDiv = document.getElementById("json-status");
        statusDiv.innerHTML = '<div class="alert alert-warning">Please drop a JSON file</div>';
      }
    }
  }
}
function loadFromFile(event) {
  const file = event.target.files[0];
  if (file && (file.type === "application/json" || file.name.endsWith(".json"))) {
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const parsed = JSON.parse(e.target.result);
        document.getElementById("json-input").value = JSON.stringify(parsed, null, 2);
        loadJson();
      } catch (error) {
        document.getElementById("json-input").value = e.target.result;
        loadJson();
      }
    };
    reader.readAsText(file);
  } else {
    const statusDiv = document.getElementById("json-status");
    statusDiv.innerHTML = '<div class="alert alert-warning">Please select a valid JSON file</div>';
  }
}
function setupAutoProcess() {
  const textarea = document.getElementById("json-input");
  const statusDiv = document.getElementById("json-status");
  let timeout;
  textarea.addEventListener("input", function() {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      const content = textarea.value.trim();
      if (!content) {
        statusDiv.innerHTML = "";
        return;
      }
      try {
        JSON.parse(content);
        statusDiv.innerHTML = '<div class="alert alert-success py-1 px-2" style="font-size: 0.85em;">Valid JSON</div>';
        loadJson();
      } catch (e) {
        statusDiv.innerHTML = `<div class="alert alert-danger py-1 px-2" style="font-size: 0.85em;">Invalid JSON: ${e.message}</div>`;
      }
    }, 500);
  });
}
function loadJson() {
  const jsonText = document.getElementById("json-input").value.trim();
  const statusDiv = document.getElementById("json-status");
  if (!jsonText) {
    statusDiv.innerHTML = '<div class="alert alert-warning">Please enter JSON configuration</div>';
    return;
  }
  try {
    state.currentConfig = JSON.parse(jsonText);
    clearViewStateCache();
    statusDiv.innerHTML = '<div class="alert alert-success">Configuration loaded successfully!</div>';
    renderPipelines();
    renderDatasources();
    updateFilters();
    renderGraph();
    updateDotView();
    updateExportView();
    populateBackfillSelect();
    renderStats();
  } catch (error) {
    statusDiv.innerHTML = `<div class="alert alert-danger">JSON Parse Error: ${error.message}</div>`;
  }
}
window.toggleTheme = toggleTheme;
window.loadExample = loadExample;
window.loadFromFile = loadFromFile;
window.generateShareableUrl = generateShareableUrl;
window.filterPipelines = filterPipelines;
window.filterDatasources = filterDatasources;
window.clearSelection = clearSelection;
window.resetGraph = resetGraph;
window.collapseAllGroups = collapseAllGroups;
window.toggleCollapseAll = toggleCollapseAll;
window.toggleGroup = toggleGroup;
window.togglePipelinesOnly = togglePipelinesOnly;
window.setAnalysisMode = setAnalysisMode;
window.toggleAnalysisMode = toggleAnalysisMode;
window.toggleCostLabels = toggleCostLabels;
window.searchNodes = searchNodes;
window.selectSearchResult = selectSearchResult;
window.showBlastRadius = showBlastRadius;
window.clearAttributeSelection = clearAttributeSelection;
window.resetAttributeGraph = resetAttributeGraph;
window.searchAttributes = searchAttributes;
window.selectAttributeFromSearch = selectAttributeFromSearch;
window.updateDotView = updateDotView;
window.copyDotToClipboard = copyDotToClipboard;
window.updateExportView = updateExportView;
window.copyExportToClipboard = copyExportToClipboard;
window.setExportFormat = setExportFormat;
window.populateBackfillSelect = populateBackfillSelect;
window.updateBackfillPlan = updateBackfillPlan;
window.copyBackfillToClipboard = copyBackfillToClipboard;
window.setBackfillView = setBackfillView;
window.toggleBackfillPicker = toggleBackfillPicker;
window.clearBackfillSelection = clearBackfillSelection;
window.filterBackfillPipelines = filterBackfillPipelines;
document.addEventListener("DOMContentLoaded", () => {
  initTheme();
  setupTabs();
  activateTabFromHash();
  document.getElementById("stats-tab")?.addEventListener("shown.bs.tab", renderStats);
});
window.addEventListener("load", () => {
  setupDragDrop();
  setupAutoProcess();
  loadFromUrl();
  renderSplashGraph();
});
window.addEventListener("hashchange", activateTabFromHash);</script>
    </head>
    <body>
        <div class="container-fluid py-4">
            <div class="hero-section">
                <div class="mb-4 text-center position-relative">
                    <div class="header-controls">
                        <a
                            href="https://github.com/mattlianje/pipeviz"
                            target="_blank"
                            style="color: var(--text-muted); font-size: 13px; text-decoration: none"
                            title="GitHub"
                            >github</a
                        >
                        <button class="theme-toggle" onclick="toggleTheme()" title="Toggle dark mode" id="theme-toggle">
                            
                        </button>
                    </div>
                    <h1 class="hero-title">
                        <img
                            src="https://raw.githubusercontent.com/mattlianje/d4/master/pix/pipeviz.png"
                            alt="Pipeviz logo"
                            style="height: 1.2em; vertical-align: middle; margin-right: 0.25rem"
                        />
                        Pipeviz
                    </h1>
                    <p class="lead">Easy, elegant lineage from a single <span style="color: #d63384">.json</span></p>
                </div>

                <ul class="nav nav-tabs hidden-on-home" id="dashboardTabs">
                    <!-- Start -->
                    <li class="nav-item">
                        <button
                            class="nav-link active"
                            id="home-tab"
                            data-bs-toggle="tab"
                            data-bs-target="#home-pane"
                            title="Welcome &amp; quick start"
                        >
                            Home
                        </button>
                    </li>
                    <li class="nav-item">
                        <button
                            class="nav-link"
                            id="config-tab"
                            data-bs-toggle="tab"
                            data-bs-target="#config-pane"
                            title="View and edit your JSON config"
                        >
                            Config
                        </button>
                    </li>
                    <li class="nav-item nav-separator"></li>
                    <!-- Visualize -->
                    <li class="nav-item">
                        <button
                            class="nav-link"
                            id="graph-tab"
                            data-bs-toggle="tab"
                            data-bs-target="#graph-pane"
                            title="Pipeline dependency graph"
                        >
                            Graph
                        </button>
                    </li>
                    <li class="nav-item">
                        <button
                            class="nav-link"
                            id="attributes-tab"
                            data-bs-toggle="tab"
                            data-bs-target="#attributes-pane"
                            title="Column-level lineage"
                        >
                            Attributes
                        </button>
                    </li>
                    <li class="nav-item nav-separator"></li>
                    <!-- Browse -->
                    <li class="nav-item">
                        <button
                            class="nav-link"
                            id="pipelines-tab"
                            data-bs-toggle="tab"
                            data-bs-target="#pipelines-pane"
                            title="Browse all pipelines"
                        >
                            Pipelines
                        </button>
                    </li>
                    <li class="nav-item">
                        <button
                            class="nav-link"
                            id="datasources-tab"
                            data-bs-toggle="tab"
                            data-bs-target="#datasources-pane"
                            title="Browse all datasources"
                        >
                            Datasources
                        </button>
                    </li>
                    <li class="nav-item nav-separator"></li>
                    <!-- Tools -->
                    <li class="nav-item">
                        <button
                            class="nav-link"
                            id="export-tab"
                            data-bs-toggle="tab"
                            data-bs-target="#export-pane"
                            title="Export as JSON, Mermaid, or DOT"
                        >
                            Export
                        </button>
                    </li>
                    <li class="nav-item">
                        <button
                            class="nav-link"
                            id="backfill-tab"
                            data-bs-toggle="tab"
                            data-bs-target="#backfill-pane"
                            title="Plan downstream execution order"
                        >
                            Planner
                        </button>
                    </li>
                    <li class="nav-item">
                        <button
                            class="nav-link"
                            id="stats-tab"
                            data-bs-toggle="tab"
                            data-bs-target="#stats-pane"
                            title="Pipeline statistics and health"
                        >
                            Stats
                        </button>
                    </li>
                    <li class="nav-item">
                        <button
                            class="nav-link"
                            id="merge-tab"
                            data-bs-toggle="tab"
                            data-bs-target="#merge-pane"
                            title="Merge configs with jq"
                        >
                            Merge
                        </button>
                    </li>
                    <li class="nav-item nav-separator"></li>
                    <!-- Reference -->
                    <li class="nav-item">
                        <button
                            class="nav-link"
                            id="spec-tab"
                            data-bs-toggle="tab"
                            data-bs-target="#spec-pane"
                            title="JSON specification reference"
                        >
                            Spec
                        </button>
                    </li>
                </ul>

                <div class="tab-content">
                    <!-- Home Tab -->
                    <div class="tab-pane fade show active" id="home-pane">
                        <div style="max-width: 750px; margin: 0 auto; padding: 2rem 1rem">
                            <!-- Intro -->
                            <p
                                style="
                                    font-size: 14px;
                                    color: var(--text-secondary);
                                    line-height: 1.7;
                                    margin-bottom: 1.5rem;
                                "
                            >
                                An open source JSON spec for lineage. Declare your pipelines, get beautiful graphs.
                            </p>

                            <!-- Demo -->
                            <div
                                style="
                                    display: flex;
                                    gap: 1.5rem;
                                    align-items: center;
                                    justify-content: center;
                                    flex-wrap: wrap;
                                    margin-bottom: 2rem;
                                "
                            >
                                <pre
                                    class="hero-animate hero-animate-1"
                                    style="padding: 1rem; font-size: 13px; margin: 0; color: var(--text-primary)"
                                >
{
  "pipelines": [{
    "name": "etl-job",
    "input_sources": ["raw_events"],
    "output_sources": ["cleaned_events"]
  }]
}</pre
                                >
                                <svg
                                    class="hero-animate hero-animate-2"
                                    width="24"
                                    height="24"
                                    viewBox="0 0 24 24"
                                    fill="none"
                                    stroke="currentColor"
                                    stroke-width="1.5"
                                    style="color: var(--text-muted); flex-shrink: 0"
                                >
                                    <path d="M5 12h14M13 5l7 7-7 7" />
                                </svg>
                                <div
                                    id="splash-graph"
                                    class="hero-animate hero-animate-3"
                                    style="
                                        min-width: 240px;
                                        min-height: 120px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                    "
                                ></div>
                            </div>

                            <!-- Buttons -->
                            <div
                                class="hero-animate hero-animate-4"
                                style="display: flex; gap: 0.75rem; justify-content: center; margin-bottom: 2.5rem"
                            >
                                <button
                                    class="btn btn-dark"
                                    onclick="
                                        loadExample()
                                        document.getElementById('graph-tab').click()
                                    "
                                >
                                    Try demo
                                </button>
                                <button
                                    class="btn btn-outline-secondary"
                                    onclick="document.getElementById('spec-tab').click()"
                                >
                                    Read spec
                                </button>
                            </div>

                            <!-- Feature tiles -->
                            <div class="feature-grid" style="margin-bottom: 2rem">
                                <div class="feature-tile">
                                    <svg
                                        width="16"
                                        height="16"
                                        viewBox="0 0 24 24"
                                        fill="none"
                                        stroke="currentColor"
                                        stroke-width="1.5"
                                        class="feature-icon"
                                    >
                                        <rect x="4" y="4" width="6" height="6" rx="1" />
                                        <rect x="14" y="4" width="6" height="6" rx="1" />
                                        <rect x="4" y="14" width="6" height="6" rx="1" />
                                        <rect x="14" y="14" width="6" height="6" rx="1" />
                                    </svg>
                                    <div
                                        style="
                                            font-size: 12px;
                                            color: var(--text-primary);
                                            font-weight: 600;
                                            margin-bottom: 0.2rem;
                                        "
                                    >
                                        Stack Agnostic
                                    </div>
                                    <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4">
                                        SQL, Spark, Kafka, APIs, shell scripts. Just JSON.
                                    </div>
                                </div>
                                <div class="feature-tile">
                                    <svg
                                        width="16"
                                        height="16"
                                        viewBox="0 0 24 24"
                                        fill="none"
                                        stroke="currentColor"
                                        stroke-width="1.5"
                                        class="feature-icon"
                                    >
                                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                                        <polyline points="14 2 14 8 20 8" />
                                    </svg>
                                    <div
                                        style="
                                            font-size: 12px;
                                            color: var(--text-primary);
                                            font-weight: 600;
                                            margin-bottom: 0.2rem;
                                        "
                                    >
                                        Zero Dependencies
                                    </div>
                                    <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4">
                                        One HTML file. No backend, no build step. Host anywhere.
                                    </div>
                                </div>
                                <div class="feature-tile">
                                    <svg
                                        width="16"
                                        height="16"
                                        viewBox="0 0 24 24"
                                        fill="none"
                                        stroke="currentColor"
                                        stroke-width="1.5"
                                        class="feature-icon"
                                    >
                                        <circle cx="6" cy="6" r="3" />
                                        <circle cx="18" cy="6" r="3" />
                                        <circle cx="6" cy="18" r="3" />
                                        <circle cx="18" cy="18" r="3" />
                                        <path d="M6 9v6m12-6v6M9 6h6m-6 12h6" />
                                    </svg>
                                    <div
                                        style="
                                            font-size: 12px;
                                            color: var(--text-primary);
                                            font-weight: 600;
                                            margin-bottom: 0.2rem;
                                        "
                                    >
                                        Federated
                                    </div>
                                    <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4">
                                        Each team owns their JSON. Merge with jq for the org-wide view.
                                    </div>
                                </div>
                                <div class="feature-tile">
                                    <svg
                                        width="16"
                                        height="16"
                                        viewBox="0 0 24 24"
                                        fill="none"
                                        stroke="currentColor"
                                        stroke-width="1.5"
                                        class="feature-icon"
                                    >
                                        <path d="M3 6h18M3 12h18M3 18h18" />
                                        <circle cx="7" cy="6" r="1.5" fill="currentColor" />
                                        <circle cx="14" cy="12" r="1.5" fill="currentColor" />
                                        <circle cx="10" cy="18" r="1.5" fill="currentColor" />
                                    </svg>
                                    <div
                                        style="
                                            font-size: 12px;
                                            color: var(--text-primary);
                                            font-weight: 600;
                                            margin-bottom: 0.2rem;
                                        "
                                    >
                                        Column-Level Lineage
                                    </div>
                                    <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4">
                                        Track field-level provenance. See where each attribute comes from.
                                    </div>
                                </div>
                            </div>

                            <!-- How it works -->
                            <div style="margin-bottom: 2rem">
                                <div
                                    style="
                                        font-size: 12px;
                                        font-weight: 600;
                                        margin-bottom: 0.75rem;
                                        color: var(--text-muted);
                                        text-transform: uppercase;
                                        letter-spacing: 0.5px;
                                    "
                                >
                                    How it works
                                </div>
                                <div
                                    style="display: flex; justify-content: space-between; gap: 1.5rem; flex-wrap: wrap"
                                >
                                    <div style="flex: 1; min-width: 140px; text-align: center">
                                        <div
                                            style="font-size: 1.25rem; color: var(--text-muted); margin-bottom: 0.2rem"
                                        >
                                            1
                                        </div>
                                        <div
                                            style="
                                                font-size: 12px;
                                                font-weight: 600;
                                                color: var(--text-primary);
                                                margin-bottom: 0.2rem;
                                            "
                                        >
                                            Define
                                        </div>
                                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.4">
                                            Write a <code>pipeviz.json</code> describing your pipelines and data sources
                                        </div>
                                    </div>
                                    <div style="flex: 1; min-width: 140px; text-align: center">
                                        <div
                                            style="font-size: 1.25rem; color: var(--text-muted); margin-bottom: 0.2rem"
                                        >
                                            2
                                        </div>
                                        <div
                                            style="
                                                font-size: 12px;
                                                font-weight: 600;
                                                color: var(--text-primary);
                                                margin-bottom: 0.2rem;
                                            "
                                        >
                                            Load
                                        </div>
                                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.4">
                                            Drop your file here, or host both files together on any static server
                                        </div>
                                    </div>
                                    <div style="flex: 1; min-width: 140px; text-align: center">
                                        <div
                                            style="font-size: 1.25rem; color: var(--text-muted); margin-bottom: 0.2rem"
                                        >
                                            3
                                        </div>
                                        <div
                                            style="
                                                font-size: 12px;
                                                font-weight: 600;
                                                color: var(--text-primary);
                                                margin-bottom: 0.2rem;
                                            "
                                        >
                                            Explore
                                        </div>
                                        <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.4">
                                            Click through the graph, trace dependencies, export DOT for other tools
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Superpowers -->
                            <div style="margin-bottom: 2rem">
                                <div
                                    style="
                                        font-size: 12px;
                                        font-weight: 600;
                                        margin-bottom: 0.5rem;
                                        color: var(--text-muted);
                                        text-transform: uppercase;
                                        letter-spacing: 0.5px;
                                    "
                                >
                                    Superpowers
                                </div>
                                <p
                                    style="
                                        font-size: 13px;
                                        color: var(--text-secondary);
                                        line-height: 1.5;
                                        margin: 0 0 1rem 0;
                                    "
                                >
                                    Each pipeline declares what it reads and writes. Pipeviz stitches these into a
                                    complete graph. From there:
                                </p>
                                <div class="superpowers-grid">
                                    <div style="display: flex; gap: 0.5rem; align-items: flex-start">
                                        <svg
                                            width="16"
                                            height="16"
                                            viewBox="0 0 24 24"
                                            fill="none"
                                            stroke="currentColor"
                                            stroke-width="1.5"
                                            style="flex-shrink: 0; margin-top: 2px"
                                        >
                                            <path d="M4 6h4M4 12h6M4 18h8" />
                                            <path d="M14 6h6M12 12h8M10 18h10" />
                                        </svg>
                                        <span
                                            ><strong style="color: var(--text-primary)">Parallelize backfills</strong>
                                            by topologically sorting nodes into stages. Independent pipelines run
                                            together.</span
                                        >
                                    </div>
                                    <div style="display: flex; gap: 0.5rem; align-items: flex-start">
                                        <svg
                                            width="16"
                                            height="16"
                                            viewBox="0 0 24 24"
                                            fill="none"
                                            stroke="currentColor"
                                            stroke-width="1.5"
                                            style="flex-shrink: 0; margin-top: 2px"
                                        >
                                            <circle cx="12" cy="12" r="9" />
                                            <path d="M12 8v4l2 2" />
                                        </svg>
                                        <span
                                            ><strong style="color: var(--text-primary)"
                                                >Detect circular dependencies</strong
                                            >
                                            before they break your backfill. Cycles shown in red.</span
                                        >
                                    </div>
                                    <div style="display: flex; gap: 0.5rem; align-items: flex-start">
                                        <svg
                                            width="16"
                                            height="16"
                                            viewBox="0 0 24 24"
                                            fill="none"
                                            stroke="currentColor"
                                            stroke-width="1.5"
                                            style="flex-shrink: 0; margin-top: 2px"
                                        >
                                            <path d="M12 2l8 10-8 10-8-10z" />
                                        </svg>
                                        <span
                                            ><strong style="color: var(--text-primary)"
                                                >Handle diamond dependencies</strong
                                            >
                                            correctly. Each node runs only after all its parents complete.</span
                                        >
                                    </div>
                                    <div style="display: flex; gap: 0.5rem; align-items: flex-start">
                                        <svg
                                            width="16"
                                            height="16"
                                            viewBox="0 0 24 24"
                                            fill="none"
                                            stroke="currentColor"
                                            stroke-width="1.5"
                                            style="flex-shrink: 0; margin-top: 2px"
                                        >
                                            <circle cx="12" cy="12" r="10" />
                                            <circle cx="12" cy="12" r="4" />
                                        </svg>
                                        <span
                                            ><strong style="color: var(--text-primary)">Trace blast radius</strong>
                                            downstream from any node. Know exactly what breaks.</span
                                        >
                                    </div>
                                    <div style="display: flex; gap: 0.5rem; align-items: flex-start">
                                        <svg
                                            width="16"
                                            height="16"
                                            viewBox="0 0 24 24"
                                            fill="none"
                                            stroke="currentColor"
                                            stroke-width="1.5"
                                            style="flex-shrink: 0; margin-top: 2px"
                                        >
                                            <path d="M4 17l6-6-6-6" />
                                            <path d="M12 19h8" />
                                        </svg>
                                        <span
                                            ><strong style="color: var(--text-primary)">Export to Mermaid</strong> and
                                            embed diagrams in CI/CD, PRs, or docs.</span
                                        >
                                    </div>
                                    <div style="display: flex; gap: 0.5rem; align-items: flex-start">
                                        <svg
                                            width="16"
                                            height="16"
                                            viewBox="0 0 24 24"
                                            fill="none"
                                            stroke="currentColor"
                                            stroke-width="1.5"
                                            style="flex-shrink: 0; margin-top: 2px"
                                        >
                                            <rect x="4" y="4" width="16" height="16" rx="2" />
                                            <path d="M9 9h6M9 12h6M9 15h4" />
                                        </svg>
                                        <span
                                            ><strong style="color: var(--text-primary)">Build MCPs</strong> on top of
                                            your graph. LLMs can query your lineage.</span
                                        >
                                    </div>
                                    <div style="display: flex; gap: 0.5rem; align-items: flex-start">
                                        <svg
                                            width="16"
                                            height="16"
                                            viewBox="0 0 24 24"
                                            fill="none"
                                            stroke="currentColor"
                                            stroke-width="1.5"
                                            style="flex-shrink: 0; margin-top: 2px"
                                        >
                                            <path d="M3 12h4l3-9 4 18 3-9h4" />
                                        </svg>
                                        <span
                                            ><strong style="color: var(--text-primary)">Find critical path</strong> via
                                            PERT analysis. Know your pipeline's true bottleneck.</span
                                        >
                                    </div>
                                    <div style="display: flex; gap: 0.5rem; align-items: flex-start">
                                        <svg
                                            width="16"
                                            height="16"
                                            viewBox="0 0 24 24"
                                            fill="none"
                                            stroke="currentColor"
                                            stroke-width="1.5"
                                            style="flex-shrink: 0; margin-top: 2px"
                                        >
                                            <path d="M12 2v20M17 5H9.5a3.5 3.5 0 000 7h5a3.5 3.5 0 010 7H6" />
                                        </svg>
                                        <span
                                            ><strong style="color: var(--text-primary)">Track spend</strong> per node
                                            and path. See where your compute budget goes.</span
                                        >
                                    </div>
                                </div>
                            </div>

                            <!-- Merging configs -->
                            <div style="margin-bottom: 2rem">
                                <div
                                    style="
                                        font-size: 12px;
                                        font-weight: 600;
                                        margin-bottom: 0.5rem;
                                        color: var(--text-muted);
                                        text-transform: uppercase;
                                        letter-spacing: 0.5px;
                                    "
                                >
                                    Merging configs
                                </div>
                                <pre
                                    style="
                                        background: var(--bg-code);
                                        padding: 0.75rem;
                                        font-size: 12px;
                                        margin: 0;
                                        overflow-x: auto;
                                        color: var(--text-primary);
                                    "
                                ><span style="color: var(--text-muted);"># each team versions their own pipeviz.json</span>
<span style="color: var(--text-muted);"># merge for org-wide view</span>
jq -s '{
  pipelines: map(.pipelines // []) | add,
  datasources: map(.datasources // []) | add
}' team-*.json > pipeviz.json</pre>
                            </div>

                            <!-- Motivation -->
                            <div style="margin-bottom: 2rem">
                                <div
                                    style="
                                        font-size: 12px;
                                        font-weight: 600;
                                        margin-bottom: 0.5rem;
                                        color: var(--text-muted);
                                        text-transform: uppercase;
                                        letter-spacing: 0.5px;
                                    "
                                >
                                    Why
                                </div>
                                <p style="font-size: 13px; color: var(--text-secondary); line-height: 1.6; margin: 0">
                                    <a
                                        href="https://openlineage.io/"
                                        target="_blank"
                                        style="color: var(--text-secondary)"
                                        >OpenLineage</a
                                    >/<a
                                        href="https://marquezproject.ai/"
                                        target="_blank"
                                        style="color: var(--text-secondary)"
                                        >Marquez</a
                                    >
                                    need agents, a metadata store, scheduler integration.
                                    <a
                                        href="https://atlas.apache.org/"
                                        target="_blank"
                                        style="color: var(--text-secondary)"
                                        >Atlas</a
                                    >
                                    wants a governance platform.
                                    <a
                                        href="https://www.getdbt.com/"
                                        target="_blank"
                                        style="color: var(--text-secondary)"
                                        >dbt</a
                                    >
                                    couples you to their framework. Pipeviz needs one JSON file.
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Configuration Tab -->
                    <div class="tab-pane fade" id="config-pane">
                        <div style="max-width: 900px; padding: 1rem 0">
                            <div class="drop-zone" id="drop-zone">
                                <textarea
                                    class="form-control json-editor"
                                    id="json-input"
                                    rows="22"
                                    placeholder="Paste JSON here or drag & drop a file"
                                ></textarea>
                            </div>
                            <div
                                style="
                                    display: flex;
                                    gap: 0.5rem;
                                    align-items: center;
                                    flex-wrap: wrap;
                                    margin-top: 0.75rem;
                                "
                            >
                                <input
                                    type="file"
                                    id="file-input"
                                    accept=".json"
                                    style="display: none"
                                    onchange="loadFromFile(event)"
                                />
                                <button class="graph-ctrl-btn" onclick="document.getElementById('file-input').click()">
                                    Browse
                                </button>
                                <button class="graph-ctrl-btn" onclick="loadExample()">Load Example</button>
                                <button class="graph-ctrl-btn" onclick="generateShareableUrl()">Share URL</button>
                                <span style="color: var(--text-muted); font-size: 12px; margin-left: auto"
                                    >Auto-load: <code style="font-size: 11px">?url=your-json-url</code></span
                                >
                            </div>
                            <div id="json-status" style="margin-top: 0.5rem"></div>
                        </div>
                    </div>

                    <!-- Pipelines Tab -->
                    <div class="tab-pane fade" id="pipelines-pane">
                        <div class="card">
                            <div class="card-body">
                                <div class="mb-3">
                                    <input
                                        type="text"
                                        class="form-control"
                                        id="pipeline-search"
                                        placeholder="Search pipelines..."
                                        onkeyup="filterPipelines()"
                                        style="max-width: 300px"
                                    />
                                </div>
                                <div class="mb-3" id="pipeline-filters"></div>
                                <div id="pipelines-table-container">
                                    <p class="text-muted text-center">Load a configuration to see your pipelines</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Data Sources Tab -->
                    <div class="tab-pane fade" id="datasources-pane">
                        <div class="card">
                            <div class="card-body">
                                <div class="mb-3">
                                    <input
                                        type="text"
                                        class="form-control"
                                        id="datasource-search"
                                        placeholder="Search data sources..."
                                        onkeyup="filterDatasources()"
                                        style="max-width: 300px"
                                    />
                                </div>
                                <div class="mb-3" id="datasource-filters"></div>
                                <div id="datasources-table-container">
                                    <p class="text-muted text-center">Load a configuration to see your data sources</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Graph Tab -->
                    <div class="tab-pane fade" id="graph-pane">
                        <div class="card">
                            <div class="card-body">
                                <div class="row mb-3">
                                    <div class="col-md-4">
                                        <div class="position-relative">
                                            <input
                                                type="text"
                                                class="form-control"
                                                id="graph-search"
                                                placeholder="Search nodes..."
                                                onkeydown="searchNodes(event)"
                                            />
                                            <div id="graph-search-results" class="search-results-dropdown"></div>
                                        </div>
                                    </div>
                                </div>
                                <div class="row">
                                    <div id="graph-col" class="col-md-12">
                                        <div class="graph-container position-relative">
                                            <div class="graph-controls">
                                                <button
                                                    class="graph-ctrl-btn"
                                                    onclick="togglePipelinesOnly()"
                                                    id="pipelines-only-btn"
                                                >
                                                    Pipelines Only
                                                </button>
                                                <button
                                                    class="graph-ctrl-btn active"
                                                    onclick="toggleCollapseAll()"
                                                    id="collapse-all-btn"
                                                >
                                                    Expand All
                                                </button>
                                                <button class="graph-ctrl-btn" onclick="clearSelection()">Clear</button>
                                                <button class="graph-ctrl-btn" onclick="resetGraph()">Reset</button>
                                                <div class="analysis-toggle ms-auto">
                                                    <input
                                                        type="checkbox"
                                                        id="cp-toggle"
                                                        onchange="toggleAnalysisMode('critical-path', this)"
                                                    />
                                                    <label for="cp-toggle"
                                                        ><span class="cp-indicator"></span>Critical Path</label
                                                    >
                                                    <input
                                                        type="checkbox"
                                                        id="cost-toggle"
                                                        onchange="toggleCostLabels(this.checked)"
                                                    />
                                                    <label for="cost-toggle"
                                                        ><span class="cost-indicator"></span>Show Costs</label
                                                    >
                                                </div>
                                            </div>
                                            <div id="graph">
                                                <div class="graph-loading text-center py-5 text-muted">
                                                    <div
                                                        class="spinner-border spinner-border-sm me-2"
                                                        role="status"
                                                    ></div>
                                                    Loading graph...
                                                </div>
                                            </div>
                                            <div class="legend">
                                                <div><strong>Legend:</strong></div>
                                                <div> = Pipeline</div>
                                                <div style="color: #00897b"> = Group</div>
                                                <div> = Data Source</div>
                                                <div> = Cluster</div>
                                                <div> = Data flow</div>
                                                <div style="color: #ff6b35"> = Dependency</div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-md-4" id="node-details-col" style="display: none">
                                        <div class="node-details-panel" id="node-details-panel">
                                            <div id="node-details-content"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Attributes Tab -->
                    <div class="tab-pane fade" id="attributes-pane">
                        <div class="card">
                            <div class="card-body">
                                <div class="row mb-3">
                                    <div class="col-md-4">
                                        <div class="position-relative">
                                            <input
                                                type="text"
                                                class="form-control"
                                                id="attribute-search"
                                                placeholder="Search attributes..."
                                                onkeydown="searchAttributes(event)"
                                            />
                                            <div id="attribute-search-results" class="search-results-dropdown"></div>
                                        </div>
                                    </div>
                                </div>
                                <div class="row">
                                    <div id="attribute-graph-col" class="col-md-12">
                                        <div class="graph-container position-relative">
                                            <div class="graph-controls">
                                                <button class="graph-ctrl-btn" onclick="clearAttributeSelection()">
                                                    Clear
                                                </button>
                                                <button class="graph-ctrl-btn" onclick="resetAttributeGraph()">
                                                    Reset
                                                </button>
                                            </div>
                                            <div id="attribute-graph">
                                                <div class="graph-loading text-center py-5 text-muted">
                                                    <div
                                                        class="spinner-border spinner-border-sm me-2"
                                                        role="status"
                                                    ></div>
                                                    Loading graph...
                                                </div>
                                            </div>
                                            <div class="legend">
                                                <div><strong>Legend:</strong></div>
                                                <div> = Data Source</div>
                                                <div> = Attribute</div>
                                                <div> = Derived from</div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-md-4" id="attribute-details-col" style="display: none">
                                        <div class="node-details-panel" id="attribute-details-panel">
                                            <div id="attribute-details-content"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Export Tab -->
                    <div class="tab-pane fade" id="export-pane">
                        <div class="card">
                            <div class="card-body">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h5 class="mb-0">Export</h5>
                                    <div class="format-toggle">
                                        <button
                                            class="graph-ctrl-btn export-format-btn active"
                                            data-format="json"
                                            onclick="setExportFormat('json')"
                                        >
                                            JSON
                                        </button>
                                        <button
                                            class="graph-ctrl-btn export-format-btn"
                                            data-format="mermaid"
                                            onclick="setExportFormat('mermaid')"
                                        >
                                            Mermaid
                                        </button>
                                        <button
                                            class="graph-ctrl-btn export-format-btn"
                                            data-format="dot"
                                            onclick="setExportFormat('dot')"
                                        >
                                            DOT
                                        </button>
                                    </div>
                                </div>
                                <div class="export-output-container">
                                    <button
                                        class="export-copy-btn"
                                        onclick="copyExportToClipboard(event)"
                                        title="Copy to clipboard"
                                    >
                                        <svg
                                            width="14"
                                            height="14"
                                            viewBox="0 0 24 24"
                                            fill="none"
                                            stroke="currentColor"
                                            stroke-width="2"
                                        >
                                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                        </svg>
                                    </button>
                                    <pre class="export-output" id="export-output">
Load a configuration to see the graph export...</pre
                                    >
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Backfill Tab -->
                    <div class="tab-pane fade" id="backfill-pane">
                        <div class="card">
                            <div class="card-body">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h5 class="mb-0">Planner</h5>
                                    <div class="d-flex align-items-center gap-3">
                                        <div class="btn-group btn-group-sm backfill-pipeline-picker">
                                            <div class="backfill-picker-dropdown" id="backfill-picker-dropdown">
                                                <div class="backfill-picker-search">
                                                    <input
                                                        type="text"
                                                        id="backfill-picker-filter"
                                                        placeholder="Filter pipelines..."
                                                        oninput="filterBackfillPipelines(this.value)"
                                                    />
                                                </div>
                                                <div class="backfill-picker-list" id="backfill-picker-list"></div>
                                                <div class="backfill-picker-footer">
                                                    <span id="backfill-picker-count">0 selected</span>
                                                    <button
                                                        class="backfill-picker-clear"
                                                        onclick="clearBackfillSelection()"
                                                    >
                                                        Clear all
                                                    </button>
                                                </div>
                                            </div>
                                            <button
                                                class="graph-ctrl-btn backfill-view-btn active"
                                                data-view="pipeline"
                                                onclick="setBackfillView('pipeline')"
                                            >
                                                Run Order
                                            </button>
                                            <button
                                                class="graph-ctrl-btn backfill-view-btn"
                                                data-view="airflow"
                                                onclick="setBackfillView('airflow')"
                                            >
                                                Airflow DAGs
                                            </button>
                                            <button
                                                class="graph-ctrl-btn backfill-view-btn danger"
                                                data-view="blast"
                                                onclick="setBackfillView('blast')"
                                            >
                                                Blast Radius
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                <div id="backfill-hint" class="backfill-hint">
                                    Select pipelines to plan backfill execution order
                                </div>
                                <div class="row">
                                    <div class="col-md-7">
                                        <div class="backfill-graph-container">
                                            <div id="backfill-graph" class="backfill-graph">
                                                <div
                                                    style="
                                                        color: var(--text-muted);
                                                        font-size: 12px;
                                                        padding: 2rem;
                                                        text-align: center;
                                                    "
                                                >
                                                    Select pipelines to see the execution plan
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-md-5">
                                        <div class="export-output-container">
                                            <button
                                                class="export-copy-btn"
                                                onclick="copyBackfillToClipboard(event)"
                                                title="Copy to clipboard"
                                            >
                                                <svg
                                                    width="14"
                                                    height="14"
                                                    viewBox="0 0 24 24"
                                                    fill="none"
                                                    stroke="currentColor"
                                                    stroke-width="2"
                                                >
                                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                                    <path
                                                        d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"
                                                    ></path>
                                                </svg>
                                            </button>
                                            <pre class="export-output" id="backfill-output" style="height: 450px">
Select a pipeline to see the backfill plan...</pre
                                            >
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Stats Tab -->
                    <div class="tab-pane fade" id="stats-pane">
                        <div class="card">
                            <div class="card-body">
                                <div id="stats-content">
                                    <div class="text-muted">Load a configuration to see statistics.</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Merge Tab -->
                    <div class="tab-pane fade" id="merge-pane">
                        <div style="max-width: 800px; padding: 1rem 0">
                            <h5 style="margin-bottom: 1rem">Merging Pipeviz Configs</h5>
                            <p
                                style="
                                    font-size: 13px;
                                    color: var(--text-secondary);
                                    line-height: 1.6;
                                    margin-bottom: 1.5rem;
                                "
                            >
                                When your data platform spans multiple teams or repositories, you can maintain separate
                                config files and merge them into a single Pipeviz config using <code>jq</code>.
                            </p>

                            <div class="merge-section">
                                <h6>Basic Merge (Two Files)</h6>
                                <p>Combine pipelines and datasources from two config files:</p>
                                <pre class="merge-code"><code>jq -s '{
  pipelines: (.[0].pipelines + .[1].pipelines),
  datasources: (.[0].datasources + .[1].datasources)
}' team_a.json team_b.json > combined.json</code></pre>
                            </div>

                            <div class="merge-section">
                                <h6>Merge Multiple Files</h6>
                                <p>Merge all <code>*.pipeviz.json</code> files in a directory:</p>
                                <pre class="merge-code"><code>jq -s '{
  pipelines: [.[].pipelines[]] | unique_by(.name),
  datasources: [.[].datasources[]] | unique_by(.name)
}' configs/*.pipeviz.json > combined.json</code></pre>
                            </div>

                            <div class="merge-section">
                                <h6>Merge with Deduplication</h6>
                                <p>
                                    When configs might have overlapping definitions, dedupe by name (last write wins):
                                </p>
                                <pre class="merge-code"><code>jq -s '{
  pipelines: (
    [.[].pipelines[]] | group_by(.name) | map(last)
  ),
  datasources: (
    [.[].datasources[]] | group_by(.name) | map(last)
  )
}' *.json > merged.json</code></pre>
                            </div>

                            <div class="merge-section">
                                <h6>Smart Prefix (Only on Collision)</h6>
                                <p>Only add prefixes when names actually collide:</p>
                                <pre class="merge-code"><code># Find colliding names, prefix only those
jq -s '
  # Collect all pipelines with their source file
  [
    (.[0].pipelines | map(. + {_src: "a"})),
    (.[1].pipelines | map(. + {_src: "b"}))
  ] | add
  # Group by name to find collisions
  | group_by(.name)
  | map(
      if length > 1 then
        # Collision: prefix each with source
        map(.name = ._src + "_" + .name)
      else . end
    )
  | add
  | map(del(._src))
' team_a.json team_b.json

# Full merge with collision handling
jq -s '
  def smart_merge(key):
    group_by(.[key]) | map(
      if length > 1 then 
        to_entries | map(.value[key] = "src\(.key)_" + .value[key]) | map(.value)
      else . end
    ) | add;
  {
    pipelines: ([.[].pipelines[]] | smart_merge("name")),
    datasources: ([.[].datasources[]] | smart_merge("name"))
  }
' *.json > merged.json</code></pre>
                            </div>

                            <style>
                                .merge-section {
                                    margin-bottom: 1.5rem;
                                }
                                .merge-section h6 {
                                    font-size: 13px;
                                    font-weight: 600;
                                    margin-bottom: 0.5rem;
                                    color: var(--text-primary);
                                }
                                .merge-section p {
                                    font-size: 12px;
                                    color: var(--text-secondary);
                                    margin-bottom: 0.5rem;
                                }
                                .merge-code {
                                    background: var(--bg-secondary);
                                    border: 1px solid var(--border-color);
                                    border-radius: 4px;
                                    padding: 12px 14px;
                                    font-size: 11px;
                                    line-height: 1.5;
                                    overflow-x: auto;
                                    margin: 0;
                                }
                                .merge-code code {
                                    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
                                    color: var(--text-primary);
                                }
                            </style>
                        </div>
                    </div>

                    <!-- Spec Tab -->
                    <div class="tab-pane fade" id="spec-pane">
                        <div style="max-width: 800px; padding: 1rem 0">
                            <style>
                                .spec-table {
                                    width: 100%;
                                    border-collapse: collapse;
                                    font-size: 12px;
                                    margin: 0.75rem 0 1rem 0;
                                }
                                .spec-table th,
                                .spec-table td {
                                    padding: 6px 10px;
                                    border: 1px solid var(--border-color);
                                    text-align: left;
                                }
                                .spec-table th {
                                    background: var(--bg-secondary);
                                }
                                .spec-section {
                                    margin-bottom: 2rem;
                                }
                                .spec-section h6 {
                                    font-weight: 600;
                                    margin-bottom: 0.5rem;
                                }
                                .spec-pre {
                                    background: var(--bg-code);
                                    border: 1px solid var(--border-color);
                                    padding: 12px;
                                    font-size: 12px;
                                    color: var(--text-primary);
                                    margin: 0;
                                }
                            </style>

                            <div style="margin-bottom: 1.5rem">
                                <h5 style="font-weight: 600; margin-bottom: 0.25rem">Pipeviz JSON Spec</h5>
                                <p style="color: var(--text-secondary); font-size: 13px">
                                    Only <code>pipelines</code> is required. Clusters and datasources are auto-created
                                    when referenced.
                                </p>
                            </div>

                            <div class="spec-section">
                                <h6>Root</h6>
                                <table class="spec-table">
                                    <tr>
                                        <th>Field</th>
                                        <th>Type</th>
                                        <th>Required</th>
                                        <th>Description</th>
                                    </tr>
                                    <tr>
                                        <td><code>pipelines</code></td>
                                        <td>array</td>
                                        <td>Yes</td>
                                        <td>Jobs that transform or move data</td>
                                    </tr>
                                    <tr>
                                        <td><code>datasources</code></td>
                                        <td>array</td>
                                        <td>No</td>
                                        <td>Tables, files, streams, APIs</td>
                                    </tr>
                                    <tr>
                                        <td><code>clusters</code></td>
                                        <td>array</td>
                                        <td>No</td>
                                        <td>Groups for visual organization</td>
                                    </tr>
                                </table>
                                <pre class="spec-pre">
{
  "clusters": [...],
  "pipelines": [...],
  "datasources": [...]
}</pre
                                >
                            </div>

                            <div class="spec-section">
                                <h6>Pipeline</h6>
                                <table class="spec-table">
                                    <tr>
                                        <th>Field</th>
                                        <th>Type</th>
                                        <th>Required</th>
                                        <th>Description</th>
                                    </tr>
                                    <tr>
                                        <td><code>name</code></td>
                                        <td>string</td>
                                        <td>Yes</td>
                                        <td>Unique identifier</td>
                                    </tr>
                                    <tr>
                                        <td><code>description</code></td>
                                        <td>string</td>
                                        <td>No</td>
                                        <td></td>
                                    </tr>
                                    <tr>
                                        <td><code>input_sources</code></td>
                                        <td>array</td>
                                        <td>No</td>
                                        <td>Datasources read from</td>
                                    </tr>
                                    <tr>
                                        <td><code>output_sources</code></td>
                                        <td>array</td>
                                        <td>No</td>
                                        <td>Datasources written to</td>
                                    </tr>
                                    <tr>
                                        <td><code>upstream_pipelines</code></td>
                                        <td>array</td>
                                        <td>No</td>
                                        <td>Pipeline or group names (orange edges)</td>
                                    </tr>
                                    <tr>
                                        <td><code>cluster</code></td>
                                        <td>string</td>
                                        <td>No</td>
                                        <td>Cluster name</td>
                                    </tr>
                                    <tr>
                                        <td><code>group</code></td>
                                        <td>string</td>
                                        <td>No</td>
                                        <td>Collapse into group node</td>
                                    </tr>
                                    <tr>
                                        <td><code>schedule</code></td>
                                        <td>string</td>
                                        <td>No</td>
                                        <td>Free text</td>
                                    </tr>
                                    <tr>
                                        <td><code>tags</code></td>
                                        <td>array</td>
                                        <td>No</td>
                                        <td></td>
                                    </tr>
                                    <tr>
                                        <td><code>links</code></td>
                                        <td>object</td>
                                        <td>No</td>
                                        <td>name to URL</td>
                                    </tr>
                                    <tr>
                                        <td><code>duration</code></td>
                                        <td>number</td>
                                        <td>No</td>
                                        <td>Runtime in minutes (for critical path)</td>
                                    </tr>
                                    <tr>
                                        <td><code>cost</code></td>
                                        <td>number</td>
                                        <td>No</td>
                                        <td>Cost per run (for spend analysis)</td>
                                    </tr>
                                </table>
                                <pre class="spec-pre">
{
  "name": "user-enrichment",
  "description": "Enriches user data with events",
  "input_sources": ["raw_users", "events"],
  "output_sources": ["enriched_users"],
  "upstream_pipelines": ["data-ingestion"],
  "cluster": "user-processing",
  "group": "etl-jobs",
  "schedule": "Every 2 hours",
  "duration": 45,
  "cost": 12.50,
  "tags": ["user-data", "ml"],
  "links": {
    "airflow": "https://...",
    "docs": "https://..."
  }
}</pre
                                >
                            </div>

                            <div class="spec-section">
                                <h6>Datasource</h6>
                                <p style="color: var(--text-secondary); font-size: 12px; margin-bottom: 0.5rem">
                                    Auto-created when referenced. Define explicitly to add metadata.
                                </p>
                                <table class="spec-table">
                                    <tr>
                                        <th>Field</th>
                                        <th>Type</th>
                                        <th>Required</th>
                                        <th>Description</th>
                                    </tr>
                                    <tr>
                                        <td><code>name</code></td>
                                        <td>string</td>
                                        <td>Yes</td>
                                        <td>Unique identifier</td>
                                    </tr>
                                    <tr>
                                        <td><code>description</code></td>
                                        <td>string</td>
                                        <td>No</td>
                                        <td></td>
                                    </tr>
                                    <tr>
                                        <td><code>type</code></td>
                                        <td>string</td>
                                        <td>No</td>
                                        <td>snowflake, postgres, kafka, s3...</td>
                                    </tr>
                                    <tr>
                                        <td><code>owner</code></td>
                                        <td>string</td>
                                        <td>No</td>
                                        <td></td>
                                    </tr>
                                    <tr>
                                        <td><code>cluster</code></td>
                                        <td>string</td>
                                        <td>No</td>
                                        <td></td>
                                    </tr>
                                    <tr>
                                        <td><code>tags</code></td>
                                        <td>array</td>
                                        <td>No</td>
                                        <td></td>
                                    </tr>
                                    <tr>
                                        <td><code>metadata</code></td>
                                        <td>object</td>
                                        <td>No</td>
                                        <td>Arbitrary key-value</td>
                                    </tr>
                                    <tr>
                                        <td><code>links</code></td>
                                        <td>object</td>
                                        <td>No</td>
                                        <td>name to URL</td>
                                    </tr>
                                    <tr>
                                        <td><code>attributes</code></td>
                                        <td>array</td>
                                        <td>No</td>
                                        <td>Column-level lineage</td>
                                    </tr>
                                </table>
                                <pre class="spec-pre">
{
  "name": "raw_users",
  "description": "Raw user data from prod",
  "type": "snowflake",
  "owner": "data-team@company.com",
  "cluster": "user-processing",
  "tags": ["pii", "users"],
  "metadata": {
    "size": "2.1TB",
    "record_count": "45M"
  },
  "links": {
    "snowflake": "https://...",
    "docs": "https://..."
  }
}</pre
                                >
                            </div>

                            <div class="spec-section">
                                <h6>Cluster</h6>
                                <p style="color: var(--text-secondary); font-size: 12px; margin-bottom: 0.5rem">
                                    Auto-created when referenced. Define explicitly for nesting.
                                </p>
                                <table class="spec-table">
                                    <tr>
                                        <th>Field</th>
                                        <th>Type</th>
                                        <th>Required</th>
                                        <th>Description</th>
                                    </tr>
                                    <tr>
                                        <td><code>name</code></td>
                                        <td>string</td>
                                        <td>Yes</td>
                                        <td>Unique identifier</td>
                                    </tr>
                                    <tr>
                                        <td><code>description</code></td>
                                        <td>string</td>
                                        <td>No</td>
                                        <td></td>
                                    </tr>
                                    <tr>
                                        <td><code>parent</code></td>
                                        <td>string</td>
                                        <td>No</td>
                                        <td>Parent cluster for nesting</td>
                                    </tr>
                                </table>
                                <pre class="spec-pre">
{
  "name": "realtime",
  "description": "Real-time processing cluster",
  "parent": "order-processing"
}</pre
                                >
                            </div>

                            <div class="spec-section">
                                <h6>Attribute Lineage</h6>
                                <p style="color: var(--text-secondary); font-size: 12px; margin-bottom: 0.5rem">
                                    Add <code>attributes</code> to a datasource. Supports nesting for structs/objects.
                                    Reference upstream with <code>source::attr</code> or
                                    <code>source::parent::child</code>.
                                </p>
                                <table class="spec-table">
                                    <tr>
                                        <th>Field</th>
                                        <th>Type</th>
                                        <th>Required</th>
                                        <th>Description</th>
                                    </tr>
                                    <tr>
                                        <td><code>name</code></td>
                                        <td>string</td>
                                        <td>Yes</td>
                                        <td>Column/field name</td>
                                    </tr>
                                    <tr>
                                        <td><code>from</code></td>
                                        <td>string or array</td>
                                        <td>No</td>
                                        <td>Upstream refs</td>
                                    </tr>
                                    <tr>
                                        <td><code>attributes</code></td>
                                        <td>array</td>
                                        <td>No</td>
                                        <td>Nested child attributes</td>
                                    </tr>
                                </table>
                                <pre class="spec-pre">
{
  "name": "enriched_users",
  "attributes": [
    { "name": "user_id", "from": "raw_users::id" },
    {
      "name": "location",
      "from": "raw_users::address",
      "attributes": [
        { "name": "city", "from": "raw_users::address::city" },
        { "name": "zip", "from": "raw_users::address::zip" }
      ]
    }
  ]
}</pre
                                >
                            </div>

                            <div class="spec-section">
                                <h6>Full Example</h6>
                                <pre class="spec-pre">
{
  "clusters": [
    { "name": "etl", "description": "ETL pipelines" }
  ],
  "pipelines": [
    {
      "name": "user-enrichment",
      "description": "Enriches user data with events",
      "input_sources": ["raw_users", "events"],
      "output_sources": ["enriched_users"],
      "cluster": "etl",
      "schedule": "Every 2 hours",
      "tags": ["user-data"],
      "links": { "airflow": "https://..." }
    }
  ],
  "datasources": [
    {
      "name": "raw_users",
      "type": "snowflake",
      "owner": "data-team@company.com",
      "attributes": [
        { "name": "id" },
        { "name": "first" },
        { "name": "last" }
      ]
    },
    {
      "name": "enriched_users",
      "type": "snowflake",
      "attributes": [
        { "name": "user_id", "from": "raw_users::id" },
        { "name": "full_name", "from": ["raw_users::first", "raw_users::last"] }
      ]
    }
  ]
}</pre
                                >
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Spec Modal -->
        <div class="modal fade" id="specModal" tabindex="-1" aria-labelledby="specModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="specModalLabel">json spec</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-4">
                            <h6>Overview</h6>
                            <p class="text-muted">
                                Pipeviz uses a simple JSON configuration to define your data lineage. Only pipelines are
                                required. Clusters and datasources are auto-created when referenced, but you can add
                                rich descriptors for better documentation.
                            </p>
                        </div>

                        <div class="mb-4">
                            <h6>Root Structure</h6>
                            <pre class="bg-light p-3 rounded"><code>{
  "clusters": [ ... ],     // Optional: cluster definitions
  "pipelines": [ ... ],    // Required: pipeline definitions
  "datasources": [ ... ]   // Optional: rich data source definitions
}</code></pre>
                        </div>

                        <div class="mb-4">
                            <h6>Clusters (Optional)</h6>
                            <p class="text-muted small">
                                Clusters can be optionally declared upfront or referenced on-the-fly. Support nested
                                hierarchies with parent relationships.
                            </p>
                            <pre class="bg-light p-3 rounded"><code>{
  "name": "real-time",
  "description": "Real-time processing cluster",  // Optional
  "parent": "order-management"                    // Optional: creates nested cluster
}</code></pre>
                        </div>

                        <div class="mb-4">
                            <h6>Pipelines</h6>
                            <pre class="bg-light p-3 rounded"><code>{
  "name": "user-enrichment",
  "description": "Enriches user data...",       // Optional
  "input_sources": ["raw_users", "events"],     // Optional
  "output_sources": ["enriched_users"],         // Optional
  "schedule": "Every 2 hours",                  // Optional
  "tags": ["user-data", "ml"],                  // Optional
  "cluster": "user-processing",                 // Optional: single cluster
  "upstream_pipelines": ["data-ingestion"],     // Optional
  "links": {                                    // Optional
    "airflow": "https://...",
    "monitoring": "https://..."
  }
}</code></pre>
                        </div>

                        <div class="mb-4">
                            <h6>Data Sources (Optional)</h6>
                            <p class="text-muted small">
                                Data sources are auto-created when referenced in pipelines. Define them explicitly to
                                add rich metadata, ownership, and documentation.
                            </p>
                            <pre class="bg-light p-3 rounded"><code>{
  "name": "raw_users",
  "description": "Raw user data...",            // Optional
  "type": "snowflake",                          // Optional
  "owner": "data-team@company.com",             // Optional
  "tags": ["pii", "users"],                     // Optional
  "cluster": "user-processing",                 // Optional: single cluster
  "metadata": {                                 // Optional
    "size": "2.1TB",
    "record_count": "45M"
  },
  "links": {                                    // Optional
    "snowflake": "https://...",
    "docs": "https://..."
  }
}</code></pre>
                        </div>

                        <div class="alert alert-info">
                            <strong>Tips:</strong>
                            <ul class="mb-0 mt-2">
                                <li>
                                    Only <code>pipelines</code> array with pipeline <code>name</code> fields is required
                                </li>
                                <li>Clusters and datasources are auto-created when referenced in pipelines</li>
                                <li>Define datasources explicitly to add rich metadata, ownership, and links</li>
                                <li>Use <code>cluster</code> (singular) to assign nodes to one cluster each</li>
                                <li>
                                    Create nested clusters using the <code>parent</code> field in cluster definitions
                                </li>
                                <li>Use <code>upstream_pipelines</code> to show pipeline dependencies</li>
                                <li>Links can point to any external tools (Airflow, monitoring, docs, etc.)</li>
                            </ul>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Blast Radius Modal -->
        <div
            class="modal fade"
            id="blastRadiusModal"
            tabindex="-1"
            aria-labelledby="blastRadiusModalLabel"
            aria-hidden="true"
        >
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="blastRadiusModalLabel">
                            <span style="color: #c98b8b"></span> Blast Radius:
                            <span id="blast-radius-node-name"></span>
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body" style="padding: 0">
                        <div class="row g-0">
                            <div class="col-md-8">
                                <div
                                    id="blast-radius-graph"
                                    style="
                                        height: 500px;
                                        background: var(--bg-primary);
                                        overflow: hidden;
                                        touch-action: none;
                                    "
                                ></div>
                            </div>
                            <div
                                class="col-md-4"
                                style="border-left: 1px solid var(--border-color); height: 500px; overflow-y: auto"
                            >
                                <div id="blast-radius-summary" style="padding: 1rem"></div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    </div>
                </div>
            </div>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    </body>
</html>
