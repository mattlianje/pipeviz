<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ∞Ô∏è Pipeviz</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/@hpcc-js/wasm@2.13.0/dist/graphviz.umd.js"></script>
    <script src="https://unpkg.com/d3-graphviz@5.0.2/build/d3-graphviz.min.js"></script>
    <style>
        body {
            background-color: #fefefe;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }
        .hero-section {
            background: #ffffff;
            border: 1px solid #f0f0f0;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            margin: 2rem auto;
            padding: 3rem;
            max-width: 1200px;
        }
        .nav-tabs {
            border-bottom: 1px solid #f0f0f0;
            margin-bottom: 2rem;
        }
        .nav-tabs .nav-link {
            border: none;
            color: #8b9297;
            font-weight: 500;
            padding: 12px 24px;
            margin-right: 2px;
            background: transparent;
            border-radius: 8px 8px 0 0;
        }
        .nav-tabs .nav-link:hover {
            color: #5a6570;
            background-color: #f8f9fb;
        }
        .nav-tabs .nav-link.active {
            background-color: #fff;
            color: #2d3748;
            border-bottom: 2px solid #7c8fb0;
            font-weight: 600;
        }
        .card {
            border: 1px solid #f0f0f0;
            border-radius: 8px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.03);
            background: white;
        }
        .table {
            background: white;
            border-radius: 8px;
            overflow: hidden;
        }
        .table th {
            background-color: #f7f8fc;
            border: none;
            font-weight: 600;
            color: #4a5568;
        }
        .badge {
            font-weight: 500;
            font-size: 0.85em;
            padding: 0.4em 0.8em;
            border-radius: 12px;
        }
        .badge-snowflake { background-color: #f6f8fa; color: #0969da; border: 1px solid #d0d7de; }
        .badge-delta { background-color: #fff8f2; color: #bc4c00; border: 1px solid #f2cc60; }
        .badge-s3 { background-color: #fffbf2; color: #9a6700; border: 1px solid #d4a72c; }
        .badge-api { background-color: #f6f8f6; color: #1a7f37; border: 1px solid #a2c185; }
        .badge-database { background-color: #fbf8ff; color: #8250df; border: 1px solid #d0bfff; }
        .badge-tag { background-color: #fff8f2; color: #953800; border: 1px solid #fb8500; }
        .badge-cluster { background-color: #f0f9ff; color: #0c4a6e; border: 1px solid #7dd3fc; }
        .graph-container {
            background: white;
            border-radius: 8px;
            min-height: 500px;
            position: relative;
            border: 1px solid #f0f0f0;
        }
        .graph-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 10;
        }
        #graph svg {
            width: 100%;
            height: 500px;
            border-radius: 8px;
        }
        .legend {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.96);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #f0f0f0;
            font-size: 13px;
            max-width: 200px;
        }
        .json-editor {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        .node-highlighted {
            stroke: #ff6b35 !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 6px rgba(255, 107, 53, 0.5));
        }
        .node-highlighted text {
            font-weight: normal !important;
            fill: #000 !important;
            stroke: none !important;
            stroke-width: 0 !important;
        }
        .node-connected {
            stroke: #17a2b8 !important;
            stroke-width: 2px !important;
            filter: drop-shadow(0 0 3px rgba(23, 162, 184, 0.4));
        }
        .node-connected text {
            font-weight: normal !important;
            fill: #000 !important;
            stroke: none !important;
            stroke-width: 0 !important;
        }
        .node-dimmed {
            opacity: 0.3 !important;
        }
        .edge-highlighted {
            stroke: #ff6b35 !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 4px rgba(255, 107, 53, 0.6));
        }
        .edge-dimmed {
            opacity: 0.2 !important;
        }
        .node-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            white-space: pre-line;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }
        .node {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .node:hover {
            stroke-width: 2px !important;
            filter: drop-shadow(0 0 4px rgba(0, 0, 0, 0.3));
        }
        .node:hover text {
            font-weight: normal !important;
            fill: #000 !important;
            stroke: none !important;
            stroke-width: 0 !important;
        }
        .btn-primary {
            background-color: #7c8fb0;
            border-color: #7c8fb0;
            color: white;
            border-radius: 8px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .btn-primary:hover {
            background-color: #6b7d9e;
            border-color: #6b7d9e;
            color: white;
        }
        .hero-title {
            color: #2d3748;
            font-weight: 700;
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        .link-icon {
            text-decoration: none;
            padding: 6px 12px;
            border-radius: 6px;
            background: white;
            border: 1px solid #d0d7de;
            color: #656d76;
            font-size: 0.8rem;
            margin: 2px;
            display: inline-block;
            transition: all 0.2s ease;
            font-weight: 500;
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
        }
        .link-icon:hover {
            background: #f6f8fa;
            border-color: #8c959f;
            color: #24292f;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
        }
        .form-control:focus, .form-select:focus {
            border-color: #7c8fb0;
            box-shadow: 0 0 0 0.2rem rgba(124, 143, 176, 0.15);
        }
        .alert-info {
            background-color: #f0f4f8;
            border-color: #bee3f8;
            color: #2b6cb0;
        }
        .text-muted {
            color: #8b9297 !important;
        }
        .lead {
            color: #5a6570;
        }
        .drop-zone {
            position: relative;
            border: 2px dashed #d0d7de;
            border-radius: 8px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .drop-zone:hover {
            border-color: #7c8fb0;
            background-color: #f8f9fa;
        }
        .drop-zone.dragover {
            border-color: #7c8fb0;
            background-color: #f0f4f8;
            border-style: solid;
        }
    </style>
</head>
<body>
    <div class="container-fluid py-4">
        <div class="hero-section">
            <div class="text-center mb-5">
                <h1 class="hero-title">üõ∞Ô∏è Pipeviz</h1>
                <p class="lead text-muted">Easy, elegant lineage with a single <code>.json</code></p>
            </div>

            <ul class="nav nav-tabs" id="dashboardTabs">
                <li class="nav-item">
                    <button class="nav-link active" id="config-tab" data-bs-toggle="tab" data-bs-target="#config-pane">
                        Configuration
                    </button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="pipelines-tab" data-bs-toggle="tab" data-bs-target="#pipelines-pane">
                        Pipelines
                    </button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="datasources-tab" data-bs-toggle="tab" data-bs-target="#datasources-pane">
                        Data Sources
                    </button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="graph-tab" data-bs-toggle="tab" data-bs-target="#graph-pane">
                        Dependency Graph
                    </button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="dot-tab" data-bs-toggle="tab" data-bs-target="#dot-pane">
                        Raw DOT
                    </button>
                </li>
            </ul>

            <div class="tab-content">
                <!-- Configuration Tab -->
                <div class="tab-pane fade show active" id="config-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-10">
                                    <h5 class="mb-3">Configuration</h5>
                                    <div class="drop-zone" id="drop-zone">
                                        <textarea class="form-control json-editor" id="json-input" rows="20"
                                                  placeholder="Paste your pipeviz.json here, drag & drop a file, or click the button below to browse..."></textarea>
                                    </div>
                                    <div class="mt-3">
                                        <input type="file" id="file-input" accept=".json" style="display: none;" onchange="loadFromFile(event)">
                                        <button class="btn btn-outline-secondary me-2" onclick="document.getElementById('file-input').click()">Browse File</button>
                                        <button class="btn btn-outline-secondary me-2" onclick="loadExample()">Load Example</button>
                                        <button class="btn btn-outline-info" onclick="generateShareableUrl()">Generate Shareable URL</button>
                                    </div>
                                    <div id="json-status" class="mt-2"></div>
                                </div>
                                <div class="col-md-2">
                                    <div class="small text-muted">
                                        <div class="mb-3"><strong>Documentation:</strong></div>
                                        <div class="mb-2">
                                            <a href="#" onclick="showSpecModal()" class="link-icon">
                                                üìã JSON Spec
                                            </a>
                                        </div>
                                        <div class="mb-3"><strong>Load from URL:</strong></div>
                                        <div class="mb-2">Add <code style="font-size: 0.7rem;">?url=your-json-url</code> to this page's URL to auto-load a config.</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Pipelines Tab -->
                <div class="tab-pane fade" id="pipelines-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="row mb-3">
                                <div class="col-md-4">
                                    <input type="text" class="form-control" id="pipeline-search"
                                           placeholder="Search pipelines..." onkeyup="filterPipelines()">
                                </div>
                                <div class="col-md-4">
                                    <select class="form-select" id="pipeline-tag-filter" onchange="filterPipelines()">
                                        <option value="">All tags</option>
                                    </select>
                                </div>
                                <div class="col-md-4">
                                    <select class="form-select" id="pipeline-cluster-filter" onchange="filterPipelines()">
                                        <option value="">All clusters</option>
                                    </select>
                                </div>
                            </div>
                            <div id="pipelines-table-container">
                                <p class="text-muted text-center">Load a configuration to see your pipelines</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Data Sources Tab -->
                <div class="tab-pane fade" id="datasources-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="row mb-3">
                                <div class="col-md-3">
                                    <input type="text" class="form-control" id="datasource-search"
                                           placeholder="Search data sources..." onkeyup="filterDatasources()">
                                </div>
                                <div class="col-md-3">
                                    <select class="form-select" id="datasource-type-filter" onchange="filterDatasources()">
                                        <option value="">All types</option>
                                    </select>
                                </div>
                                <div class="col-md-3">
                                    <select class="form-select" id="datasource-tag-filter" onchange="filterDatasources()">
                                        <option value="">All tags</option>
                                    </select>
                                </div>
                                <div class="col-md-3">
                                    <select class="form-select" id="datasource-cluster-filter" onchange="filterDatasources()">
                                        <option value="">All clusters</option>
                                    </select>
                                </div>
                            </div>
                            <div id="datasources-table-container">
                                <p class="text-muted text-center">Load a configuration to see your data sources</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Graph Tab -->
                <div class="tab-pane fade" id="graph-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="alert alert-info">
                                <strong>Interactive Graph:</strong> Click nodes to highlight connections. Click empty space to clear selection.
                            </div>
                            <div class="graph-container position-relative">
                                <div class="graph-controls">
                                    <div class="btn-group me-2">
                                        <button class="btn btn-sm btn-outline-warning" onclick="clearSelection()">
                                            Clear Selection
                                        </button>
                                    </div>
                                    <button class="btn btn-sm btn-outline-primary me-2" onclick="fitGraph()">Fit</button>
                                    <button class="btn btn-sm btn-outline-secondary" onclick="resetGraph()">Reset</button>
                                </div>
                                <div id="graph"></div>
                                <div class="legend">
                                    <div><strong>Legend:</strong></div>
                                    <div>‚ñ† = Pipeline</div>
                                    <div>‚óè = Data Source</div>
                                    <div>‚ñ° = Cluster</div>
                                    <div>‚Üí = Data flow</div>
                                    <div style="color: #ff6b35;">‚Üí = Dependency</div>
                                    <div class="mt-2 small text-success">Click nodes to highlight</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Raw DOT Tab -->
                <div class="tab-pane fade" id="dot-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h5 class="mb-0">Generated Graphviz DOT</h5>
                                <div>
                                    <button class="btn btn-sm btn-outline-info me-2" onclick="updateDotView()">Refresh</button>
                                    <button class="btn btn-sm btn-outline-secondary" onclick="copyDotToClipboard()">Copy to Clipboard</button>
                                </div>
                            </div>
                            <div class="alert alert-info">
                                <strong>About DOT:</strong> This is the raw Graphviz DOT language representation of your data lineage.
                                You can copy this and use it with any Graphviz-compatible tool or modify it for custom visualizations.
                            </div>
                            <textarea class="form-control json-editor" id="dot-output" rows="25" readonly
                                      placeholder="Load a configuration to see the generated DOT code..."></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Spec Modal -->
    <div class="modal fade" id="specModal" tabindex="-1" aria-labelledby="specModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="specModalLabel">üìã Pipeviz JSON Specification</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-4">
                        <h6>Overview</h6>
                        <p class="text-muted">Pipeviz uses a simple JSON configuration to define your data lineage. Only pipelines are required - clusters and datasources are auto-created when referenced, but you can add rich descriptors for better documentation.</p>
                    </div>

                    <div class="mb-4">
                        <h6>Root Structure</h6>
                        <pre class="bg-light p-3 rounded"><code>{
  "clusters": [ ... ],     // Optional: cluster definitions
  "pipelines": [ ... ],    // Required: pipeline definitions
  "datasources": [ ... ]   // Optional: rich data source definitions
}</code></pre>
                    </div>

                    <div class="mb-4">
                        <h6>Clusters (Optional)</h6>
                        <p class="text-muted small">Clusters can be optionally declared upfront or referenced on-the-fly. Support nested hierarchies with parent relationships.</p>
                        <pre class="bg-light p-3 rounded"><code>{
  "name": "real-time",
  "description": "Real-time processing cluster",  // Optional
  "parent": "order-management"                    // Optional: creates nested cluster
}</code></pre>
                    </div>

                    <div class="mb-4">
                        <h6>Pipelines</h6>
                        <pre class="bg-light p-3 rounded"><code>{
  "name": "user-enrichment",
  "description": "Enriches user data...",       // Optional
  "input_sources": ["raw_users", "events"],     // Optional
  "output_sources": ["enriched_users"],         // Optional
  "schedule": "Every 2 hours",                  // Optional
  "tags": ["user-data", "ml"],                  // Optional
  "cluster": "user-processing",                 // Optional: single cluster
  "upstream_pipelines": ["data-ingestion"],     // Optional
  "links": {                                    // Optional
    "airflow": "https://...",
    "monitoring": "https://..."
  }
}</code></pre>
                    </div>

                    <div class="mb-4">
                        <h6>Data Sources (Optional)</h6>
                        <p class="text-muted small">Data sources are auto-created when referenced in pipelines. Define them explicitly to add rich metadata, ownership, and documentation.</p>
                        <pre class="bg-light p-3 rounded"><code>{
  "name": "raw_users",
  "description": "Raw user data...",            // Optional
  "type": "snowflake",                          // Optional
  "owner": "data-team@company.com",             // Optional
  "tags": ["pii", "users"],                     // Optional
  "cluster": "user-processing",                 // Optional: single cluster
  "metadata": {                                 // Optional
    "size": "2.1TB",
    "record_count": "45M"
  },
  "links": {                                    // Optional
    "snowflake": "https://...",
    "docs": "https://..."
  }
}</code></pre>
                    </div>

                    <div class="alert alert-info">
                        <strong>üí° Pro Tips:</strong>
                        <ul class="mb-0 mt-2">
                            <li>Only <code>pipelines</code> array with pipeline <code>name</code> fields is required</li>
                            <li>Clusters and datasources are auto-created when referenced in pipelines</li>
                            <li>Define datasources explicitly to add rich metadata, ownership, and links</li>
                            <li>Use <code>cluster</code> (singular) to assign nodes to one cluster each</li>
                            <li>Create nested clusters using the <code>parent</code> field in cluster definitions</li>
                            <li>Use <code>upstream_pipelines</code> to show pipeline dependencies</li>
                            <li>Links can point to any external tools (Airflow, monitoring, docs, etc.)</li>
                        </ul>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let currentConfig = null;
        let graphviz = null;
        let selectedNode = null;

        const exampleConfig = {
            "clusters": [
                {
                    "name": "user-processing",
                    "description": "User data processing and enrichment cluster"
                },
                {
                    "name": "order-management",
                    "description": "Order processing and validation cluster"
                },
                {
                    "name": "real-time",
                    "description": "Real-time streaming data cluster",
                    "parent": "order-management"
                },
                {
                    "name": "analytics",
                    "description": "Analytics and reporting cluster"
                }
            ],
            "pipelines": [
                {
                    "name": "user-enrichment",
                    "description": "Enriches user data with behavioral signals and ML features",
                    "input_sources": ["raw_users", "user_events"],
                    "output_sources": ["enriched_users"],
                    "schedule": "Every 2 hours",
                    "tags": ["user-data", "ml", "enrichment"],
                    "cluster": "user-processing",
                    "links": {
                        "airflow": "https://airflow.company.com/dags/user_enrichment",
                        "monitoring": "https://grafana.company.com/d/user-enrichment",
                        "docs": "https://docs.company.com/pipelines/user-enrichment"
                    },
                    "upstream_pipelines": []
                },
                {
                    "name": "order-processing",
                    "description": "Validates and processes incoming orders in real-time",
                    "input_sources": ["raw_orders", "inventory"],
                    "output_sources": ["processed_orders", "order_audit"],
                    "schedule": "Every 15 minutes",
                    "tags": ["orders", "real-time", "validation"],
                    "cluster": "real-time",
                    "links": {
                        "airflow": "https://airflow.company.com/dags/order_processing",
                        "monitoring": "https://grafana.company.com/d/orders",
                        "alerts": "https://pagerduty.company.com/services/orders"
                    },
                    "upstream_pipelines": []
                },
                {
                    "name": "analytics-aggregation",
                    "description": "Daily aggregation of user metrics and business KPIs",
                    "input_sources": ["enriched_users", "processed_orders", "user_events"],
                    "output_sources": ["daily_metrics", "user_cohorts"],
                    "schedule": "Daily at 1:00 AM",
                    "tags": ["analytics", "aggregation", "daily"],
                    "cluster": "analytics",
                    "links": {
                        "airflow": "https://airflow.company.com/dags/analytics_agg",
                        "dashboard": "https://tableau.company.com/analytics-dashboard"
                    },
                    "upstream_pipelines": ["user-enrichment", "order-processing"]
                }
            ],
            "datasources": [
                {
                    "name": "raw_users",
                    "description": "Raw user registration and profile data from production database",
                    "type": "snowflake",
                    "owner": "data-platform@company.com",
                    "tags": ["pii", "users", "core-data"],
                    "cluster": "user-processing",
                    "metadata": {
                        "schema": "RAW_DATA",
                        "table": "USERS",
                        "size": "2.1TB",
                        "record_count": "45M",
                        "refresh_frequency": "real-time"
                    },
                    "links": {
                        "snowflake": "https://company.snowflakecomputing.com/console#/data/databases/PROD/schemas/RAW_DATA/table/USERS",
                        "monitoring": "https://grafana.company.com/d/raw-users",
                        "docs": "https://docs.company.com/schemas/raw_users"
                    }
                },
                {
                    "name": "user_events",
                    "description": "Clickstream and interaction events from all digital touchpoints",
                    "type": "s3",
                    "owner": "analytics-team@company.com",
                    "tags": ["events", "clickstream", "large-dataset"],
                    "cluster": "analytics",
                    "metadata": {
                        "bucket": "company-events-prod",
                        "size": "15TB",
                        "record_count": "2.5B",
                        "file_format": "parquet"
                    },
                    "links": {
                        "s3": "https://s3.console.aws.amazon.com/s3/buckets/company-events-prod",
                        "athena": "https://console.aws.amazon.com/athena/home#query"
                    }
                },
                {
                    "name": "raw_orders",
                    "description": "Real-time order data from e-commerce platform",
                    "type": "api",
                    "owner": "platform-team@company.com",
                    "tags": ["orders", "real-time", "revenue"],
                    "cluster": "real-time",
                    "metadata": {
                        "endpoint": "https://api.company.com/v2/orders",
                        "rate_limit": "1000 req/min",
                        "record_count": "120M"
                    },
                    "links": {
                        "api_docs": "https://docs.company.com/api/orders",
                        "monitoring": "https://grafana.company.com/d/orders-api"
                    }
                },
                {
                    "name": "inventory",
                    "description": "Product inventory levels across all warehouses",
                    "type": "snowflake",
                    "owner": "supply-chain@company.com",
                    "tags": ["inventory", "warehouse", "operational"],
                    "cluster": "order-management",
                    "metadata": {
                        "schema": "INVENTORY",
                        "size": "150GB",
                        "refresh_frequency": "every 15 minutes"
                    },
                    "links": {
                        "snowflake": "https://company.snowflakecomputing.com/console#/data/databases/PROD/schemas/INVENTORY",
                        "tableau": "https://tableau.company.com/views/inventory-dashboard"
                    }
                }
            ]
        };

        function loadExample() {
            document.getElementById('json-input').value = JSON.stringify(exampleConfig, null, 2);
            loadJson();
        }

        function generateShareableUrl() {
            if (!currentConfig) {
                alert('No configuration loaded to share');
                return;
            }

            const configJson = JSON.stringify(currentConfig);
            const encodedConfig = btoa(configJson);
            const currentUrl = window.location.origin + window.location.pathname;
            const shareableUrl = `${currentUrl}?config=${encodedConfig}`;

            navigator.clipboard.writeText(shareableUrl).then(() => {
                const statusDiv = document.getElementById('json-status');
                statusDiv.innerHTML = '<div class="alert alert-success">Shareable URL copied to clipboard!</div>';
                setTimeout(() => {
                    statusDiv.innerHTML = '';
                }, 3000);
            }).catch(() => {
                prompt('Copy this shareable URL:', shareableUrl);
            });
        }

        function loadFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);

            const configParam = urlParams.get('config');
            if (configParam) {
                try {
                    const decodedConfig = atob(configParam);
                    const parsed = JSON.parse(decodedConfig);
                    document.getElementById('json-input').value = JSON.stringify(parsed, null, 2);
                    loadJson();
                    return;
                } catch (error) {
                    console.error('Error decoding config parameter:', error);
                }
            }

            const urlParam = urlParams.get('url');
            if (urlParam) {
                fetch(urlParam)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        return response.text();
                    })
                    .then(configText => {
                        try {
                            const parsed = JSON.parse(configText);
                            document.getElementById('json-input').value = JSON.stringify(parsed, null, 2);
                            loadJson();
                        } catch (error) {
                            document.getElementById('json-input').value = configText;
                            loadJson();
                        }
                    })
                    .catch(error => {
                        const statusDiv = document.getElementById('json-status');
                        statusDiv.innerHTML = `<div class="alert alert-danger">Error loading from URL: ${error.message}</div>`;
                        loadExample();
                    });
                return;
            }

            loadExample();
        }

        function setupDragDrop() {
            const dropZone = document.getElementById('drop-zone');
            const textarea = document.getElementById('json-input');

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => dropZone.classList.add('dragover'), false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => dropZone.classList.remove('dragover'), false);
            });

            dropZone.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type === "application/json" || file.name.endsWith('.json')) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            try {
                                const parsed = JSON.parse(e.target.result);
                                textarea.value = JSON.stringify(parsed, null, 2);
                                loadJson();
                            } catch (error) {
                                textarea.value = e.target.result;
                                loadJson();
                            }
                        };
                        reader.readAsText(file);
                    } else {
                        const statusDiv = document.getElementById('json-status');
                        statusDiv.innerHTML = '<div class="alert alert-warning">Please drop a JSON file</div>';
                    }
                }
            }
        }

        function loadFromFile(event) {
            const file = event.target.files[0];
            if (file && (file.type === "application/json" || file.name.endsWith('.json'))) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const parsed = JSON.parse(e.target.result);
                        document.getElementById('json-input').value = JSON.stringify(parsed, null, 2);
                        loadJson();
                    } catch (error) {
                        document.getElementById('json-input').value = e.target.result;
                        loadJson();
                    }
                };
                reader.readAsText(file);
            } else {
                const statusDiv = document.getElementById('json-status');
                statusDiv.innerHTML = '<div class="alert alert-warning">Please select a valid JSON file</div>';
            }
        }

        function setupAutoProcess() {
            const textarea = document.getElementById('json-input');
            let timeout;

            textarea.addEventListener('input', function() {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    const content = textarea.value.trim();
                    if (content && content.startsWith('{') && content.endsWith('}')) {
                        try {
                            const parsed = JSON.parse(content);
                            const prettified = JSON.stringify(parsed, null, 2);
                            if (prettified !== content) {
                                textarea.value = prettified;
                            }
                            loadJson();
                        } catch (e) {
                            // Invalid JSON, don't process yet
                        }
                    }
                }, 1000);
            });
        }

        function loadJson() {
            const jsonText = document.getElementById('json-input').value.trim();
            const statusDiv = document.getElementById('json-status');

            if (!jsonText) {
                statusDiv.innerHTML = '<div class="alert alert-warning">Please enter JSON configuration</div>';
                return;
            }

            try {
                currentConfig = JSON.parse(jsonText);
                statusDiv.innerHTML = '<div class="alert alert-success">Configuration loaded successfully!</div>';

                renderPipelines();
                renderDatasources();
                updateFilters();
                renderGraph();
                updateDotView();

            } catch (error) {
                statusDiv.innerHTML = `<div class="alert alert-danger">JSON Parse Error: ${error.message}</div>`;
            }
        }

        function renderPipelines() {
            if (!currentConfig || !currentConfig.pipelines) return;

            const container = document.getElementById('pipelines-table-container');
            let html = `
                <table class="table table-striped table-hover">
                    <thead>
                        <tr>
                            <th>Pipeline</th>
                            <th>Description</th>
                            <th>Schedule</th>
                            <th>Input Sources</th>
                            <th>Output Sources</th>
                            <th>Cluster</th>
                            <th>Tags</th>
                            <th>Links</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            currentConfig.pipelines.forEach(pipeline => {
                const inputSources = pipeline.input_sources?.map(s =>
                    `<span class="badge me-1 mb-1" style="background-color: #e3f2fd; color: #1565c0; font-size: 0.85em;">${s}</span>`
                ).join('') || '';

                const outputSources = pipeline.output_sources?.map(s =>
                    `<span class="badge me-1 mb-1" style="background-color: #e8f5e8; color: #2e7d32; font-size: 0.85em;">${s}</span>`
                ).join('') || '';

                const cluster = pipeline.cluster ?
                    `<span class="badge badge-cluster me-1 mb-1">${pipeline.cluster}</span>` : '';

                const tags = pipeline.tags?.map(t =>
                    `<span class="badge me-1 mb-1" style="background-color: #fff3cd; color: #856404; font-size: 0.85em;">${t}</span>`
                ).join('') || '';

                const links = pipeline.links ? Object.entries(pipeline.links).map(([name, url]) =>
                    `<a href="${url}" target="_blank" class="btn btn-sm btn-outline-primary me-1 mb-1" style="font-size: 0.75em; padding: 2px 6px;">${name}</a>`
                ).join('') : '';

                html += `
                    <tr class="pipeline-row"
                        data-name="${pipeline.name.toLowerCase()}"
                        data-description="${(pipeline.description || '').toLowerCase()}"
                        data-cluster="${(pipeline.cluster || '').toLowerCase()}"
                        data-tags="${(pipeline.tags || []).join(',').toLowerCase()}">
                        <td><strong>${pipeline.name}</strong></td>
                        <td>${pipeline.description || ''}</td>
                        <td><code class="text-success">${pipeline.schedule || ''}</code></td>
                        <td>${inputSources}</td>
                        <td>${outputSources}</td>
                        <td>${cluster}</td>
                        <td>${tags}</td>
                        <td>${links}</td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function renderDatasources() {
            if (!currentConfig || !currentConfig.pipelines) {
                const container = document.getElementById('datasources-table-container');
                container.innerHTML = '<p class="text-muted text-center">Load a configuration to see your data sources</p>';
                return;
            }
        
            const allDataSources = new Map();
            
            if (currentConfig.datasources) {
                currentConfig.datasources.forEach(ds => {
                    allDataSources.set(ds.name, ds);
                });
            }
            
            currentConfig.pipelines.forEach(pipeline => {
                pipeline.input_sources?.forEach(sourceName => {
                    if (!allDataSources.has(sourceName)) {
                        allDataSources.set(sourceName, { 
                            name: sourceName, 
                            type: 'auto-created',
                            description: 'Auto-created from pipeline references',
                            isAutoCreated: true
                        });
                    }
                });
                pipeline.output_sources?.forEach(sourceName => {
                    if (!allDataSources.has(sourceName)) {
                        allDataSources.set(sourceName, { 
                            name: sourceName, 
                            type: 'auto-created',
                            description: 'Auto-created from pipeline references',
                            isAutoCreated: true
                        });
                    }
                });
            });
        
            const container = document.getElementById('datasources-table-container');
            
            if (allDataSources.size === 0) {
                container.innerHTML = '<p class="text-muted text-center">No data sources found</p>';
                return;
            }
        
            let html = `
                <table class="table table-striped table-hover">
                    <thead>
                        <tr>
                            <th>Name & Type</th>
                            <th>Description</th>
                            <th>Owner</th>
                            <th>Metadata</th>
                            <th>Cluster</th>
                            <th>Tags</th>
                            <th>Links</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
        
            allDataSources.forEach(ds => {
                const typeBadge = `<span class="badge badge-${ds.type || 'secondary'}">${(ds.type || 'unknown').toUpperCase()}</span>`;
        
                const metadata = ds.metadata ? Object.entries(ds.metadata).map(([k, v]) =>
                    `<div class="small text-muted mb-1"><span style="font-weight: 500;">${k.replace(/_/g, ' ')}:</span> ${v}</div>`
                ).join('') : '';
        
                const cluster = ds.cluster ?
                    `<span class="badge badge-cluster me-1 mb-1">${ds.cluster}</span>` : '';
        
                const tags = ds.tags?.map(t =>
                    `<span class="badge me-1 mb-1" style="background-color: #fff3cd; color: #856404; font-size: 0.85em;">${t}</span>`
                ).join('') || '';
        
                const links = ds.links ? Object.entries(ds.links).map(([name, url]) =>
                    `<a href="${url}" target="_blank" class="btn btn-sm btn-outline-primary me-1 mb-1" style="font-size: 0.75em; padding: 2px 6px;">${name}</a>`
                ).join('') : '';
        
                html += `
                    <tr class="datasource-row"
                        data-name="${ds.name.toLowerCase()}"
                        data-type="${(ds.type || '').toLowerCase()}"
                        data-cluster="${(ds.cluster || '').toLowerCase()}"
                        data-tags="${(ds.tags || []).join(',').toLowerCase()}"
                        data-search="${(ds.name + ' ' + (ds.description || '') + ' ' + (ds.owner || '')).toLowerCase()}">
                        <td>
                            <div><strong>${ds.name}</strong></div>
                            <div>${typeBadge}</div>
                        </td>
                        <td>${ds.isAutoCreated ? `<span class="text-secondary fst-italic">${ds.description}</span>` : (ds.description || '')}</td>
                        <td class="small text-muted">${ds.owner || ''}</td>
                        <td>${metadata}</td>
                        <td>${cluster}</td>
                        <td>${tags}</td>
                        <td>${links}</td>
                    </tr>
                `;
            });
        
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function updateFilters() {
            if (!currentConfig) return;

            // Pipeline filters
            const pipelineTags = [...new Set(currentConfig.pipelines?.flatMap(p => p.tags || []) || [])].sort();
            const pipelineTagFilter = document.getElementById('pipeline-tag-filter');
            pipelineTagFilter.innerHTML = '<option value="">All tags</option>' +
                pipelineTags.map(tag => `<option value="${tag}">${tag}</option>`).join('');

            const pipelineClusters = [...new Set(currentConfig.pipelines?.map(p => p.cluster).filter(c => c) || [])].sort();
            const pipelineClusterFilter = document.getElementById('pipeline-cluster-filter');
            pipelineClusterFilter.innerHTML = '<option value="">All clusters</option>' +
                pipelineClusters.map(cluster => `<option value="${cluster}">${cluster}</option>`).join('');

            // Datasource filters
            const datasourceTypes = [...new Set(currentConfig.datasources?.map(ds => ds.type || 'unknown') || [])].sort();
            const datasourceTags = [...new Set(currentConfig.datasources?.flatMap(ds => ds.tags || []) || [])].sort();
            const datasourceClusters = [...new Set(currentConfig.datasources?.map(ds => ds.cluster).filter(c => c) || [])].sort();

            const typeFilter = document.getElementById('datasource-type-filter');
            typeFilter.innerHTML = '<option value="">All types</option>' +
                datasourceTypes.map(type => `<option value="${type}">${type}</option>`).join('');

            const dsTagFilter = document.getElementById('datasource-tag-filter');
            dsTagFilter.innerHTML = '<option value="">All tags</option>' +
                datasourceTags.map(tag => `<option value="${tag}">${tag}</option>`).join('');

            const dsClusterFilter = document.getElementById('datasource-cluster-filter');
            dsClusterFilter.innerHTML = '<option value="">All clusters</option>' +
                datasourceClusters.map(cluster => `<option value="${cluster}">${cluster}</option>`).join('');
        }

        function filterPipelines() {
            const searchTerm = document.getElementById('pipeline-search').value.toLowerCase();
            const selectedTag = document.getElementById('pipeline-tag-filter').value.toLowerCase();
            const selectedCluster = document.getElementById('pipeline-cluster-filter').value.toLowerCase();
            const rows = document.querySelectorAll('.pipeline-row');

            rows.forEach(row => {
                const name = row.getAttribute('data-name');
                const description = row.getAttribute('data-description');
                const tags = row.getAttribute('data-tags');
                const cluster = row.getAttribute('data-cluster');

                const matchesSearch = !searchTerm || name.includes(searchTerm) || description.includes(searchTerm);
                const matchesTag = !selectedTag || tags.includes(selectedTag);
                const matchesCluster = !selectedCluster || cluster === selectedCluster;

                row.style.display = (matchesSearch && matchesTag && matchesCluster) ? '' : 'none';
            });
        }

        function filterDatasources() {
            const searchTerm = document.getElementById('datasource-search').value.toLowerCase();
            const selectedType = document.getElementById('datasource-type-filter').value.toLowerCase();
            const selectedTag = document.getElementById('datasource-tag-filter').value.toLowerCase();
            const selectedCluster = document.getElementById('datasource-cluster-filter').value.toLowerCase();
            const rows = document.querySelectorAll('.datasource-row');

            rows.forEach(row => {
                const searchContent = row.getAttribute('data-search');
                const type = row.getAttribute('data-type');
                const tags = row.getAttribute('data-tags');
                const cluster = row.getAttribute('data-cluster');

                const matchesSearch = !searchTerm || searchContent.includes(searchTerm);
                const matchesType = !selectedType || type === selectedType;
                const matchesTag = !selectedTag || tags.includes(selectedTag);
                const matchesCluster = !selectedCluster || cluster === selectedCluster;

                row.style.display = (matchesSearch && matchesType && matchesTag && matchesCluster) ? '' : 'none';
            });
        }

        function generateGraphvizDot() {
            if (!currentConfig) return '';
        
            const pipelines = currentConfig.pipelines || [];
            const datasources = currentConfig.datasources || [];
            const explicitClusters = currentConfig.clusters || [];
        
            // Collect ALL data sources (explicit + auto-created from pipeline references)
            const allDataSources = new Map();
            
            // Add explicit data sources
            datasources.forEach(ds => {
                allDataSources.set(ds.name, ds);
            });
            
            // Add auto-created data sources from pipeline input/output references
            pipelines.forEach(pipeline => {
                pipeline.input_sources?.forEach(sourceName => {
                    if (!allDataSources.has(sourceName)) {
                        allDataSources.set(sourceName, { 
                            name: sourceName, 
                            type: 'auto-created'
                            // No cluster assignment - let auto-created sources be unclustered
                        });
                    }
                });
                pipeline.output_sources?.forEach(sourceName => {
                    if (!allDataSources.has(sourceName)) {
                        allDataSources.set(sourceName, { 
                            name: sourceName, 
                            type: 'auto-created'
                            // No cluster assignment - let auto-created sources be unclustered
                        });
                    }
                });
            });
        
            // Collect all clusters mentioned in pipelines and datasources
            const allClusterNames = new Set();
            pipelines.forEach(p => { if (p.cluster) allClusterNames.add(p.cluster); });
            allDataSources.forEach(ds => { if (ds.cluster) allClusterNames.add(ds.cluster); });
        
            // Build cluster hierarchy
            const clusterDefinitions = new Map();
            const clusterHierarchy = new Map(); // child -> parent
            const clusterChildren = new Map(); // parent -> [children]
        
            // Process explicit clusters
            explicitClusters.forEach(cluster => {
                clusterDefinitions.set(cluster.name, cluster);
                allClusterNames.add(cluster.name);
        
                if (cluster.parent) {
                    clusterHierarchy.set(cluster.name, cluster.parent);
                    if (!clusterChildren.has(cluster.parent)) {
                        clusterChildren.set(cluster.parent, []);
                    }
                    clusterChildren.get(cluster.parent).push(cluster.name);
                    allClusterNames.add(cluster.parent); // Ensure parent exists
                }
            });
        
            // Add implicit clusters (those referenced but not explicitly defined)
            allClusterNames.forEach(name => {
                if (!clusterDefinitions.has(name)) {
                    clusterDefinitions.set(name, { name, description: `Auto-generated cluster: ${name}` });
                }
            });
        
            let dot = `digraph PipevizGraph {
            rankdir=LR;
            bgcolor="transparent";
            node [fontsize=12];
            edge [fontsize=10];
        
        `;
        
            // Generate cluster colors automatically
            const clusterColors = [
                "#1976d2", "#7b1fa2", "#388e3c", "#f57c00", "#d32f2f",
                "#1976d2", "#616161", "#c2185b", "#303f9f", "#f57c00"
            ];
        
            // Group nodes by cluster
            const nodesByCluster = new Map();
        
            pipelines.forEach(pipeline => {
                const cluster = pipeline.cluster || '_unclustered';
                if (!nodesByCluster.has(cluster)) {
                    nodesByCluster.set(cluster, []);
                }
                nodesByCluster.get(cluster).push({ type: 'pipeline', node: pipeline });
            });
        
            // Use ALL data sources (explicit + auto-created)
            allDataSources.forEach(ds => {
                const cluster = ds.cluster || '_unclustered';
                if (!nodesByCluster.has(cluster)) {
                    nodesByCluster.set(cluster, []);
                }
                nodesByCluster.get(cluster).push({ type: 'datasource', node: ds });
            });
        
            // Find root clusters (those without parents)
            const rootClusters = [];
            clusterDefinitions.forEach((cluster, name) => {
                if (!clusterHierarchy.has(name) && nodesByCluster.has(name)) {
                    rootClusters.push(name);
                }
            });
        
            let colorIndex = 0;
        
            function renderCluster(clusterName, depth = 0) {
                const cluster = clusterDefinitions.get(clusterName);
                if (!cluster) return '';
        
                const nodesInCluster = nodesByCluster.get(clusterName) || [];
                const children = clusterChildren.get(clusterName) || [];
        
                // Skip if cluster has no nodes and no children with nodes
                const hasNodes = nodesInCluster.length > 0;
                const hasChildrenWithNodes = children.some(child =>
                    nodesByCluster.has(child) && nodesByCluster.get(child).length > 0
                );
        
                if (!hasNodes && !hasChildrenWithNodes) return '';
        
                const clusterColor = clusterColors[colorIndex % clusterColors.length];
                colorIndex++;
        
                let result = `${'    '.repeat(depth + 1)}subgraph cluster_${clusterName.replace(/[^a-zA-Z0-9]/g, '_')} {
        ${'    '.repeat(depth + 2)}label="${clusterName}";
        ${'    '.repeat(depth + 2)}style="dotted";
        ${'    '.repeat(depth + 2)}color="#666666";
        ${'    '.repeat(depth + 2)}fontsize=11;
        ${'    '.repeat(depth + 2)}fontname="Arial";
        
        `;
        
                // Add nodes in this cluster
                nodesInCluster.forEach(item => {
                    if (item.type === 'pipeline') {
                        const pipeline = item.node;
                        const label = pipeline.schedule ? 
                            `<${pipeline.name}<BR/><FONT POINT-SIZE="9" COLOR="#d63384"><I>${pipeline.schedule}</I></FONT>>` :
                            `"${pipeline.name}"`;
                        result += `${'    '.repeat(depth + 2)}"${pipeline.name}" [shape=box, style="filled,rounded",
        ${'    '.repeat(depth + 3)}fillcolor="#e3f2fd", color="#1976d2",
        ${'    '.repeat(depth + 3)}fontname="Arial Bold",
        ${'    '.repeat(depth + 3)}label=${label}];
        `;
                    } else if (item.type === 'datasource') {
                        const ds = item.node;
                        result += `${'    '.repeat(depth + 2)}"${ds.name}" [shape=ellipse, style=filled,
        ${'    '.repeat(depth + 3)}fillcolor="#f3e5f5", color="#7b1fa2",
        ${'    '.repeat(depth + 3)}fontname="Arial", fontsize=10];
        `;
                    }
                });
        
                // Add child clusters
                children.forEach(childName => {
                    result += renderCluster(childName, depth + 1);
                });
        
                result += `${'    '.repeat(depth + 1)}}
        
        `;
                return result;
            }
        
            // Render all root clusters
            rootClusters.forEach(clusterName => {
                dot += renderCluster(clusterName);
            });
        
            // Add unclustered nodes
            const unclusteredNodes = nodesByCluster.get('_unclustered') || [];
            unclusteredNodes.forEach(item => {
                if (item.type === 'pipeline') {
                    const pipeline = item.node;
                    const label = pipeline.schedule ? 
                        `<${pipeline.name}<BR/><FONT POINT-SIZE="9" COLOR="#d63384"><I>${pipeline.schedule}</I></FONT>>` :
                        `"${pipeline.name}"`;
                    dot += `    "${pipeline.name}" [shape=box, style="filled,rounded",
                fillcolor="#e3f2fd", color="#1976d2",
                fontname="Arial Bold",
                label=${label}];
        `;
                } else if (item.type === 'datasource') {
                    const ds = item.node;
                    dot += `    "${ds.name}" [shape=ellipse, style=filled,
                fillcolor="#f3e5f5", color="#7b1fa2",
                fontname="Arial", fontsize=10];
        `;
                }
            });
        
            // Add data flow edges
            dot += '\n';
            pipelines.forEach(pipeline => {
                pipeline.input_sources?.forEach(source => {
                    dot += `    "${source}" -> "${pipeline.name}" [color="#666", arrowsize=0.8];\n`;
                });
                pipeline.output_sources?.forEach(source => {
                    dot += `    "${pipeline.name}" -> "${source}" [color="#666", arrowsize=0.8];\n`;
                });
            });
        
            // Add pipeline dependencies
            dot += '\n';
            pipelines.forEach(pipeline => {
                pipeline.upstream_pipelines?.forEach(upstream => {
                    dot += `    "${upstream}" -> "${pipeline.name}" [color="#ff6b35", style="solid", arrowsize=0.8];\n`;
                });
            });
        
            dot += '\n    overlap=false; splines=true;\n}';
            return dot;
        }



        function renderGraph() {
            if (!currentConfig) return;

            document.getElementById('graph-tab').addEventListener('shown.bs.tab', function() {
                if (!graphviz) {
                    setTimeout(initializeGraph, 100);
                } else {
                    // Force re-render when tab is shown
                    updateGraph();
                }
            });

            if (document.getElementById('graph-tab').classList.contains('active')) {
                setTimeout(initializeGraph, 100);
            }
        }

        function initializeGraph() {
            try {
                graphviz = d3.select("#graph").graphviz()
                    .width(document.getElementById('graph').clientWidth)
                    .height(500)
                    .fit(true)
                    .on("initEnd", setupGraphInteractivity)
                    .on("renderEnd", setupGraphInteractivity);
                updateGraph();
            } catch (error) {
                console.error('Graphviz initialization error:', error);
                // Fallback: show DOT code in graph area
                document.getElementById('graph').innerHTML = `
                    <div class="alert alert-warning m-3">
                        <strong>Graph rendering issue detected.</strong><br>
                        Please check the Raw DOT tab to see the generated code.<br>
                        <small>Error: ${error.message}</small>
                    </div>
                `;
            }
        }

        function updateGraph() {
            if (graphviz) {
                const dotSrc = generateGraphvizDot();
                graphviz.renderDot(dotSrc);
            }
        }

        function setupGraphInteractivity() {
            if (document.getElementById('node-tooltip')) {
                document.getElementById('node-tooltip').remove();
            }
            const tooltip = document.createElement('div');
            tooltip.id = 'node-tooltip';
            tooltip.className = 'node-tooltip';
            tooltip.style.display = 'none';
            document.body.appendChild(tooltip);

            d3.select("#graph").selectAll(".node")
                .style("cursor", "pointer")
                .on("click", function(event, d) {
                    event.stopPropagation();
                    const nodeName = d3.select(this).select("title").text();
                    selectNode(nodeName, this);
                })
                .on("mouseover", function(event, d) {
                    const nodeName = d3.select(this).select("title").text();
                    showNodeTooltip(event, nodeName);
                })
                .on("mousemove", function(event, d) {
                    tooltip.style.left = (event.pageX + 10) + 'px';
                    tooltip.style.top = (event.pageY - 10) + 'px';
                })
                .on("mouseout", function(event, d) {
                    hideNodeTooltip();
                });

            d3.select("#graph").on("click", function(event) {
                // Check if clicked on background
                if (event.target.tagName === "svg" || event.target === event.currentTarget || 
                    event.target.classList.contains('graph-container') || 
                    !event.target.closest('.node')) {
                    clearSelection();
                }
            });
        }

        function showNodeTooltip(event, nodeName) {
            const tooltip = document.getElementById('node-tooltip');
            if (!tooltip || !currentConfig) return;

            let content = '';

            const pipeline = currentConfig.pipelines?.find(p => p.name === nodeName);
            if (pipeline) {
                content = `${pipeline.name}`;
                if (pipeline.description) content += `\nDescription: ${pipeline.description}`;
                if (pipeline.schedule) content += `\nSchedule: ${pipeline.schedule}`;
                if (pipeline.cluster) content += `\nCluster: ${pipeline.cluster}`;
                if (pipeline.tags && pipeline.tags.length > 0) content += `\nTags: ${pipeline.tags.join(', ')}`;
                if (pipeline.input_sources && pipeline.input_sources.length > 0) content += `\nInputs: ${pipeline.input_sources.join(', ')}`;
                if (pipeline.output_sources && pipeline.output_sources.length > 0) content += `\nOutputs: ${pipeline.output_sources.join(', ')}`;
            }

            const datasource = currentConfig.datasources?.find(ds => ds.name === nodeName);
            if (datasource) {
                content = `${datasource.name}`;
                if (datasource.type) content += `\nType: ${datasource.type.toUpperCase()}`;
                if (datasource.description) content += `\nDescription: ${datasource.description}`;
                if (datasource.owner) content += `\nOwner: ${datasource.owner}`;
                if (datasource.cluster) content += `\nCluster: ${datasource.cluster}`;
                if (datasource.tags && datasource.tags.length > 0) content += `\nTags: ${datasource.tags.join(', ')}`;

                if (datasource.metadata) {
                    const keyFields = ['size', 'record_count', 'refresh_frequency', 'environment'];
                    keyFields.forEach(field => {
                        if (datasource.metadata[field]) {
                            content += `\n${field.replace(/_/g, ' ')}: ${datasource.metadata[field]}`;
                        }
                    });
                }
            }

            if (content) {
                tooltip.textContent = content;
                tooltip.style.display = 'block';
                tooltip.style.left = (event.pageX + 10) + 'px';
                tooltip.style.top = (event.pageY - 10) + 'px';
            }
        }

        function hideNodeTooltip() {
            const tooltip = document.getElementById('node-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        function selectNode(nodeName, nodeElement) {
            selectedNode = nodeName;
            clearHighlights();
            d3.select(nodeElement).classed("node-highlighted", true);

            const connectedNodes = new Set();
            const connectedEdges = new Set();

            d3.select("#graph").selectAll(".edge").each(function() {
                const edge = d3.select(this);
                const title = edge.select("title").text();
                const match = title.match(/^(.+?)(?:->|--)\s*(.+?)$/);
                if (match) {
                    const source = match[1];
                    const target = match[2];
                    if (source === nodeName || target === nodeName) {
                        connectedEdges.add(this);
                        connectedNodes.add(source === nodeName ? target : source);
                        edge.classed("edge-highlighted", true);
                    }
                }
            });

            d3.select("#graph").selectAll(".node").each(function() {
                const node = d3.select(this);
                const nodeTitle = node.select("title").text();
                if (connectedNodes.has(nodeTitle)) {
                    node.classed("node-connected", true);
                } else if (nodeTitle !== nodeName) {
                    node.classed("node-dimmed", true);
                }
            });

            d3.select("#graph").selectAll(".edge").each(function() {
                if (!connectedEdges.has(this)) {
                    d3.select(this).classed("edge-dimmed", true);
                }
            });
        }

        function clearSelection() {
            selectedNode = null;
            clearHighlights();
        }

        function clearHighlights() {
            d3.select("#graph").selectAll(".node")
                .classed("node-highlighted node-connected node-dimmed", false);
            d3.select("#graph").selectAll(".edge")
                .classed("edge-highlighted edge-dimmed", false);
        }

        function fitGraph() {
            if (graphviz) graphviz.fit(true);
        }

        function resetGraph() {
            if (graphviz) graphviz.resetZoom();
        }

        function updateDotView() {
            const dotOutput = document.getElementById('dot-output');
            if (currentConfig) {
                dotOutput.value = generateGraphvizDot();
            } else {
                dotOutput.value = '';
            }
        }

        function copyDotToClipboard() {
            const dotOutput = document.getElementById('dot-output');
            if (dotOutput.value) {
                navigator.clipboard.writeText(dotOutput.value).then(() => {
                    // Show temporary success message
                    const originalText = document.querySelector('#dot-pane .btn-outline-secondary').textContent;
                    const btn = document.querySelector('#dot-pane .btn-outline-secondary');
                    btn.textContent = 'Copied!';
                    btn.classList.remove('btn-outline-secondary');
                    btn.classList.add('btn-success');
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.classList.remove('btn-success');
                        btn.classList.add('btn-outline-secondary');
                    }, 2000);
                }).catch(() => {
                    // Fallback: select the text
                    dotOutput.select();
                    dotOutput.setSelectionRange(0, 99999);
                });
            }
        }

        function showSpecModal() {
            const modal = new bootstrap.Modal(document.getElementById('specModal'));
            modal.show();
        }

        window.addEventListener('load', function() {
            setupDragDrop();
            setupAutoProcess();
            loadFromUrl();
        });
    </script>
</body>
</html>
