<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipeviz</title>
    <link rel="icon" href="https://raw.githubusercontent.com/mattlianje/d4/master/pix/pipeviz.png">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/@hpcc-js/wasm@2.13.0/dist/graphviz.umd.js"></script>
    <script src="https://unpkg.com/d3-graphviz@5.0.2/build/d3-graphviz.min.js"></script>
    <style>
        :root {
            --bg-primary: #fff;
            --bg-secondary: #f5f5f5;
            --bg-code: #f5f5f5;
            --text-primary: #000;
            --text-secondary: #666;
            --text-muted: #828282;
            --border-color: #ccc;
            --border-light: #eee;
        }
        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #252525;
            --bg-code: #2d2d2d;
            --text-primary: #e0e0e0;
            --text-secondary: #aaa;
            --text-muted: #888;
            --border-color: #444;
            --border-light: #333;
        }
        html {
            overflow-y: scroll;
        }
        body {
            background-color: var(--bg-primary);
            min-height: 100vh;
            font-family: Verdana, Geneva, sans-serif;
            font-size: 13px;
            color: var(--text-primary);
        }
        .hero-section {
            background: var(--bg-primary);
            margin: 1rem auto;
            padding: 1.5rem 4rem;
            max-width: 1600px;
        }
        @media (max-width: 768px) {
            .hero-section {
                padding: 1.5rem 1.5rem;
            }
            .feature-grid {
                grid-template-columns: 1fr !important;
            }
            .feature-tile-centered {
                width: 100% !important;
            }
        }
        .nav-tabs {
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 1.5rem;
        }
        .nav-tabs .nav-link {
            border: none;
            color: var(--text-muted);
            font-weight: 400;
            padding: 6px 12px;
            margin-right: 2px;
            background: transparent;
            border-radius: 0;
            font-size: 12px;
        }
        .nav-tabs .nav-link:hover {
            color: var(--text-primary);
            background-color: var(--bg-secondary);
        }
        .nav-tabs .nav-link.active {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            border-bottom: 2px solid var(--text-primary);
        }
        .nav-tabs.hidden-on-home {
            display: none;
        }
        .card {
            border: none;
            border-radius: 0;
            box-shadow: none;
            background: transparent;
        }
        .card-body {
            padding: 0;
        }
        .table-container {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        .table {
            background: var(--bg-primary);
            font-size: 13px;
            border-collapse: collapse;
            table-layout: fixed;
            width: 100%;
            min-width: 900px;
        }
        .table th {
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            font-weight: bold;
            color: var(--text-primary);
            white-space: nowrap;
            font-size: 11px;
        }
        .table td {
            border-bottom: 1px solid var(--border-light);
            vertical-align: top;
            color: var(--text-primary);
            overflow: hidden;
        }
        .table td > div {
            overflow-x: auto;
        }
        .table .col-sources > div,
        .table .col-tags > div {
            white-space: normal;
        }
        .table .col-sources .badge,
        .table .col-tags .badge {
            display: block;
            width: fit-content;
            margin-bottom: 2px;
        }
        .table tr:last-child td {
            border-bottom: none;
        }
        .table .col-name { width: 200px; }
        .table .col-desc { width: 250px; }
        .table .col-schedule { width: 100px; }
        .table .col-sources { width: 340px; }
        .table .col-cluster { width: 120px; }
        .table .col-tags { width: 160px; }
        .table .col-links { width: 100px; }
        .table .col-owner { width: 180px; }
        .table .col-metadata { width: 200px; }
        .badge {
            font-weight: normal;
            font-size: 11px;
            padding: 2px 5px;
            border-radius: 2px;
            display: inline-block;
            margin-bottom: 2px;
        }
        .badge-snowflake { background-color: #e8f4fd; color: #0366d6; border: 1px solid #0366d6; }
        .badge-delta { background-color: #fff3e0; color: #e65100; border: 1px solid #e65100; }
        .badge-s3 { background-color: #fff8e1; color: #f57c00; border: 1px solid #f57c00; }
        .badge-api { background-color: #e8f5e9; color: #2e7d32; border: 1px solid #2e7d32; }
        .badge-database { background-color: #f3e5f5; color: #7b1fa2; border: 1px solid #7b1fa2; }
        .badge-tag { background-color: #fff3e0; color: #e65100; border: 1px solid #e65100; }
        .badge-cluster { background-color: #e3f2fd; color: #1565c0; border: 1px solid #1565c0; }
        .graph-container {
            background: var(--bg-primary);
            min-height: 500px;
            position: relative;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }
        .graph-container svg {
            max-width: 100%;
        }
        .graph-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        #graph svg {
            width: 100%;
            height: 500px;
        }
        .legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: var(--bg-primary);
            padding: 8px 12px;
            font-size: 11px;
            max-width: 160px;
            opacity: 0.9;
            color: var(--text-primary);
        }
        .json-editor {
            font-family: monospace;
            font-size: 12px;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        .json-editor:focus {
            border-color: var(--text-muted);
            box-shadow: none;
            outline: none;
        }
        .node-highlighted {
            stroke: #e65100 !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 4px rgba(230, 81, 0, 0.4));
        }
        .node-highlighted polygon,
        .node-highlighted ellipse,
        .node-highlighted path {
            fill: #fff3e0 !important;
        }
        .node-highlighted text {
            font-weight: normal !important;
            fill: #000 !important;
            stroke: none !important;
            stroke-width: 0 !important;
        }
        .node-connected {
            stroke: #7b1fa2 !important;
            stroke-width: 1.5px !important;
        }
        .node-connected text {
            font-weight: normal !important;
            fill: #000 !important;
            stroke: none !important;
            stroke-width: 0 !important;
        }
        .node-dimmed {
            opacity: 0.5 !important;
        }
        .edge-highlighted {
            stroke: #7b1fa2 !important;
            stroke-width: 1.5px !important;
        }
        .edge-dimmed {
            opacity: 0.4 !important;
        }
        .cluster-highlighted > polygon,
        .cluster-highlighted > path {
            stroke: #e65100 !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 4px rgba(230, 81, 0, 0.4));
            fill: #fff3e0 !important;
        }
        .cluster-connected > polygon,
        .cluster-connected > path {
            stroke: #7b1fa2 !important;
            stroke-width: 1.5px !important;
        }
        .cluster-dimmed {
            opacity: 0.5 !important;
        }
        .node-tooltip {
            position: absolute;
            background: #000;
            color: #fff;
            padding: 6px 8px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            max-width: 280px;
            white-space: pre-line;
        }
        .node {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .node:hover {
            stroke-width: 2px !important;
            filter: drop-shadow(0 0 4px rgba(0, 0, 0, 0.3));
        }
        .node:hover text {
            font-weight: normal !important;
            fill: #000 !important;
            stroke: none !important;
            stroke-width: 0 !important;
        }
        .node-details-panel {
            background: var(--bg-primary);
            padding: 1rem;
            min-height: 500px;
            max-height: 500px;
            overflow-y: auto;
            overflow-x: auto;
        }
        .node-details-panel .detail-value,
        .node-details-panel .lineage-link {
            white-space: nowrap;
        }
        .node-details-panel h5 {
            color: var(--text-primary);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            font-weight: bold;
            font-size: 13px;
        }
        .node-details-panel .detail-label {
            font-size: 10px;
            color: var(--text-muted);
            font-weight: bold;
            margin-bottom: 0.25rem;
        }
        .node-details-panel .detail-value {
            margin-bottom: 1rem;
            font-size: 12px;
            color: var(--text-primary);
        }
        .lineage-link {
            margin-bottom: 4px;
            cursor: pointer;
            color: #0366d6;
        }
        .lineage-link:hover {
            text-decoration: underline;
        }
        [data-theme="dark"] .lineage-link {
            color: #58a6ff;
        }
        .node-details-panel .detail-value:last-child {
            margin-bottom: 0;
        }
        .node-details-panel .links-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #eee;
        }
        .node-details-panel .link-btn {
            display: inline-block;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
            border-color: var(--border-color);
            color: var(--text-secondary);
            background: var(--bg-secondary);
        }
        .node-details-panel .link-btn:hover {
            background-color: var(--text-secondary);
            border-color: var(--text-secondary);
            color: var(--bg-primary);
        }
        [data-theme="dark"] .node-details-panel .link-btn {
            border-color: #666;
            color: #ccc;
            background: #333;
        }
        [data-theme="dark"] .node-details-panel .link-btn:hover {
            background-color: #888;
            border-color: #888;
            color: #fff;
        }
        .search-results-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-top: none;
            max-height: 300px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }
        .search-results-dropdown.show {
            display: block;
        }
        .search-result-item {
            padding: 6px 10px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--text-primary);
        }
        .search-result-item:last-child {
            border-bottom: none;
        }
        .search-result-item:hover,
        .search-result-item.selected {
            background-color: var(--bg-secondary);
        }
        .search-result-item .result-type {
            font-size: 9px;
            padding: 2px 4px;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .search-result-item .result-type.pipeline {
            background-color: #e3f2fd;
            color: #1565c0;
            border: 1px solid #1565c0;
        }
        .search-result-item .result-type.datasource {
            background-color: #f3e5f5;
            color: #7b1fa2;
            border: 1px solid #7b1fa2;
        }
        .search-result-item .result-name {
            font-weight: 400;
        }
        .search-result-item .result-match {
            color: #d84315;
            font-weight: 600;
        }
        .btn {
            border-radius: 0;
            font-size: 12px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .btn-primary {
            background-color: #333;
            border-color: #333;
            color: #fff;
        }
        .btn-primary:hover {
            background-color: #000;
            border-color: #000;
            color: #fff;
        }
        .btn-outline-primary {
            color: #333;
            border-color: #333;
        }
        .btn-outline-primary:hover {
            background-color: #333;
            border-color: #333;
            color: #fff;
        }
        .btn-outline-secondary {
            color: #666;
            border-color: #999;
        }
        .btn-outline-secondary:hover {
            background-color: #666;
            border-color: #666;
            color: #fff;
        }
        .btn-outline-warning {
            color: #b45309;
            border-color: #b45309;
        }
        .btn-outline-warning:hover {
            background-color: #b45309;
            border-color: #b45309;
            color: #fff;
        }
        .btn-outline-info {
            color: #0369a1;
            border-color: #0369a1;
        }
        .btn-outline-info:hover {
            background-color: #0369a1;
            border-color: #0369a1;
            color: #fff;
        }
        .hero-title {
            color: var(--text-primary);
            font-weight: bold;
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            letter-spacing: -0.5px;
        }
        .header-controls {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 12px;
            margin-bottom: 0.5rem;
        }
        .link-icon {
            text-decoration: none;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 12px;
            margin: 2px;
            display: inline-block;
        }
        .link-icon:hover {
            background: #555;
            border-color: #555;
            color: #fff;
        }
        [data-theme="dark"] .link-icon {
            background: #333;
            border-color: #555;
            color: #ccc;
        }
        [data-theme="dark"] .link-icon:hover {
            background: #666;
            border-color: #666;
            color: #fff;
        }
        .form-control, .form-select {
            border-radius: 0;
            border: 1px solid var(--border-color);
            font-size: 13px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        .form-control:focus, .form-select:focus {
            border-color: var(--text-muted);
            box-shadow: none;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        .form-control::placeholder {
            color: var(--text-muted);
        }
        .alert {
            border-radius: 0;
            font-size: 13px;
        }
        .alert-info {
            background-color: #f5f5f5;
            border: 1px solid #ccc;
            color: #333;
        }
        .alert-success {
            background-color: #e8f5e9;
            border: 1px solid #4caf50;
            color: #2e7d32;
        }
        .alert-danger {
            background-color: #ffebee;
            border: 1px solid #f44336;
            color: #c62828;
        }
        .alert-warning {
            background-color: #fff8e1;
            border: 1px solid #ff9800;
            color: #e65100;
        }
        .text-muted {
            color: var(--text-secondary) !important;
        }
        .lead {
            color: var(--text-muted);
            font-size: 12px;
        }
        .theme-toggle {
            background: none;
            border: 1px solid var(--border-color);
            padding: 4px 8px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 0;
        }
        .theme-toggle:hover {
            background: var(--bg-secondary);
        }
        .drop-zone {
            position: relative;
            border: 1px dashed #999;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .drop-zone:hover {
            border-color: #333;
            background-color: #fafafa;
        }
        .drop-zone.dragover {
            border-color: #333;
            background-color: #f0f0f0;
            border-style: solid;
        }
        .modal-content {
            border-radius: 0;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        .modal-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 0.75rem 1rem;
        }
        .modal-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .modal-body {
            font-size: 13px;
            color: var(--text-primary);
        }
        .modal-body pre {
            background: #1a1a1a;
            color: #f0f0f0;
            padding: 12px;
            font-size: 12px;
            border: none;
            border-radius: 0;
        }
        .modal-body code {
            color: #d63384;
            background: var(--bg-code);
            padding: 1px 4px;
            font-size: 11px;
        }
        .modal-footer {
            border-top: 1px solid var(--border-color);
            padding: 0.5rem 1rem;
        }
        code {
            font-family: monospace;
            font-size: 12px;
        }
        .filter-tag {
            display: inline-block;
            padding: 2px 8px;
            margin: 2px;
            font-size: 11px;
            cursor: pointer;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
        }
        .filter-tag:hover {
            border-color: var(--text-muted);
            color: var(--text-primary);
        }
        .filter-tag.active {
            background: var(--text-primary);
            border-color: var(--text-primary);
            color: var(--bg-primary);
        }
        .filter-group {
            display: inline-block;
            margin-right: 1rem;
        }
        .filter-group-label {
            font-size: 10px;
            color: var(--text-muted);
            margin-right: 4px;
        }
        /* Dark mode graph text fix */
        [data-theme="dark"] #graph text,
        [data-theme="dark"] #splash-graph text,
        [data-theme="dark"] #attribute-graph text {
            fill: #e0e0e0 !important;
        }
        [data-theme="dark"] #graph .node text,
        [data-theme="dark"] #splash-graph .node text,
        [data-theme="dark"] #attribute-graph .node text {
            fill: #000 !important;
        }
        [data-theme="dark"] #graph .graph > polygon,
        [data-theme="dark"] #splash-graph .graph > polygon,
        [data-theme="dark"] #attribute-graph .graph > polygon {
            fill: transparent !important;
        }
        [data-theme="dark"] #graph .cluster > polygon,
        [data-theme="dark"] #graph .cluster > path,
        [data-theme="dark"] #attribute-graph .cluster > polygon,
        [data-theme="dark"] #attribute-graph .cluster > path {
            fill: #2a2a2a !important;
            stroke: #555 !important;
        }
        [data-theme="dark"] #graph .cluster text,
        [data-theme="dark"] #attribute-graph .cluster text {
            fill: #e0e0e0 !important;
        }
        /* Dark mode Bootstrap table overrides */
        [data-theme="dark"] .table {
            --bs-table-bg: var(--bg-primary);
            --bs-table-striped-bg: var(--bg-secondary);
            --bs-table-hover-bg: #333;
            --bs-table-color: var(--text-primary);
            --bs-table-striped-color: var(--text-primary);
            --bs-table-hover-color: var(--text-primary);
            color: var(--text-primary);
            border-color: var(--border-color);
        }
        [data-theme="dark"] .table > :not(caption) > * > * {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            border-bottom-color: var(--border-light);
        }
        [data-theme="dark"] .table-striped > tbody > tr:nth-of-type(odd) > * {
            background-color: var(--bg-secondary);
        }
        [data-theme="dark"] .table th {
            background-color: #252525 !important;
            color: #e0e0e0 !important;
        }
        /* Dark mode for table link buttons */
        [data-theme="dark"] .table .btn-outline-primary {
            border-color: #666;
            color: #aaa;
        }
        [data-theme="dark"] .table .btn-outline-primary:hover {
            background-color: #555;
            border-color: #555;
            color: #fff;
        }
        /* Hero fade-in animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(12px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .hero-animate {
            opacity: 0;
            animation: fadeInUp 0.5s ease-out forwards;
        }
        .hero-animate-1 { animation-delay: 0.1s; }
        .hero-animate-2 { animation-delay: 0.3s; }
        .hero-animate-3 { animation-delay: 0.5s; }
        .hero-animate-4 { animation-delay: 0.7s; }
        /* Feature tiles grid */
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 2.5rem;
        }
        @media (max-width: 992px) {
            .feature-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (max-width: 576px) {
            .feature-grid {
                grid-template-columns: 1fr;
            }
            .feature-tile {
                padding: 1rem 1.25rem;
            }
        }
        /* Feature tiles */
        .feature-tile {
            padding: 0.875rem;
            background: var(--bg-secondary);
        }
        .feature-icon {
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }
    </style>
  <script type="module" crossorigin>(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function renderSplashGraph() {
  const isDark = document.documentElement.getAttribute("data-theme") === "dark";
  const textColor = isDark ? "#e0e0e0" : "#000000";
  const dot = `digraph {
        rankdir=LR
        bgcolor="transparent"
        node [fontname="Arial" fontsize="10" fontcolor="${textColor}"]
        edge [color="#999999"]
        "raw_events" [shape=ellipse style=filled fillcolor="#f3e5f5" color="#7b1fa2"]
        "etl-job" [shape=box style="filled,rounded" fillcolor="#e3f2fd" color="#1976d2" fontname="Arial"]
        "cleaned_events" [shape=ellipse style=filled fillcolor="#f3e5f5" color="#7b1fa2"]
        "raw_events" -> "etl-job"
        "etl-job" -> "cleaned_events"
    }`;
  d3.select("#splash-graph").graphviz().width(260).height(110).fit(true).renderDot(dot);
}
const state = {
  currentConfig: null,
  lastRenderedConfigHash: null,
  graphviz: null,
  groupedView: true,
  pipelinesOnlyView: false,
  expandedGroups: /* @__PURE__ */ new Set(),
  selectedNode: null,
  // Cached lineage maps for performance
  cachedUpstreamMap: {},
  cachedDownstreamMap: {},
  cachedLineage: {},
  // Attribute graph state
  attributeGraphviz: null,
  attributeLastRenderedConfigHash: null,
  nestedClusterCount: 0,
  attributeLineageMap: {},
  datasourceLineageMap: {},
  selectedAttribute: null
};
function getConfigHash(config) {
  return JSON.stringify(config);
}
const exampleConfig = {
  "clusters": [
    {
      "name": "user-processing",
      "description": "User data processing and enrichment cluster"
    },
    {
      "name": "order-management",
      "description": "Order processing and validation cluster"
    },
    {
      "name": "real-time",
      "description": "Real-time streaming data cluster",
      "parent": "order-management"
    },
    {
      "name": "analytics",
      "description": "Analytics and reporting cluster"
    }
  ],
  "pipelines": [
    {
      "name": "user-enrichment",
      "description": "Enriches user data with behavioral signals and ML features",
      "input_sources": ["raw_users", "user_events"],
      "output_sources": ["enriched_users"],
      "schedule": "Every 2 hours",
      "tags": ["user-data", "ml", "enrichment"],
      "cluster": "user-processing",
      "links": {
        "airflow": "https://airflow.company.com/dags/user_enrichment",
        "monitoring": "https://grafana.company.com/d/user-enrichment",
        "docs": "https://docs.company.com/pipelines/user-enrichment"
      },
      "upstream_pipelines": []
    },
    {
      "name": "order-processing",
      "description": "Validates and processes incoming orders in real-time",
      "input_sources": ["raw_orders", "inventory"],
      "output_sources": ["processed_orders", "order_audit"],
      "schedule": "Every 15 minutes",
      "tags": ["orders", "real-time", "validation"],
      "cluster": "real-time",
      "links": {
        "airflow": "https://airflow.company.com/dags/order_processing",
        "monitoring": "https://grafana.company.com/d/orders",
        "alerts": "https://pagerduty.company.com/services/orders"
      },
      "upstream_pipelines": []
    },
    {
      "name": "analytics-aggregation",
      "description": "Daily aggregation of user metrics and business KPIs",
      "input_sources": ["enriched_users", "processed_orders", "user_events"],
      "output_sources": ["daily_metrics", "user_cohorts"],
      "schedule": "Daily at 1:00 AM",
      "tags": ["analytics", "aggregation", "daily"],
      "cluster": "analytics",
      "links": {
        "airflow": "https://airflow.company.com/dags/analytics_agg",
        "dashboard": "https://tableau.company.com/analytics-dashboard"
      },
      "upstream_pipelines": ["user-enrichment", "order-processing"]
    },
    {
      "name": "export-to-salesforce",
      "description": "Sync user cohorts to Salesforce",
      "input_sources": ["user_cohorts"],
      "output_sources": ["salesforce_users"],
      "group": "data-exports",
      "cluster": "analytics",
      "upstream_pipelines": ["analytics-aggregation"]
    },
    {
      "name": "export-to-hubspot",
      "description": "Sync user cohorts to HubSpot",
      "input_sources": ["user_cohorts"],
      "output_sources": ["hubspot_contacts"],
      "group": "data-exports",
      "cluster": "analytics",
      "upstream_pipelines": ["analytics-aggregation"]
    },
    {
      "name": "export-to-amplitude",
      "description": "Sync daily metrics to Amplitude",
      "input_sources": ["daily_metrics"],
      "output_sources": ["amplitude_events"],
      "group": "data-exports",
      "cluster": "analytics",
      "upstream_pipelines": ["analytics-aggregation"]
    },
    {
      "name": "weekly-rollup",
      "description": "Aggregate daily metrics into weekly executive summary",
      "input_sources": ["daily_metrics", "enriched_users"],
      "output_sources": ["executive_summary"],
      "schedule": "0 6 * * MON",
      "cluster": "analytics",
      "upstream_pipelines": ["analytics-aggregation", "user-enrichment"]
    }
  ],
  "datasources": [
    {
      "name": "raw_users",
      "description": "Raw user registration and profile data from production database",
      "type": "snowflake",
      "owner": "data-platform@company.com",
      "tags": ["pii", "users", "core-data"],
      "cluster": "user-processing",
      "attributes": [
        { "name": "id" },
        { "name": "first_name" },
        { "name": "last_name" },
        { "name": "email" },
        { "name": "signup_date" },
        {
          "name": "address",
          "attributes": [
            { "name": "city" },
            { "name": "zip" },
            {
              "name": "geo",
              "attributes": [
                { "name": "lat" },
                { "name": "lng" }
              ]
            }
          ]
        }
      ],
      "metadata": {
        "schema": "RAW_DATA",
        "table": "USERS",
        "size": "2.1TB",
        "record_count": "45M",
        "refresh_frequency": "real-time"
      },
      "links": {
        "snowflake": "https://company.snowflakecomputing.com/console#/data/databases/PROD/schemas/RAW_DATA/table/USERS",
        "monitoring": "https://grafana.company.com/d/raw-users",
        "docs": "https://docs.company.com/schemas/raw_users"
      }
    },
    {
      "name": "user_events",
      "description": "Clickstream and interaction events from all digital touchpoints",
      "type": "s3",
      "owner": "analytics-team@company.com",
      "tags": ["events", "clickstream", "large-dataset"],
      "cluster": "analytics",
      "attributes": [
        { "name": "event_id" },
        { "name": "user_id", "from": "raw_users::id" },
        { "name": "event_type" },
        { "name": "page_url" },
        { "name": "timestamp" }
      ],
      "metadata": {
        "bucket": "company-events-prod",
        "size": "15TB",
        "record_count": "2.5B",
        "file_format": "parquet"
      },
      "links": {
        "s3": "https://s3.console.aws.amazon.com/s3/buckets/company-events-prod",
        "athena": "https://console.aws.amazon.com/athena/home#query"
      }
    },
    {
      "name": "raw_orders",
      "description": "Real-time order data from e-commerce platform",
      "type": "api",
      "owner": "platform-team@company.com",
      "tags": ["orders", "real-time", "revenue"],
      "cluster": "real-time",
      "metadata": {
        "endpoint": "https://api.company.com/v2/orders",
        "rate_limit": "1000 req/min",
        "record_count": "120M"
      },
      "links": {
        "api_docs": "https://docs.company.com/api/orders",
        "monitoring": "https://grafana.company.com/d/orders-api"
      }
    },
    {
      "name": "inventory",
      "description": "Product inventory levels across all warehouses",
      "type": "snowflake",
      "owner": "supply-chain@company.com",
      "tags": ["inventory", "warehouse", "operational"],
      "cluster": "order-management",
      "metadata": {
        "schema": "INVENTORY",
        "size": "150GB",
        "refresh_frequency": "every 15 minutes"
      },
      "links": {
        "snowflake": "https://company.snowflakecomputing.com/console#/data/databases/PROD/schemas/INVENTORY",
        "tableau": "https://tableau.company.com/views/inventory-dashboard"
      }
    },
    {
      "name": "enriched_users",
      "description": "Enriched user profiles with behavioral features",
      "type": "delta",
      "owner": "data-platform@company.com",
      "tags": ["users", "enriched", "ml-ready"],
      "cluster": "user-processing",
      "attributes": [
        { "name": "user_id", "from": "raw_users::id" },
        { "name": "full_name", "from": ["raw_users::first_name", "raw_users::last_name"] },
        { "name": "email", "from": "raw_users::email" },
        { "name": "event_count", "from": "user_events::event_id" },
        { "name": "last_active", "from": "user_events::timestamp" },
        { "name": "signup_date", "from": "raw_users::signup_date" },
        {
          "name": "location",
          "from": "raw_users::address",
          "attributes": [
            { "name": "city", "from": "raw_users::address::city" },
            { "name": "zip", "from": "raw_users::address::zip" },
            { "name": "coords", "from": "raw_users::address::geo" }
          ]
        }
      ]
    },
    {
      "name": "daily_metrics",
      "description": "Aggregated daily business metrics",
      "type": "snowflake",
      "owner": "analytics-team@company.com",
      "tags": ["metrics", "daily", "kpi"],
      "cluster": "analytics",
      "attributes": [
        { "name": "date" },
        { "name": "active_users", "from": "enriched_users::user_id" },
        { "name": "total_events", "from": "user_events::event_id" }
      ]
    },
    {
      "name": "executive_summary",
      "description": "Weekly executive dashboard metrics",
      "type": "snowflake",
      "cluster": "analytics",
      "attributes": [
        { "name": "week" },
        { "name": "weekly_active_users", "from": "daily_metrics::active_users" },
        { "name": "weekly_events", "from": "daily_metrics::total_events" },
        { "name": "user_growth", "from": ["daily_metrics::active_users", "enriched_users::signup_date"] }
      ]
    },
    {
      "name": "user_cohorts",
      "description": "User segmentation and cohort definitions",
      "type": "snowflake",
      "cluster": "analytics"
    },
    {
      "name": "salesforce_users",
      "description": "User data synced to Salesforce CRM",
      "type": "api",
      "cluster": "analytics"
    },
    {
      "name": "hubspot_contacts",
      "description": "Contact data synced to HubSpot",
      "type": "api",
      "cluster": "analytics"
    },
    {
      "name": "amplitude_events",
      "description": "Product analytics events sent to Amplitude",
      "type": "api",
      "cluster": "analytics"
    }
  ]
};
function generateAttributeDot() {
  if (!state.currentConfig) return "";
  const datasources = state.currentConfig.datasources || [];
  document.documentElement.getAttribute("data-theme") === "dark";
  const textColor = "#334155";
  const clusterBg = "#f1f5f9";
  const attrFill = "#ffffff";
  const attrBorder = "#94a3b8";
  let dot = `digraph AttributeLineage {
    rankdir=LR
    bgcolor="transparent"
    compound=true
    nodesep=0.15
    node [fontname="Arial" fontsize="10"]
    edge [fontsize="9" color="#94a3b8" arrowsize="0.6"]

`;
  const sourceRefs = /* @__PURE__ */ new Set();
  function collectSourceRefs(attrs) {
    attrs.forEach((attr) => {
      if (attr.from) {
        const sources = Array.isArray(attr.from) ? attr.from : [attr.from];
        sources.forEach((s) => sourceRefs.add(s));
      }
      if (attr.attributes) collectSourceRefs(attr.attributes);
    });
  }
  datasources.forEach((ds) => {
    if (ds.attributes) collectSourceRefs(ds.attributes);
  });
  function isSourceRef(dsName, attrPath) {
    const ref = `${dsName}::${attrPath.replace(/__/g, "::")}`;
    return sourceRefs.has(ref);
  }
  const structAttrs = /* @__PURE__ */ new Set();
  state.nestedClusterCount = 0;
  function renderAttributes(attrs, dsName, dsId, prefix = "", depth = 0) {
    let result = "";
    attrs.forEach((attr) => {
      const attrPath = prefix ? `${prefix}__${attr.name}` : attr.name;
      const attrId = `${dsId}__${attrPath.replace(/[^a-zA-Z0-9_]/g, "_")}`;
      const hasUpstream = attr.from ? true : false;
      const hasDownstream = isSourceRef(dsName, attrPath);
      const hasLineage = hasUpstream || hasDownstream;
      const hasChildren = attr.attributes && attr.attributes.length > 0;
      if (hasChildren) {
        structAttrs.add(attrId);
        state.nestedClusterCount++;
        const clusterId = `cluster_${attrId}`;
        const nestedBg = hasLineage ? "#dde5ed" : depth === 0 ? "#e8eef4" : "#dce4ec";
        result += `        subgraph ${clusterId} {
                    label="${attr.name}"
                    labelloc="t"
                    style=filled
                    fillcolor="${nestedBg}"
                    fontcolor="${hasLineage ? "#7b1fa2" : textColor}"
                    color="${hasLineage ? "#7b1fa2" : attrBorder}"
                    fontname="Arial"
                    fontsize="9"
                    margin="8"
`;
        result += `            "${attrId}" [label="" shape=point width=0 height=0 fixedsize=true style=invis];
`;
        result += renderAttributes(attr.attributes, dsName, dsId, attrPath, depth + 1);
        result += `                        }
`;
      } else {
        const fill = hasLineage ? "#e2e8f0" : attrFill;
        result += `            "${attrId}" [label="${attr.name}" shape=box style="filled,rounded" fillcolor="${fill}" color="${attrBorder}" fontcolor="${textColor}" fontsize="9" height="0.3"];
`;
      }
    });
    return result;
  }
  function collectLineage(attrs, dsId, prefix = "") {
    let edges = [];
    attrs.forEach((attr) => {
      const attrPath = prefix ? `${prefix}__${attr.name}` : attr.name;
      const targetId = `${dsId}__${attrPath.replace(/[^a-zA-Z0-9_]/g, "_")}`;
      const targetIsStruct = structAttrs.has(targetId);
      if (attr.from) {
        const sources = Array.isArray(attr.from) ? attr.from : [attr.from];
        sources.forEach((source) => {
          const parts = source.split("::");
          if (parts.length >= 2) {
            const sourceDs = parts[0].replace(/[^a-zA-Z0-9]/g, "_");
            const sourcePath = parts.slice(1).join("__").replace(/[^a-zA-Z0-9_]/g, "_");
            const sourceId = `${sourceDs}__${sourcePath}`;
            const sourceIsStruct = structAttrs.has(sourceId);
            let edgeAttrs = ['color="#7b1fa2"'];
            if (sourceIsStruct) {
              edgeAttrs.push(`ltail="cluster_${sourceId}"`);
            }
            if (targetIsStruct) {
              edgeAttrs.push(`lhead="cluster_${targetId}"`);
            }
            edges.push(`    "${sourceId}" -> "${targetId}" [${edgeAttrs.join(" ")}];
`);
          }
        });
      }
      if (attr.attributes && attr.attributes.length > 0) {
        edges = edges.concat(collectLineage(attr.attributes, dsId, attrPath));
      }
    });
    return edges;
  }
  datasources.forEach((ds) => {
    if (!ds.attributes || ds.attributes.length === 0) return;
    const dsId = ds.name.replace(/[^a-zA-Z0-9]/g, "_");
    dot += `    subgraph cluster_${dsId} {
        label="${ds.name}"
        style=filled
        fillcolor="${clusterBg}"
        fontcolor="${textColor}"
        color="${attrBorder}"
        fontname="Arial"
        fontsize="11"

`;
    dot += renderAttributes(ds.attributes, ds.name, dsId);
    dot += `    }

`;
  });
  datasources.forEach((ds) => {
    if (!ds.attributes) return;
    const dsId = ds.name.replace(/[^a-zA-Z0-9]/g, "_");
    const edges = collectLineage(ds.attributes, dsId);
    edges.forEach((edge) => {
      dot += edge;
    });
  });
  dot += `}`;
  return dot;
}
function renderAttributeGraph() {
  if (!state.currentConfig) return;
  const dot = generateAttributeDot();
  if (!dot) return;
  if (!state.attributeGraphviz) {
    document.getElementById("attribute-graph").innerHTML = "";
    state.attributeGraphviz = d3.select("#attribute-graph").graphviz().width(document.getElementById("attribute-graph").offsetWidth || 800).height(500).fit(true).zoom(true);
  }
  state.attributeGraphviz.renderDot(dot).on("end", function() {
    d3.select("#attribute-graph").selectAll(".node").on("click", function(event) {
      event.stopPropagation();
      const title = d3.select(this).select("title").text();
      if (title && state.attributeLineageMap[title]) {
        selectAttribute(title);
      }
    });
    d3.select("#attribute-graph").selectAll(".cluster").on("click", function(event) {
      event.stopPropagation();
      const title = d3.select(this).select("title").text();
      if (title && title.startsWith("cluster_")) {
        const id = title.substring(8);
        if (id.includes("__") && state.attributeLineageMap[id]) {
          selectAttribute(id);
        } else {
          const ds = (state.currentConfig.datasources || []).find(
            (d) => d.name.replace(/[^a-zA-Z0-9]/g, "_") === id
          );
          if (ds) showDatasourceInAttributePanel(ds);
        }
      }
    });
    d3.select("#attribute-graph svg").on("click", function(event) {
      if (event.target.tagName === "svg" || event.target.classList.contains("graph")) {
        clearAttributeSelection();
      }
    });
  });
}
function resetAttributeGraph() {
  if (state.attributeGraphviz) state.attributeGraphviz.resetZoom();
}
function buildAttributeLineageMap() {
  state.attributeLineageMap = {};
  if (!state.currentConfig) return;
  const datasources = state.currentConfig.datasources || [];
  function registerAttributes(attrs, dsName, dsId, prefix = "") {
    attrs.forEach((attr) => {
      const attrPath = prefix ? `${prefix}__${attr.name}` : attr.name;
      const attrId = `${dsId}__${attrPath.replace(/[^a-zA-Z0-9_]/g, "_")}`;
      const fullName = prefix ? `${dsName}::${prefix.replace(/__/g, "::")}::${attr.name}` : `${dsName}::${attr.name}`;
      state.attributeLineageMap[attrId] = {
        id: attrId,
        name: attr.name,
        datasource: dsName,
        fullName,
        upstream: [],
        downstream: []
      };
      if (attr.attributes && attr.attributes.length > 0) {
        registerAttributes(attr.attributes, dsName, dsId, attrPath);
      }
    });
  }
  function collectAttributeLineage(attrs, dsId, prefix = "") {
    attrs.forEach((attr) => {
      const attrPath = prefix ? `${prefix}__${attr.name}` : attr.name;
      const targetId = `${dsId}__${attrPath.replace(/[^a-zA-Z0-9_]/g, "_")}`;
      if (attr.from) {
        const sources = Array.isArray(attr.from) ? attr.from : [attr.from];
        sources.forEach((source) => {
          const parts = source.split("::");
          if (parts.length >= 2) {
            const sourceDs = parts[0].replace(/[^a-zA-Z0-9]/g, "_");
            const sourcePath = parts.slice(1).join("__").replace(/[^a-zA-Z0-9_]/g, "_");
            const sourceId = `${sourceDs}__${sourcePath}`;
            if (state.attributeLineageMap[targetId]) {
              state.attributeLineageMap[targetId].upstream.push(sourceId);
            }
            if (state.attributeLineageMap[sourceId]) {
              state.attributeLineageMap[sourceId].downstream.push(targetId);
            }
          }
        });
      }
      if (attr.attributes && attr.attributes.length > 0) {
        collectAttributeLineage(attr.attributes, dsId, attrPath);
      }
    });
  }
  datasources.forEach((ds) => {
    if (!ds.attributes) return;
    const dsId = ds.name.replace(/[^a-zA-Z0-9]/g, "_");
    registerAttributes(ds.attributes, ds.name, dsId);
  });
  datasources.forEach((ds) => {
    if (!ds.attributes) return;
    const dsId = ds.name.replace(/[^a-zA-Z0-9]/g, "_");
    collectAttributeLineage(ds.attributes, dsId);
  });
  function computeFullChain(attrId, direction, visited = /* @__PURE__ */ new Set(), depth = 1) {
    if (visited.has(attrId)) return [];
    visited.add(attrId);
    const attr = state.attributeLineageMap[attrId];
    if (!attr) return [];
    const next = direction === "upstream" ? attr.upstream : attr.downstream;
    let result = [];
    next.forEach((nextId) => {
      result.push({ id: nextId, depth });
      result.push(...computeFullChain(nextId, direction, visited, depth + 1));
    });
    return result;
  }
  Object.keys(state.attributeLineageMap).forEach((attrId) => {
    state.attributeLineageMap[attrId].fullUpstream = computeFullChain(attrId, "upstream", /* @__PURE__ */ new Set());
    state.attributeLineageMap[attrId].fullDownstream = computeFullChain(attrId, "downstream", /* @__PURE__ */ new Set());
  });
  var dsDirectUpstream = {};
  var dsDirectDownstream = {};
  datasources.forEach(function(ds) {
    var id = ds.name.replace(/[^a-zA-Z0-9]/g, "_");
    dsDirectUpstream[id] = /* @__PURE__ */ new Set();
    dsDirectDownstream[id] = /* @__PURE__ */ new Set();
  });
  Object.values(state.attributeLineageMap).forEach(function(attr) {
    if (!attr || !attr.datasource) return;
    var dsId = attr.datasource.replace(/[^a-zA-Z0-9]/g, "_");
    var upIds = attr.upstream || [];
    for (var i = 0; i < upIds.length; i++) {
      var upDs = upIds[i].split("__")[0];
      if (upDs && upDs !== dsId && dsDirectUpstream[dsId]) {
        dsDirectUpstream[dsId].add(upDs);
      }
    }
    var downIds = attr.downstream || [];
    for (var j = 0; j < downIds.length; j++) {
      var downDs = downIds[j].split("__")[0];
      if (downDs && downDs !== dsId && dsDirectDownstream[dsId]) {
        dsDirectDownstream[dsId].add(downDs);
      }
    }
  });
  function bfsProvenance(startId, getNeighbors) {
    var result = [];
    var visited = /* @__PURE__ */ new Set([startId]);
    var queue = [];
    var neighbors = getNeighbors(startId);
    neighbors.forEach(function(id) {
      queue.push({ id, depth: 1 });
      visited.add(id);
    });
    while (queue.length > 0) {
      var item = queue.shift();
      result.push(item);
      var next = getNeighbors(item.id);
      next.forEach(function(nextId) {
        if (!visited.has(nextId)) {
          visited.add(nextId);
          queue.push({ id: nextId, depth: item.depth + 1 });
        }
      });
    }
    result.sort(function(a, b) {
      return a.depth - b.depth;
    });
    return result;
  }
  state.datasourceLineageMap = {};
  datasources.forEach(function(ds) {
    var id = ds.name.replace(/[^a-zA-Z0-9]/g, "_");
    state.datasourceLineageMap[id] = {
      name: ds.name,
      upstream: bfsProvenance(id, function(x) {
        return dsDirectUpstream[x] || /* @__PURE__ */ new Set();
      }),
      downstream: bfsProvenance(id, function(x) {
        return dsDirectDownstream[x] || /* @__PURE__ */ new Set();
      })
    };
  });
}
function selectAttribute(attrId) {
  state.selectedAttribute = attrId;
  const attr = state.attributeLineageMap[attrId];
  if (!attr) return;
  d3.select("#attribute-graph").selectAll(".node").classed("node-highlighted", false).classed("node-connected", false).classed("node-dimmed", false);
  d3.select("#attribute-graph").selectAll(".cluster").classed("cluster-highlighted", false).classed("cluster-connected", false).classed("cluster-dimmed", false);
  d3.select("#attribute-graph").selectAll(".edge").classed("edge-highlighted", false).classed("edge-dimmed", false);
  const upstream = attr.fullUpstream || [];
  const downstream = attr.fullDownstream || [];
  const allConnected = /* @__PURE__ */ new Set([attrId, ...upstream.map((x) => x.id), ...downstream.map((x) => x.id)]);
  d3.select("#attribute-graph").selectAll(".node").each(function() {
    const node = d3.select(this);
    const title = node.select("title").text();
    if (title === attrId) {
      node.classed("node-highlighted", true).classed("node-dimmed", false);
    } else if (allConnected.has(title)) {
      node.classed("node-connected", true).classed("node-dimmed", false);
    } else {
      node.classed("node-dimmed", true);
    }
  });
  d3.select("#attribute-graph").selectAll(".cluster").each(function() {
    const cluster = d3.select(this);
    const title = cluster.select("title").text();
    if (title && title.startsWith("cluster_")) {
      const clusterId = title.substring(8);
      if (clusterId === attrId) {
        cluster.classed("cluster-highlighted", true).classed("cluster-dimmed", false);
      } else if (allConnected.has(clusterId)) {
        cluster.classed("cluster-connected", true).classed("cluster-dimmed", false);
      } else {
        cluster.classed("cluster-dimmed", true);
      }
    }
  });
  d3.select("#attribute-graph").selectAll(".edge").each(function() {
    const edge = d3.select(this);
    const title = edge.select("title").text();
    const [from, to] = title.split("->").map((s) => s.trim());
    if (allConnected.has(from) && allConnected.has(to)) {
      edge.classed("edge-highlighted", true).classed("edge-dimmed", false);
    } else {
      edge.classed("edge-dimmed", true);
    }
  });
  showAttributeDetails(attrId, upstream, downstream);
}
function showAttributeDetails(attrId, upstream, downstream) {
  const attr = state.attributeLineageMap[attrId];
  if (!attr) return;
  const col = document.getElementById("attribute-details-col");
  const graphCol = document.getElementById("attribute-graph-col");
  const content = document.getElementById("attribute-details-content");
  graphCol.classList.remove("col-md-12");
  graphCol.classList.add("col-md-8");
  col.style.display = "block";
  setTimeout(() => {
    if (state.attributeGraphviz) state.attributeGraphviz.fit(true);
  }, 50);
  let html = `<h5>${attr.name}</h5>`;
  html += `<div class="detail-label">DATASOURCE</div>`;
  html += `<div class="detail-value">${attr.datasource}</div>`;
  const childPrefix = attrId + "__";
  const children = Object.keys(state.attributeLineageMap).filter((id) => id.startsWith(childPrefix)).map((id) => {
    const child = state.attributeLineageMap[id];
    const relativePath = id.substring(childPrefix.length);
    const depth = (relativePath.match(/__/g) || []).length;
    return { id, name: child.name, relativePath, depth };
  }).sort((a, b) => a.relativePath.localeCompare(b.relativePath));
  if (children.length > 0) {
    html += `<div class="detail-label">CONTAINS (${children.length})</div>`;
    html += `<div class="detail-value">`;
    children.forEach((child) => {
      const indent = child.depth * 12;
      html += `<div class="lineage-link" data-attr-id="${child.id}" style="padding-left: ${indent}px;">${child.relativePath.replace(/__/g, ".")}</div>`;
    });
    html += `</div>`;
  }
  function dedupeAndSort(items) {
    const seen = /* @__PURE__ */ new Map();
    items.forEach((x) => {
      if (!seen.has(x.id) || seen.get(x.id).depth > x.depth) {
        seen.set(x.id, x);
      }
    });
    return [...seen.values()].sort((a, b) => a.depth - b.depth);
  }
  const sortedUpstream = dedupeAndSort(upstream);
  const sortedDownstream = dedupeAndSort(downstream);
  if (sortedUpstream.length > 0) {
    html += `<div class="detail-label">UPSTREAM (${sortedUpstream.length})</div>`;
    html += `<div class="detail-value">`;
    sortedUpstream.forEach((x) => {
      const upAttr = state.attributeLineageMap[x.id];
      if (upAttr) {
        const indent = (x.depth - 1) * 12;
        const opacity = Math.max(0.5, 1 - (x.depth - 1) * 0.15);
        const prefix = x.depth > 1 ? " " : "";
        html += `<div class="lineage-link" data-attr-id="${x.id}" style="padding-left: ${indent}px; opacity: ${opacity};">${prefix}${upAttr.fullName}</div>`;
      }
    });
    html += `</div>`;
  }
  if (sortedDownstream.length > 0) {
    html += `<div class="detail-label">DOWNSTREAM (${sortedDownstream.length})</div>`;
    html += `<div class="detail-value">`;
    sortedDownstream.forEach((x) => {
      const downAttr = state.attributeLineageMap[x.id];
      if (downAttr) {
        const indent = (x.depth - 1) * 12;
        const opacity = Math.max(0.5, 1 - (x.depth - 1) * 0.15);
        const prefix = x.depth > 1 ? " " : "";
        html += `<div class="lineage-link" data-attr-id="${x.id}" style="padding-left: ${indent}px; opacity: ${opacity};">${prefix}${downAttr.fullName}</div>`;
      }
    });
    html += `</div>`;
  }
  if (sortedUpstream.length === 0 && sortedDownstream.length === 0) {
    html += `<div class="detail-value text-muted">No lineage connections</div>`;
  }
  content.innerHTML = html;
  content.querySelectorAll(".lineage-link").forEach((el) => {
    el.addEventListener("click", function() {
      const attrId2 = this.getAttribute("data-attr-id");
      if (attrId2) selectAttribute(attrId2);
    });
  });
}
function showDatasourceInAttributePanel(ds) {
  state.selectedAttribute = null;
  var dsId = ds.name.replace(/[^a-zA-Z0-9]/g, "_");
  var dsLineage = state.datasourceLineageMap[dsId] || { upstream: [], downstream: [] };
  var upstreamList = dsLineage.upstream || [];
  var downstreamList = dsLineage.downstream || [];
  var connectedIds = /* @__PURE__ */ new Set();
  upstreamList.forEach(function(x) {
    connectedIds.add(x.id);
  });
  downstreamList.forEach(function(x) {
    connectedIds.add(x.id);
  });
  d3.select("#attribute-graph").selectAll(".node").classed("node-highlighted", false).classed("node-connected", false).classed("node-dimmed", false);
  d3.select("#attribute-graph").selectAll(".edge").classed("edge-highlighted", false).classed("edge-dimmed", false);
  d3.select("#attribute-graph").selectAll(".cluster").classed("cluster-highlighted", false).classed("cluster-connected", false).classed("cluster-dimmed", false);
  d3.select("#attribute-graph").selectAll(".cluster").each(function() {
    const cluster = d3.select(this);
    const title = cluster.select("title").text();
    if (title && title.startsWith("cluster_")) {
      const clusterId = title.substring(8);
      if (clusterId === dsId) {
        cluster.classed("cluster-highlighted", true);
      } else if (connectedIds.has(clusterId)) {
        cluster.classed("cluster-connected", true);
      }
    }
  });
  const col = document.getElementById("attribute-details-col");
  const graphCol = document.getElementById("attribute-graph-col");
  const content = document.getElementById("attribute-details-content");
  graphCol.classList.remove("col-md-12");
  graphCol.classList.add("col-md-8");
  col.style.display = "block";
  setTimeout(() => {
    if (state.attributeGraphviz) state.attributeGraphviz.fit(true);
  }, 50);
  let html = `<h5>${ds.name}</h5>`;
  if (ds.type) {
    html += `<div class="detail-label">TYPE</div>`;
    html += `<div class="detail-value"><span class="badge badge-${ds.type}">${ds.type.toUpperCase()}</span></div>`;
  }
  if (upstreamList.length > 0) {
    html += '<div class="detail-label">UPSTREAM (' + upstreamList.length + ")</div>";
    html += '<div class="detail-value">';
    upstreamList.forEach(function(item) {
      var depth = item.depth;
      var indent = (depth - 1) * 16;
      var opacity = Math.max(0.4, 1 - (depth - 1) * 0.2);
      var found = (state.currentConfig.datasources || []).find(function(d) {
        return d.name.replace(/[^a-zA-Z0-9]/g, "_") === item.id;
      });
      var name = found ? found.name : item.id;
      var prefix = depth > 1 ? " " : "";
      html += '<div class="lineage-link" data-ds-name="' + name + '" style="padding-left: ' + indent + "px; opacity: " + opacity + ';">' + prefix + name + "</div>";
    });
    html += "</div>";
  }
  if (downstreamList.length > 0) {
    html += '<div class="detail-label">DOWNSTREAM (' + downstreamList.length + ")</div>";
    html += '<div class="detail-value">';
    downstreamList.forEach(function(item) {
      var depth = item.depth;
      var indent = (depth - 1) * 16;
      var opacity = Math.max(0.4, 1 - (depth - 1) * 0.2);
      var found = (state.currentConfig.datasources || []).find(function(d) {
        return d.name.replace(/[^a-zA-Z0-9]/g, "_") === item.id;
      });
      var name = found ? found.name : item.id;
      var prefix = depth > 1 ? " " : "";
      html += '<div class="lineage-link" data-ds-name="' + name + '" style="padding-left: ' + indent + "px; opacity: " + opacity + ';">' + prefix + name + "</div>";
    });
    html += "</div>";
  }
  if (ds.description) {
    html += `<div class="detail-label">Description</div>`;
    html += `<div class="detail-value">${ds.description}</div>`;
  }
  if (ds.owner) {
    html += `<div class="detail-label">Owner</div>`;
    html += `<div class="detail-value">${ds.owner}</div>`;
  }
  if (ds.cluster) {
    html += `<div class="detail-label">Cluster</div>`;
    html += `<div class="detail-value"><span class="badge badge-cluster">${ds.cluster}</span></div>`;
  }
  if (ds.tags && ds.tags.length > 0) {
    html += `<div class="detail-label">Tags</div>`;
    html += `<div class="detail-value">${ds.tags.map(
      (t) => `<span class="badge me-1 mb-1" style="background-color: #fff3cd; color: #856404;">${t}</span>`
    ).join("")}</div>`;
  }
  if (ds.attributes && ds.attributes.length > 0) {
    let countAttrs2 = function(attrs) {
      attrs.forEach((attr) => {
        attrCount++;
        if (attr.attributes) countAttrs2(attr.attributes);
      });
    }, listAttrs2 = function(attrs, indent = 0) {
      attrs.forEach((attr) => {
        const hasChildren = attr.attributes && attr.attributes.length > 0;
        html += `<div class="small" style="padding-left: ${indent * 12}px;">${hasChildren ? " " : ""}${attr.name}</div>`;
        if (attr.attributes) listAttrs2(attr.attributes, indent + 1);
      });
    };
    var countAttrs = countAttrs2, listAttrs = listAttrs2;
    let attrCount = 0;
    countAttrs2(ds.attributes);
    html += `<div class="detail-label">Attributes (${attrCount})</div>`;
    html += `<div class="detail-value">`;
    listAttrs2(ds.attributes);
    html += `</div>`;
  }
  if (ds.metadata && Object.keys(ds.metadata).length) {
    html += `<div class="detail-label">Metadata</div>`;
    html += `<div class="detail-value">`;
    Object.entries(ds.metadata).forEach(([key, value]) => {
      html += `<div class="small"><strong>${key.replace(/_/g, " ")}:</strong> ${value}</div>`;
    });
    html += `</div>`;
  }
  if (ds.links && Object.keys(ds.links).length) {
    html += `<div class="links-section">`;
    html += `<div class="detail-label">Links</div>`;
    Object.entries(ds.links).forEach(([name, url]) => {
      html += `<a href="${url}" target="_blank" class="btn btn-sm btn-outline-primary link-btn">${name}</a>`;
    });
    html += `</div>`;
  }
  content.innerHTML = html;
  content.querySelectorAll(".lineage-link[data-ds-name]").forEach((el) => {
    el.addEventListener("click", function() {
      const dsName = this.getAttribute("data-ds-name");
      const targetDs = (state.currentConfig.datasources || []).find((d) => d.name === dsName);
      if (targetDs) showDatasourceInAttributePanel(targetDs);
    });
  });
}
function clearAttributeSelection() {
  state.selectedAttribute = null;
  d3.select("#attribute-graph").selectAll(".node").classed("node-highlighted", false).classed("node-connected", false).classed("node-dimmed", false);
  d3.select("#attribute-graph").selectAll(".cluster").classed("cluster-highlighted", false).classed("cluster-connected", false).classed("cluster-dimmed", false);
  d3.select("#attribute-graph").selectAll(".edge").classed("edge-highlighted", false).classed("edge-dimmed", false);
  const col = document.getElementById("attribute-details-col");
  const graphCol = document.getElementById("attribute-graph-col");
  col.style.display = "none";
  graphCol.classList.remove("col-md-8");
  graphCol.classList.add("col-md-12");
  setTimeout(() => {
    if (state.attributeGraphviz) state.attributeGraphviz.fit(true);
  }, 50);
}
function searchAttributes(event) {
  const resultsDiv = document.getElementById("attribute-search-results");
  const items = resultsDiv.querySelectorAll(".search-result-item[data-id]");
  if (event.key === "ArrowDown" || event.key === "ArrowUp") {
    event.preventDefault();
    if (items.length === 0) return;
    const current = resultsDiv.querySelector(".search-result-item.selected");
    let index = current ? Array.from(items).indexOf(current) : -1;
    if (event.key === "ArrowDown") {
      index = index < items.length - 1 ? index + 1 : 0;
    } else {
      index = index > 0 ? index - 1 : items.length - 1;
    }
    items.forEach((item) => item.classList.remove("selected"));
    items[index].classList.add("selected");
    items[index].scrollIntoView({ block: "nearest" });
    return;
  }
  if (event.key === "Enter") {
    const selected = resultsDiv.querySelector(".search-result-item.selected");
    if (selected && selected.dataset.id) {
      selectAttributeFromSearch(selected.dataset.id);
    }
    return;
  }
  if (event.key === "Escape") {
    resultsDiv.classList.remove("show");
    resultsDiv.innerHTML = "";
    return;
  }
  const query = event.target.value.toLowerCase().trim();
  if (query.length < 2) {
    resultsDiv.classList.remove("show");
    return;
  }
  const matches = [];
  Object.values(state.attributeLineageMap).forEach((attr) => {
    if (attr.fullName.toLowerCase().includes(query) || attr.name.toLowerCase().includes(query)) {
      matches.push(attr);
    }
  });
  if (matches.length === 0) {
    resultsDiv.classList.remove("show");
    return;
  }
  let html = "";
  matches.slice(0, 10).forEach((attr, i) => {
    html += `<div class="search-result-item${i === 0 ? " selected" : ""}" data-id="${attr.id}" onclick="selectAttributeFromSearch('${attr.id}')">
            <span class="result-type datasource">${attr.datasource}</span>
            <span class="result-name">${attr.name}</span>
        </div>`;
  });
  resultsDiv.innerHTML = html;
  resultsDiv.classList.add("show");
}
function selectAttributeFromSearch(attrId) {
  document.getElementById("attribute-search-results").classList.remove("show");
  document.getElementById("attribute-search").value = "";
  selectAttribute(attrId);
}
document.addEventListener("click", function(e) {
  if (!e.target.closest("#attribute-search") && !e.target.closest("#attribute-search-results")) {
    document.getElementById("attribute-search-results")?.classList.remove("show");
  }
});
document.getElementById("attributes-tab")?.addEventListener("shown.bs.tab", function() {
  const newHash = getConfigHash(state.currentConfig);
  if (!state.attributeGraphviz || newHash !== state.attributeLastRenderedConfigHash) {
    setTimeout(() => {
      buildAttributeLineageMap();
      renderAttributeGraph();
      state.attributeLastRenderedConfigHash = newHash;
    }, 100);
  }
});
function generateGraphvizDot() {
  if (!state.currentConfig) return "";
  const isDark = document.documentElement.getAttribute("data-theme") === "dark";
  const edgeColor = isDark ? "#b0b0b0" : "#555";
  let pipelines = state.currentConfig.pipelines || [];
  const datasources = state.currentConfig.datasources || [];
  const explicitClusters = state.currentConfig.clusters || [];
  {
    const groups = /* @__PURE__ */ new Map();
    const ungroupedPipelines = [];
    pipelines.forEach((p) => {
      if (p.group && !state.expandedGroups.has(p.group)) {
        if (!groups.has(p.group)) {
          groups.set(p.group, {
            name: p.group,
            description: `Grouped pipelines: ${p.group}`,
            input_sources: /* @__PURE__ */ new Set(),
            output_sources: /* @__PURE__ */ new Set(),
            upstream_pipelines: /* @__PURE__ */ new Set(),
            cluster: p.cluster,
            _isGroup: true,
            _members: []
          });
        }
        const group = groups.get(p.group);
        p.input_sources?.forEach((s) => group.input_sources.add(s));
        p.output_sources?.forEach((s) => group.output_sources.add(s));
        p.upstream_pipelines?.forEach((u) => group.upstream_pipelines.add(u));
        group._members.push(p.name);
      } else {
        ungroupedPipelines.push(p);
      }
    });
    const groupedPipelines = Array.from(groups.values()).map((g) => ({
      ...g,
      input_sources: Array.from(g.input_sources),
      output_sources: Array.from(g.output_sources),
      upstream_pipelines: Array.from(g.upstream_pipelines).filter((u) => !g._members.includes(u))
    }));
    pipelines = [...ungroupedPipelines, ...groupedPipelines];
  }
  const allDataSources = /* @__PURE__ */ new Map();
  datasources.forEach((ds) => allDataSources.set(ds.name, ds));
  pipelines.forEach((pipeline) => {
    pipeline.input_sources?.forEach((sourceName) => {
      if (!allDataSources.has(sourceName)) {
        allDataSources.set(sourceName, { name: sourceName, type: "auto-created" });
      }
    });
    pipeline.output_sources?.forEach((sourceName) => {
      if (!allDataSources.has(sourceName)) {
        allDataSources.set(sourceName, { name: sourceName, type: "auto-created" });
      }
    });
  });
  const allClusterNames = /* @__PURE__ */ new Set();
  pipelines.forEach((p) => {
    if (p.cluster) allClusterNames.add(p.cluster);
  });
  allDataSources.forEach((ds) => {
    if (ds.cluster) allClusterNames.add(ds.cluster);
  });
  const clusterDefinitions = /* @__PURE__ */ new Map();
  const clusterHierarchy = /* @__PURE__ */ new Map();
  const clusterChildren = /* @__PURE__ */ new Map();
  explicitClusters.forEach((cluster) => {
    clusterDefinitions.set(cluster.name, cluster);
    allClusterNames.add(cluster.name);
    if (cluster.parent) {
      clusterHierarchy.set(cluster.name, cluster.parent);
      if (!clusterChildren.has(cluster.parent)) {
        clusterChildren.set(cluster.parent, []);
      }
      clusterChildren.get(cluster.parent).push(cluster.name);
      allClusterNames.add(cluster.parent);
    }
  });
  allClusterNames.forEach((name) => {
    if (!clusterDefinitions.has(name)) {
      clusterDefinitions.set(name, { name, description: `Auto-generated cluster: ${name}` });
    }
  });
  let dot = `digraph PipevizGraph {
    rankdir=LR;
    bgcolor="transparent";
    node [fontsize=12];
    edge [fontsize=10];

`;
  const nodesByCluster = /* @__PURE__ */ new Map();
  pipelines.forEach((pipeline) => {
    const cluster = pipeline.cluster || "_unclustered";
    if (!nodesByCluster.has(cluster)) {
      nodesByCluster.set(cluster, []);
    }
    nodesByCluster.get(cluster).push({ type: "pipeline", node: pipeline });
  });
  allDataSources.forEach((ds) => {
    const cluster = ds.cluster || "_unclustered";
    if (!nodesByCluster.has(cluster)) {
      nodesByCluster.set(cluster, []);
    }
    nodesByCluster.get(cluster).push({ type: "datasource", node: ds });
  });
  const rootClusters = [];
  clusterDefinitions.forEach((cluster, name) => {
    if (!clusterHierarchy.has(name) && nodesByCluster.has(name)) {
      rootClusters.push(name);
    }
  });
  function renderCluster(clusterName, depth = 0) {
    const cluster = clusterDefinitions.get(clusterName);
    if (!cluster) return "";
    const nodesInCluster = nodesByCluster.get(clusterName) || [];
    const children = clusterChildren.get(clusterName) || [];
    const hasNodes = nodesInCluster.length > 0;
    const hasChildrenWithNodes = children.some(
      (child) => nodesByCluster.has(child) && nodesByCluster.get(child).length > 0
    );
    if (!hasNodes && !hasChildrenWithNodes) return "";
    let result = `${"    ".repeat(depth + 1)}subgraph cluster_${clusterName.replace(/[^a-zA-Z0-9]/g, "_")} {
${"    ".repeat(depth + 2)}label="${clusterName}";
${"    ".repeat(depth + 2)}style="dotted";
${"    ".repeat(depth + 2)}color="#666666";
${"    ".repeat(depth + 2)}fontsize=11;
${"    ".repeat(depth + 2)}fontname="Arial";

`;
    nodesInCluster.forEach((item) => {
      if (item.type === "pipeline") {
        const pipeline = item.node;
        const isGroup = pipeline._isGroup;
        const memberCount = pipeline._members?.length || 0;
        const label = isGroup ? `<${pipeline.name}<BR/><FONT POINT-SIZE="9" COLOR="#666">(${memberCount} pipelines)</FONT>>` : pipeline.schedule ? `<${pipeline.name}<BR/><FONT POINT-SIZE="9" COLOR="#d63384"><I>${pipeline.schedule}</I></FONT>>` : `"${pipeline.name}"`;
        const fillColor = isGroup ? "#e0f2f1" : "#e3f2fd";
        const borderColor = isGroup ? "#00897b" : "#1976d2";
        const penWidth = isGroup ? "2" : "1";
        result += `${"    ".repeat(depth + 2)}"${pipeline.name}" [shape=box, style="filled,rounded",
${"    ".repeat(depth + 3)}fillcolor="${fillColor}", color="${borderColor}", penwidth=${penWidth},
${"    ".repeat(depth + 3)}fontname="Arial",
${"    ".repeat(depth + 3)}label=${label}];
`;
      } else if (item.type === "datasource" && !state.pipelinesOnlyView) {
        const ds = item.node;
        result += `${"    ".repeat(depth + 2)}"${ds.name}" [shape=ellipse, style=filled,
${"    ".repeat(depth + 3)}fillcolor="#f3e5f5", color="#7b1fa2",
${"    ".repeat(depth + 3)}fontname="Arial", fontsize=10];
`;
      }
    });
    children.forEach((childName) => {
      result += renderCluster(childName, depth + 1);
    });
    result += `${"    ".repeat(depth + 1)}}

`;
    return result;
  }
  rootClusters.forEach((clusterName) => {
    dot += renderCluster(clusterName);
  });
  const unclusteredNodes = nodesByCluster.get("_unclustered") || [];
  unclusteredNodes.forEach((item) => {
    if (item.type === "pipeline") {
      const pipeline = item.node;
      const isGroup = pipeline._isGroup;
      const memberCount = pipeline._members?.length || 0;
      const label = isGroup ? `<${pipeline.name}<BR/><FONT POINT-SIZE="9" COLOR="#666">(${memberCount} pipelines)</FONT>>` : pipeline.schedule ? `<${pipeline.name}<BR/><FONT POINT-SIZE="9" COLOR="#d63384"><I>${pipeline.schedule}</I></FONT>>` : `"${pipeline.name}"`;
      const fillColor = isGroup ? "#e0f2f1" : "#e3f2fd";
      const borderColor = isGroup ? "#00897b" : "#1976d2";
      const penWidth = isGroup ? "2" : "1";
      dot += `    "${pipeline.name}" [shape=box, style="filled,rounded",
        fillcolor="${fillColor}", color="${borderColor}", penwidth=${penWidth},
        fontname="Arial",
        label=${label}];
`;
    } else if (item.type === "datasource" && !state.pipelinesOnlyView) {
      const ds = item.node;
      dot += `    "${ds.name}" [shape=ellipse, style=filled,
        fillcolor="#f3e5f5", color="#7b1fa2",
        fontname="Arial", fontsize=10];
`;
    }
  });
  if (!state.pipelinesOnlyView) {
    dot += "\n";
    pipelines.forEach((pipeline) => {
      pipeline.input_sources?.forEach((source) => {
        dot += `    "${source}" -> "${pipeline.name}" [color="${edgeColor}", arrowsize=0.8];
`;
      });
      pipeline.output_sources?.forEach((source) => {
        dot += `    "${pipeline.name}" -> "${source}" [color="${edgeColor}", arrowsize=0.8];
`;
      });
    });
  }
  const validNodeNames = new Set(pipelines.map((p) => p.name));
  dot += "\n";
  pipelines.forEach((pipeline) => {
    pipeline.upstream_pipelines?.forEach((upstream) => {
      if (validNodeNames.has(upstream)) {
        dot += `    "${upstream}" -> "${pipeline.name}" [color="#ff6b35", style="solid", arrowsize=0.8];
`;
      }
    });
  });
  dot += "\n    overlap=false; splines=true;\n}";
  return dot;
}
let graphTabListenerAdded = false;
function renderGraph() {
  if (!state.currentConfig) return;
  const currentHash = getConfigHash(state.currentConfig);
  if (!graphTabListenerAdded) {
    document.getElementById("graph-tab").addEventListener("shown.bs.tab", function() {
      const newHash = getConfigHash(state.currentConfig);
      if (!state.graphviz) {
        setTimeout(initializeGraph, 100);
        state.lastRenderedConfigHash = newHash;
      } else if (newHash !== state.lastRenderedConfigHash) {
        updateGraph();
        state.lastRenderedConfigHash = newHash;
      }
    });
    graphTabListenerAdded = true;
  }
  if (document.getElementById("graph-tab").classList.contains("active")) {
    setTimeout(initializeGraph, 100);
    state.lastRenderedConfigHash = currentHash;
  }
}
function initializeGraph() {
  try {
    document.getElementById("graph").innerHTML = "";
    state.graphviz = d3.select("#graph").graphviz().width(document.getElementById("graph").clientWidth).height(500).fit(true).on("initEnd", setupGraphInteractivity).on("renderEnd", setupGraphInteractivity);
    updateGraph();
  } catch (error) {
    console.error("Graphviz initialization error:", error);
    document.getElementById("graph").innerHTML = `
            <div class="alert alert-warning m-3">
                <strong>Graph rendering issue detected.</strong><br>
                Please check the Raw DOT tab to see the generated code.<br>
                <small>Error: ${error.message}</small>
            </div>
        `;
  }
}
function updateGraph() {
  if (state.graphviz) {
    const dotSrc = generateGraphvizDot();
    state.graphviz.renderDot(dotSrc);
  }
}
function setupGraphInteractivity() {
  state.cachedUpstreamMap = {};
  state.cachedDownstreamMap = {};
  state.cachedLineage = {};
  d3.select("#graph").selectAll(".edge").each(function() {
    const edge = d3.select(this);
    const title = edge.select("title").text();
    const match = title.match(/^(.+?)(?:->|--)\s*(.+?)$/);
    if (match) {
      const source = match[1];
      const target = match[2];
      if (!state.cachedDownstreamMap[source]) state.cachedDownstreamMap[source] = [];
      if (!state.cachedUpstreamMap[target]) state.cachedUpstreamMap[target] = [];
      state.cachedDownstreamMap[source].push(target);
      state.cachedUpstreamMap[target].push(source);
    }
  });
  function getFullChain(node, map, visited = /* @__PURE__ */ new Set(), depth = 1) {
    if (visited.has(node)) return [];
    visited.add(node);
    const neighbors = map[node] || [];
    let result = [];
    neighbors.forEach((n) => {
      result.push({ name: n, depth });
      result.push(...getFullChain(n, map, visited, depth + 1));
    });
    return result;
  }
  d3.select("#graph").selectAll(".node").each(function() {
    const nodeName = d3.select(this).select("title").text();
    state.cachedLineage[nodeName] = {
      upstream: getFullChain(nodeName, state.cachedUpstreamMap, /* @__PURE__ */ new Set()),
      downstream: getFullChain(nodeName, state.cachedDownstreamMap, /* @__PURE__ */ new Set())
    };
  });
  if (document.getElementById("node-tooltip")) {
    document.getElementById("node-tooltip").remove();
  }
  const tooltip = document.createElement("div");
  tooltip.id = "node-tooltip";
  tooltip.className = "node-tooltip";
  tooltip.style.display = "none";
  document.body.appendChild(tooltip);
  d3.select("#graph").selectAll(".node").style("cursor", "pointer").on("click", function(event, d) {
    event.stopPropagation();
    const nodeName = d3.select(this).select("title").text();
    selectNode(nodeName, this);
  }).on("dblclick", function(event, d) {
    event.stopPropagation();
    const nodeName = d3.select(this).select("title").text();
    if (state.currentConfig?.pipelines) {
      const isGroupNode = state.currentConfig.pipelines.some((p) => p.group === nodeName);
      if (isGroupNode) {
        toggleGroup(nodeName);
      }
    }
  }).on("mouseover", function(event, d) {
    const nodeName = d3.select(this).select("title").text();
    showNodeTooltip(event, nodeName);
  }).on("mousemove", function(event, d) {
    tooltip.style.left = event.pageX + 10 + "px";
    tooltip.style.top = event.pageY - 10 + "px";
  }).on("mouseout", function(event, d) {
    hideNodeTooltip();
  });
  d3.select("#graph").on("click", function(event) {
    if (event.target.tagName === "svg" || event.target === event.currentTarget || event.target.classList.contains("graph-container") || !event.target.closest(".node")) {
      clearSelection();
    }
  });
}
function showNodeTooltip(event, nodeName) {
  const tooltip = document.getElementById("node-tooltip");
  if (!tooltip || !state.currentConfig) return;
  let content = "";
  {
    const groupMembers = state.currentConfig.pipelines?.filter((p) => p.group === nodeName);
    if (groupMembers?.length > 0) {
      content = `${nodeName} (${groupMembers.length} pipelines)`;
      content += `
Click for details`;
      content += `
Members: ${groupMembers.map((p) => p.name).join(", ")}`;
      tooltip.textContent = content;
      tooltip.style.display = "block";
      tooltip.style.left = event.pageX + 10 + "px";
      tooltip.style.top = event.pageY - 10 + "px";
      return;
    }
  }
  const pipeline = state.currentConfig.pipelines?.find((p) => p.name === nodeName);
  if (pipeline) {
    content = `${pipeline.name}`;
    if (pipeline.description) content += `
Description: ${pipeline.description}`;
    if (pipeline.schedule) content += `
Schedule: ${pipeline.schedule}`;
    if (pipeline.cluster) content += `
Cluster: ${pipeline.cluster}`;
    if (pipeline.tags && pipeline.tags.length > 0) content += `
Tags: ${pipeline.tags.join(", ")}`;
    if (pipeline.input_sources && pipeline.input_sources.length > 0) content += `
Inputs: ${pipeline.input_sources.join(", ")}`;
    if (pipeline.output_sources && pipeline.output_sources.length > 0) content += `
Outputs: ${pipeline.output_sources.join(", ")}`;
  }
  const datasource = state.currentConfig.datasources?.find((ds) => ds.name === nodeName);
  if (datasource) {
    content = `${datasource.name}`;
    if (datasource.type) content += `
Type: ${datasource.type.toUpperCase()}`;
    if (datasource.description) content += `
Description: ${datasource.description}`;
    if (datasource.owner) content += `
Owner: ${datasource.owner}`;
    if (datasource.cluster) content += `
Cluster: ${datasource.cluster}`;
    if (datasource.tags && datasource.tags.length > 0) content += `
Tags: ${datasource.tags.join(", ")}`;
    if (datasource.metadata) {
      const keyFields = ["size", "record_count", "refresh_frequency", "environment"];
      keyFields.forEach((field) => {
        if (datasource.metadata[field]) {
          content += `
${field.replace(/_/g, " ")}: ${datasource.metadata[field]}`;
        }
      });
    }
  }
  if (content) {
    tooltip.textContent = content;
    tooltip.style.display = "block";
    tooltip.style.left = event.pageX + 10 + "px";
    tooltip.style.top = event.pageY - 10 + "px";
  }
}
function hideNodeTooltip() {
  const tooltip = document.getElementById("node-tooltip");
  if (tooltip) {
    tooltip.style.display = "none";
  }
}
function selectNode(nodeName, nodeElement) {
  state.selectedNode = nodeName;
  clearHighlights();
  d3.select(nodeElement).classed("node-highlighted", true);
  const lineage = state.cachedLineage[nodeName] || { upstream: [], downstream: [] };
  const upstream = lineage.upstream;
  const downstream = lineage.downstream;
  const allConnected = /* @__PURE__ */ new Set([...upstream.map((x) => x.name), ...downstream.map((x) => x.name)]);
  d3.select("#graph").selectAll(".node").each(function() {
    const node = d3.select(this);
    const nodeTitle = node.select("title").text();
    if (allConnected.has(nodeTitle)) {
      node.classed("node-connected", true);
    } else if (nodeTitle !== nodeName) {
      node.classed("node-dimmed", true);
    }
  });
  d3.select("#graph").selectAll(".edge").each(function() {
    const edge = d3.select(this);
    const title = edge.select("title").text();
    const match = title.match(/^(.+?)(?:->|--)\s*(.+?)$/);
    if (match) {
      const source = match[1];
      const target = match[2];
      const sourceInChain = source === nodeName || allConnected.has(source);
      const targetInChain = target === nodeName || allConnected.has(target);
      if (sourceInChain && targetInChain) {
        edge.classed("edge-highlighted", true);
      } else {
        edge.classed("edge-dimmed", true);
      }
    }
  });
  showNodeDetails(nodeName, upstream, downstream);
}
function showNodeDetails(nodeName, upstream = [], downstream = []) {
  const col = document.getElementById("node-details-col");
  const content = document.getElementById("node-details-content");
  if (!state.currentConfig) return;
  let html = "";
  let nodeData = null;
  let nodeType = "";
  const pipeline = state.currentConfig.pipelines?.find((p) => p.name === nodeName);
  if (pipeline) {
    nodeData = pipeline;
    nodeType = "Pipeline";
  }
  if (!nodeData && state.groupedView) {
    const groupMembers = state.currentConfig.pipelines?.filter((p) => p.group === nodeName);
    if (groupMembers?.length > 0) {
      const allInputs = /* @__PURE__ */ new Set();
      const allOutputs = /* @__PURE__ */ new Set();
      groupMembers.forEach((p) => {
        p.input_sources?.forEach((s) => allInputs.add(s));
        p.output_sources?.forEach((s) => allOutputs.add(s));
      });
      nodeData = {
        name: nodeName,
        description: `Group containing ${groupMembers.length} pipelines`,
        input_sources: Array.from(allInputs),
        output_sources: Array.from(allOutputs),
        cluster: groupMembers[0].cluster,
        _members: groupMembers.map((p) => p.name)
      };
      nodeType = "Pipeline Group";
    }
  }
  const datasource = state.currentConfig.datasources?.find((ds) => ds.name === nodeName);
  if (datasource) {
    nodeData = datasource;
    nodeType = "Data Source";
  }
  if (!nodeData) {
    const allSources = /* @__PURE__ */ new Set();
    state.currentConfig.pipelines?.forEach((p) => {
      p.input_sources?.forEach((s) => allSources.add(s));
      p.output_sources?.forEach((s) => allSources.add(s));
    });
    if (allSources.has(nodeName)) {
      nodeData = { name: nodeName, description: "Auto-created from pipeline references" };
      nodeType = "Data Source";
    }
  }
  if (!nodeData) {
    col.style.display = "none";
    return;
  }
  html = `<h5>${nodeData.name}</h5>`;
  html += `<div class="detail-label">Type</div>`;
  html += `<div class="detail-value"><span class="badge bg-secondary">${nodeType}</span></div>`;
  if (nodeType === "Pipeline Group") {
    const isExpanded = state.expandedGroups.has(nodeName);
    html += `<div class="mt-2 mb-2">
            <button class="btn btn-sm btn-outline-warning" onclick="toggleGroup('${nodeName}')">
                ${isExpanded ? "Collapse Group" : "Expand Group"}
            </button>
        </div>`;
  }
  if (nodeType === "Pipeline" && nodeData.group && state.expandedGroups.has(nodeData.group)) {
    html += `<div class="mt-2 mb-2">
            <button class="btn btn-sm btn-outline-secondary" onclick="toggleGroup('${nodeData.group}')">
                Collapse Group (${nodeData.group})
            </button>
        </div>`;
  }
  if (nodeData.description) {
    html += `<div class="detail-label">Description</div>`;
    html += `<div class="detail-value">${nodeData.description}</div>`;
  }
  if (nodeData.schedule) {
    html += `<div class="detail-label">Schedule</div>`;
    html += `<div class="detail-value"><code class="text-success">${nodeData.schedule}</code></div>`;
  }
  if (nodeData.type) {
    html += `<div class="detail-label">Source Type</div>`;
    html += `<div class="detail-value"><span class="badge badge-${nodeData.type}">${nodeData.type.toUpperCase()}</span></div>`;
  }
  if (nodeData.owner) {
    html += `<div class="detail-label">Owner</div>`;
    html += `<div class="detail-value">${nodeData.owner}</div>`;
  }
  if (nodeData.cluster) {
    html += `<div class="detail-label">Cluster</div>`;
    html += `<div class="detail-value"><span class="badge badge-cluster">${nodeData.cluster}</span></div>`;
  }
  if (nodeData.input_sources?.length) {
    html += `<div class="detail-label">Input Sources</div>`;
    html += `<div class="detail-value">${nodeData.input_sources.map(
      (s) => `<span class="badge me-1 mb-1" style="background-color: #e3f2fd; color: #1565c0;">${s}</span>`
    ).join("")}</div>`;
  }
  if (nodeData.output_sources?.length) {
    html += `<div class="detail-label">Output Sources</div>`;
    html += `<div class="detail-value">${nodeData.output_sources.map(
      (s) => `<span class="badge me-1 mb-1" style="background-color: #e8f5e8; color: #2e7d32;">${s}</span>`
    ).join("")}</div>`;
  }
  if (nodeData.upstream_pipelines?.length) {
    html += `<div class="detail-label">Upstream Pipelines</div>`;
    html += `<div class="detail-value">${nodeData.upstream_pipelines.map(
      (p) => `<span class="badge me-1 mb-1" style="background-color: #fff3e0; color: #e65100;">${p}</span>`
    ).join("")}</div>`;
  }
  if (nodeData._members?.length) {
    html += `<div class="detail-label">Member Pipelines</div>`;
    html += `<div class="detail-value">${nodeData._members.map(
      (p) => `<span class="badge me-1 mb-1" style="background-color: #e0f2f1; color: #00897b;">${p}</span>`
    ).join("")}</div>`;
  }
  if (nodeData.tags?.length) {
    html += `<div class="detail-label">Tags</div>`;
    html += `<div class="detail-value">${nodeData.tags.map(
      (t) => `<span class="badge me-1 mb-1" style="background-color: #fff3cd; color: #856404;">${t}</span>`
    ).join("")}</div>`;
  }
  if (nodeData.metadata && Object.keys(nodeData.metadata).length) {
    html += `<div class="detail-label">Metadata</div>`;
    html += `<div class="detail-value">`;
    Object.entries(nodeData.metadata).forEach(([key, value]) => {
      html += `<div class="small"><strong>${key.replace(/_/g, " ")}:</strong> ${value}</div>`;
    });
    html += `</div>`;
  }
  if (nodeData.links && Object.keys(nodeData.links).length) {
    html += `<div class="links-section">`;
    html += `<div class="detail-label">Links</div>`;
    Object.entries(nodeData.links).forEach(([name, url]) => {
      html += `<a href="${url}" target="_blank" class="btn btn-sm btn-outline-primary link-btn">${name}</a>`;
    });
    html += `</div>`;
  }
  const pipelineNames = new Set((state.currentConfig.pipelines || []).map((p) => p.name));
  {
    (state.currentConfig.pipelines || []).forEach((p) => {
      if (p.group) pipelineNames.add(p.group);
    });
  }
  function dedupeAndSort(items, filterFn) {
    const seen = /* @__PURE__ */ new Map();
    items.filter((x) => filterFn(x.name)).forEach((x) => {
      if (!seen.has(x.name) || seen.get(x.name).depth > x.depth) {
        seen.set(x.name, x);
      }
    });
    return [...seen.values()].sort((a, b) => a.depth - b.depth);
  }
  const upstreamPipelines = dedupeAndSort(upstream, (n) => pipelineNames.has(n));
  const upstreamSources = dedupeAndSort(upstream, (n) => !pipelineNames.has(n));
  const downstreamPipelines = dedupeAndSort(downstream, (n) => pipelineNames.has(n));
  const downstreamSources = dedupeAndSort(downstream, (n) => !pipelineNames.has(n));
  function renderLineageList(items, label) {
    if (items.length === 0) return "";
    let out = `<div class="detail-label">${label} (${items.length})</div><div class="detail-value">`;
    items.forEach((x) => {
      const indent = (x.depth - 1) * 12;
      const opacity = Math.max(0.5, 1 - (x.depth - 1) * 0.15);
      const prefix = x.depth > 1 ? " " : "";
      out += `<div class="lineage-link" data-node-name="${x.name}" style="padding-left: ${indent}px; opacity: ${opacity};">${prefix}${x.name}</div>`;
    });
    out += `</div>`;
    return out;
  }
  html += renderLineageList(upstreamPipelines, "UPSTREAM PIPELINES");
  html += renderLineageList(upstreamSources, "UPSTREAM SOURCES");
  html += renderLineageList(downstreamPipelines, "DOWNSTREAM PIPELINES");
  html += renderLineageList(downstreamSources, "DOWNSTREAM SOURCES");
  const graphCol = document.getElementById("graph-col");
  graphCol.classList.remove("col-md-12");
  graphCol.classList.add("col-md-8");
  col.style.display = "block";
  content.innerHTML = html;
  content.querySelectorAll(".lineage-link").forEach((el) => {
    el.addEventListener("click", function() {
      const targetName = this.getAttribute("data-node-name");
      if (targetName) {
        d3.select("#graph").selectAll(".node").each(function() {
          const nodeTitle = d3.select(this).select("title").text();
          if (nodeTitle === targetName) {
            selectNode(targetName, this);
          }
        });
      }
    });
  });
}
function clearSelection() {
  state.selectedNode = null;
  clearHighlights();
  const col = document.getElementById("node-details-col");
  const graphCol = document.getElementById("graph-col");
  if (col) col.style.display = "none";
  if (graphCol) {
    graphCol.classList.remove("col-md-8");
    graphCol.classList.add("col-md-12");
  }
}
function clearHighlights() {
  d3.select("#graph").selectAll(".node").classed("node-highlighted node-connected node-dimmed", false);
  d3.select("#graph").selectAll(".edge").classed("edge-highlighted edge-dimmed", false);
}
function fuzzyMatch(text, query) {
  text = text.toLowerCase();
  query = query.toLowerCase();
  if (text.includes(query)) {
    return { match: true, score: query.length / text.length + 0.5 };
  }
  let queryIdx = 0;
  let score = 0;
  let lastMatchIdx = -1;
  for (let i = 0; i < text.length && queryIdx < query.length; i++) {
    if (text[i] === query[queryIdx]) {
      score += 1;
      if (lastMatchIdx === i - 1) score += 0.5;
      if (i === 0 || text[i - 1] === "_" || text[i - 1] === "-" || text[i - 1] === " ") score += 0.3;
      lastMatchIdx = i;
      queryIdx++;
    }
  }
  if (queryIdx === query.length) {
    return { match: true, score: score / text.length };
  }
  return { match: false, score: 0 };
}
function highlightMatch(text, query) {
  const lowerText = text.toLowerCase();
  const lowerQuery = query.toLowerCase();
  const idx = lowerText.indexOf(lowerQuery);
  if (idx !== -1) {
    return text.substring(0, idx) + '<span class="result-match">' + text.substring(idx, idx + query.length) + "</span>" + text.substring(idx + query.length);
  }
  let result = "";
  let queryIdx = 0;
  for (let i = 0; i < text.length; i++) {
    if (queryIdx < query.length && text[i].toLowerCase() === lowerQuery[queryIdx]) {
      result += '<span class="result-match">' + text[i] + "</span>";
      queryIdx++;
    } else {
      result += text[i];
    }
  }
  return result;
}
function searchNodes(event) {
  const dropdown = document.getElementById("graph-search-results");
  const items = dropdown.querySelectorAll(".search-result-item[data-name]");
  if (event.key === "ArrowDown" || event.key === "ArrowUp") {
    event.preventDefault();
    if (items.length === 0) return;
    const current = dropdown.querySelector(".search-result-item.selected");
    let index = current ? Array.from(items).indexOf(current) : -1;
    if (event.key === "ArrowDown") {
      index = index < items.length - 1 ? index + 1 : 0;
    } else {
      index = index > 0 ? index - 1 : items.length - 1;
    }
    items.forEach((item) => item.classList.remove("selected"));
    items[index].classList.add("selected");
    items[index].scrollIntoView({ block: "nearest" });
    return;
  }
  if (event.key === "Enter") {
    const selected = dropdown.querySelector(".search-result-item.selected");
    if (selected && selected.dataset.name) {
      selectSearchResult(selected.dataset.name);
    }
    return;
  }
  if (event.key === "Escape") {
    dropdown.classList.remove("show");
    dropdown.innerHTML = "";
    return;
  }
  const query = event.target.value.trim();
  if (!query || query.length < 1 || !state.currentConfig) {
    dropdown.classList.remove("show");
    dropdown.innerHTML = "";
    return;
  }
  const results = [];
  state.currentConfig.pipelines?.forEach((p) => {
    const nameMatch = fuzzyMatch(p.name, query);
    const descMatch = p.description ? fuzzyMatch(p.description, query) : { match: false, score: 0 };
    if (nameMatch.match || descMatch.match) {
      results.push({
        name: p.name,
        type: "pipeline",
        score: Math.max(nameMatch.score * 1.5, descMatch.score)
      });
    }
  });
  state.currentConfig.datasources?.forEach((ds) => {
    const nameMatch = fuzzyMatch(ds.name, query);
    const descMatch = ds.description ? fuzzyMatch(ds.description, query) : { match: false, score: 0 };
    if (nameMatch.match || descMatch.match) {
      results.push({
        name: ds.name,
        type: "datasource",
        score: Math.max(nameMatch.score * 1.5, descMatch.score)
      });
    }
  });
  const autoSources = /* @__PURE__ */ new Set();
  state.currentConfig.pipelines?.forEach((p) => {
    p.input_sources?.forEach((s) => autoSources.add(s));
    p.output_sources?.forEach((s) => autoSources.add(s));
  });
  autoSources.forEach((name) => {
    if (!state.currentConfig.datasources?.find((ds) => ds.name === name)) {
      const nameMatch = fuzzyMatch(name, query);
      if (nameMatch.match) {
        results.push({
          name,
          type: "datasource",
          score: nameMatch.score * 1.5
        });
      }
    }
  });
  results.sort((a, b) => b.score - a.score);
  const topResults = results.slice(0, 8);
  if (topResults.length === 0) {
    dropdown.innerHTML = '<div class="search-result-item text-muted">No matches found</div>';
    dropdown.classList.add("show");
    return;
  }
  dropdown.innerHTML = topResults.map((r, i) => `
        <div class="search-result-item${i === 0 ? " selected" : ""}" data-name="${r.name}" onclick="selectSearchResult('${r.name}')">
            <span class="result-type ${r.type}">${r.type === "pipeline" ? "Pipeline" : "Source"}</span>
            <span class="result-name">${highlightMatch(r.name, query)}</span>
        </div>
    `).join("");
  dropdown.classList.add("show");
}
function selectSearchResult(nodeName) {
  const dropdown = document.getElementById("graph-search-results");
  const searchInput = document.getElementById("graph-search");
  dropdown.classList.remove("show");
  searchInput.value = "";
  let found = false;
  d3.select("#graph").selectAll(".node").each(function() {
    const node = d3.select(this);
    const nodeTitle = node.select("title").text();
    if (nodeTitle === nodeName) {
      found = true;
      selectNode(nodeName, this);
    }
  });
  if (!found) {
    showNodeDetails(nodeName);
  }
}
document.addEventListener("click", function(e) {
  const dropdown = document.getElementById("graph-search-results");
  const searchInput = document.getElementById("graph-search");
  if (dropdown && !dropdown.contains(e.target) && e.target !== searchInput) {
    dropdown.classList.remove("show");
  }
});
function resetGraph() {
  if (state.graphviz) state.graphviz.resetZoom();
}
function collapseAllGroups() {
  state.expandedGroups.clear();
  updateGraph();
}
function togglePipelinesOnly() {
  state.pipelinesOnlyView = !state.pipelinesOnlyView;
  const btn = document.getElementById("pipelines-only-btn");
  if (state.pipelinesOnlyView) {
    btn.classList.remove("btn-outline-secondary");
    btn.classList.add("btn-secondary");
  } else {
    btn.classList.remove("btn-secondary");
    btn.classList.add("btn-outline-secondary");
  }
  updateGraph();
}
function toggleGroup(groupName) {
  if (state.expandedGroups.has(groupName)) {
    state.expandedGroups.delete(groupName);
  } else {
    state.expandedGroups.add(groupName);
  }
  updateGraph();
  showNodeDetails(groupName);
}
function toggleTheme() {
  const html = document.documentElement;
  const btn = document.getElementById("theme-toggle");
  if (html.getAttribute("data-theme") === "dark") {
    html.removeAttribute("data-theme");
    btn.textContent = "";
    localStorage.setItem("pipeviz-theme", "light");
  } else {
    html.setAttribute("data-theme", "dark");
    btn.textContent = "";
    localStorage.setItem("pipeviz-theme", "dark");
  }
  renderSplashGraph();
  updateGraph();
}
function initTheme() {
  const saved = localStorage.getItem("pipeviz-theme");
  if (saved === "dark") {
    document.documentElement.setAttribute("data-theme", "dark");
    document.getElementById("theme-toggle").textContent = "";
  }
}
function setupTabs() {
  document.querySelectorAll("#dashboardTabs button").forEach((tab) => {
    tab.addEventListener("shown.bs.tab", function(e) {
      const tabs = document.getElementById("dashboardTabs");
      const tabName = e.target.id.replace("-tab", "");
      if (e.target.id === "home-tab") {
        tabs.classList.add("hidden-on-home");
        history.replaceState(null, "", window.location.pathname + window.location.search);
      } else {
        tabs.classList.remove("hidden-on-home");
        history.replaceState(null, "", "#" + tabName);
      }
    });
  });
}
function activateTabFromHash() {
  const hash = window.location.hash.slice(1);
  if (hash) {
    const tab = document.getElementById(hash + "-tab");
    if (tab) {
      tab.click();
    }
  }
}
function renderPipelines() {
  if (!state.currentConfig || !state.currentConfig.pipelines) return;
  const container = document.getElementById("pipelines-table-container");
  let html = `
        <div class="table-container">
        <table class="table table-striped table-hover">
            <thead>
                <tr>
                    <th>Pipeline</th>
                    <th>Description</th>
                    <th>Schedule</th>
                    <th>Input Sources</th>
                    <th>Output Sources</th>
                    <th>Cluster</th>
                    <th>Tags</th>
                    <th>Links</th>
                </tr>
            </thead>
            <tbody>
    `;
  state.currentConfig.pipelines.forEach((pipeline) => {
    const inputSources = pipeline.input_sources?.map(
      (s) => `<span class="badge me-1 mb-1" style="background-color: #e3f2fd; color: #1565c0; font-size: 0.85em;">${s}</span>`
    ).join("") || "";
    const outputSources = pipeline.output_sources?.map(
      (s) => `<span class="badge me-1 mb-1" style="background-color: #e8f5e8; color: #2e7d32; font-size: 0.85em;">${s}</span>`
    ).join("") || "";
    const cluster = pipeline.cluster ? `<span class="badge badge-cluster me-1 mb-1">${pipeline.cluster}</span>` : "";
    const tags = pipeline.tags?.map(
      (t) => `<span class="badge me-1 mb-1" style="background-color: #fff3cd; color: #856404; font-size: 0.85em;">${t}</span>`
    ).join("") || "";
    const links = pipeline.links ? Object.entries(pipeline.links).map(
      ([name, url]) => `<a href="${url}" target="_blank" class="btn btn-sm btn-outline-primary me-1 mb-1" style="font-size: 0.75em; padding: 2px 6px;">${name}</a>`
    ).join("") : "";
    html += `
            <tr class="pipeline-row"
                data-name="${pipeline.name.toLowerCase()}"
                data-description="${(pipeline.description || "").toLowerCase()}"
                data-cluster="${(pipeline.cluster || "").toLowerCase()}"
                data-tags="${(pipeline.tags || []).join(",").toLowerCase()}">
                <td class="col-name"><div><strong>${pipeline.name}</strong></div></td>
                <td class="col-desc"><div>${pipeline.description || ""}</div></td>
                <td class="col-schedule"><div><code class="text-success">${pipeline.schedule || ""}</code></div></td>
                <td class="col-sources"><div>${inputSources}</div></td>
                <td class="col-sources"><div>${outputSources}</div></td>
                <td class="col-cluster"><div>${cluster}</div></td>
                <td class="col-tags"><div>${tags}</div></td>
                <td class="col-links"><div>${links}</div></td>
            </tr>
        `;
  });
  html += "</tbody></table></div>";
  container.innerHTML = html;
}
function renderDatasources() {
  if (!state.currentConfig || !state.currentConfig.pipelines) {
    const container2 = document.getElementById("datasources-table-container");
    container2.innerHTML = '<p class="text-muted text-center">Load a configuration to see your data sources</p>';
    return;
  }
  const allDataSources = /* @__PURE__ */ new Map();
  if (state.currentConfig.datasources) {
    state.currentConfig.datasources.forEach((ds) => {
      allDataSources.set(ds.name, ds);
    });
  }
  state.currentConfig.pipelines.forEach((pipeline) => {
    pipeline.input_sources?.forEach((sourceName) => {
      if (!allDataSources.has(sourceName)) {
        allDataSources.set(sourceName, {
          name: sourceName,
          type: "auto-created",
          description: "Auto-created from pipeline references",
          isAutoCreated: true
        });
      }
    });
    pipeline.output_sources?.forEach((sourceName) => {
      if (!allDataSources.has(sourceName)) {
        allDataSources.set(sourceName, {
          name: sourceName,
          type: "auto-created",
          description: "Auto-created from pipeline references",
          isAutoCreated: true
        });
      }
    });
  });
  const container = document.getElementById("datasources-table-container");
  if (allDataSources.size === 0) {
    container.innerHTML = '<p class="text-muted text-center">No data sources found</p>';
    return;
  }
  let html = `
        <div class="table-container">
        <table class="table table-striped table-hover">
            <thead>
                <tr>
                    <th>Name & Type</th>
                    <th>Description</th>
                    <th>Owner</th>
                    <th>Metadata</th>
                    <th>Cluster</th>
                    <th>Tags</th>
                    <th>Links</th>
                </tr>
            </thead>
            <tbody>
    `;
  allDataSources.forEach((ds) => {
    const typeBadge = `<span class="badge badge-${ds.type || "secondary"}">${(ds.type || "unknown").toUpperCase()}</span>`;
    const metadata = ds.metadata ? Object.entries(ds.metadata).map(
      ([k, v]) => `<div class="small text-muted mb-1"><span style="font-weight: 500;">${k.replace(/_/g, " ")}:</span> ${v}</div>`
    ).join("") : "";
    const cluster = ds.cluster ? `<span class="badge badge-cluster me-1 mb-1">${ds.cluster}</span>` : "";
    const tags = ds.tags?.map(
      (t) => `<span class="badge me-1 mb-1" style="background-color: #fff3cd; color: #856404; font-size: 0.85em;">${t}</span>`
    ).join("") || "";
    const links = ds.links ? Object.entries(ds.links).map(
      ([name, url]) => `<a href="${url}" target="_blank" class="btn btn-sm btn-outline-primary me-1 mb-1" style="font-size: 0.75em; padding: 2px 6px;">${name}</a>`
    ).join("") : "";
    html += `
            <tr class="datasource-row"
                data-name="${ds.name.toLowerCase()}"
                data-type="${(ds.type || "").toLowerCase()}"
                data-cluster="${(ds.cluster || "").toLowerCase()}"
                data-tags="${(ds.tags || []).join(",").toLowerCase()}"
                data-search="${(ds.name + " " + (ds.description || "") + " " + (ds.owner || "")).toLowerCase()}">
                <td class="col-name"><div><strong>${ds.name}</strong><br>${typeBadge}</div></td>
                <td class="col-desc"><div>${ds.isAutoCreated ? `<span class="text-secondary fst-italic">${ds.description}</span>` : ds.description || ""}</div></td>
                <td class="col-owner"><div class="small text-muted">${ds.owner || ""}</div></td>
                <td class="col-metadata"><div>${metadata}</div></td>
                <td class="col-cluster"><div>${cluster}</div></td>
                <td class="col-tags"><div>${tags}</div></td>
                <td class="col-links"><div>${links}</div></td>
            </tr>
        `;
  });
  html += "</tbody></table></div>";
  container.innerHTML = html;
}
const activeFilters = {
  pipelineTags: /* @__PURE__ */ new Set(),
  pipelineClusters: /* @__PURE__ */ new Set(),
  datasourceTypes: /* @__PURE__ */ new Set(),
  datasourceTags: /* @__PURE__ */ new Set(),
  datasourceClusters: /* @__PURE__ */ new Set()
};
function updateFilters() {
  if (!state.currentConfig) return;
  const pipelineTags = [...new Set(state.currentConfig.pipelines?.flatMap((p) => p.tags || []) || [])].sort();
  const pipelineClusters = [...new Set(state.currentConfig.pipelines?.map((p) => p.cluster).filter((c) => c) || [])].sort();
  let pipelineHtml = "";
  if (pipelineClusters.length) {
    pipelineHtml += '<span class="filter-group"><span class="filter-group-label">cluster:</span>';
    pipelineHtml += pipelineClusters.map(
      (c) => `<span class="filter-tag" data-type="pipelineClusters" data-value="${c}">${c}</span>`
    ).join("");
    pipelineHtml += "</span>";
  }
  if (pipelineTags.length) {
    pipelineHtml += '<span class="filter-group"><span class="filter-group-label">tag:</span>';
    pipelineHtml += pipelineTags.map(
      (t) => `<span class="filter-tag" data-type="pipelineTags" data-value="${t}">${t}</span>`
    ).join("");
    pipelineHtml += "</span>";
  }
  document.getElementById("pipeline-filters").innerHTML = pipelineHtml;
  const datasourceTypes = [...new Set(state.currentConfig.datasources?.map((ds) => ds.type || "unknown") || [])].sort();
  const datasourceTags = [...new Set(state.currentConfig.datasources?.flatMap((ds) => ds.tags || []) || [])].sort();
  const datasourceClusters = [...new Set(state.currentConfig.datasources?.map((ds) => ds.cluster).filter((c) => c) || [])].sort();
  let datasourceHtml = "";
  if (datasourceTypes.length) {
    datasourceHtml += '<span class="filter-group"><span class="filter-group-label">type:</span>';
    datasourceHtml += datasourceTypes.map(
      (t) => `<span class="filter-tag" data-type="datasourceTypes" data-value="${t}">${t}</span>`
    ).join("");
    datasourceHtml += "</span>";
  }
  if (datasourceClusters.length) {
    datasourceHtml += '<span class="filter-group"><span class="filter-group-label">cluster:</span>';
    datasourceHtml += datasourceClusters.map(
      (c) => `<span class="filter-tag" data-type="datasourceClusters" data-value="${c}">${c}</span>`
    ).join("");
    datasourceHtml += "</span>";
  }
  if (datasourceTags.length) {
    datasourceHtml += '<span class="filter-group"><span class="filter-group-label">tag:</span>';
    datasourceHtml += datasourceTags.map(
      (t) => `<span class="filter-tag" data-type="datasourceTags" data-value="${t}">${t}</span>`
    ).join("");
    datasourceHtml += "</span>";
  }
  document.getElementById("datasource-filters").innerHTML = datasourceHtml;
  document.querySelectorAll(".filter-tag").forEach((tag) => {
    tag.addEventListener("click", function() {
      const type = this.dataset.type;
      const value = this.dataset.value;
      if (activeFilters[type].has(value)) {
        activeFilters[type].delete(value);
        this.classList.remove("active");
      } else {
        activeFilters[type].add(value);
        this.classList.add("active");
      }
      if (type.startsWith("pipeline")) {
        filterPipelines();
      } else {
        filterDatasources();
      }
    });
  });
}
function filterPipelines() {
  const searchTerm = document.getElementById("pipeline-search").value.toLowerCase();
  const rows = document.querySelectorAll(".pipeline-row");
  rows.forEach((row) => {
    const name = row.getAttribute("data-name");
    const description = row.getAttribute("data-description");
    const tags = row.getAttribute("data-tags").split(",").filter((t) => t);
    const cluster = row.getAttribute("data-cluster");
    const matchesSearch = !searchTerm || name.includes(searchTerm) || description.includes(searchTerm);
    const matchesTag = activeFilters.pipelineTags.size === 0 || tags.some((t) => activeFilters.pipelineTags.has(t));
    const matchesCluster = activeFilters.pipelineClusters.size === 0 || activeFilters.pipelineClusters.has(cluster);
    row.style.display = matchesSearch && matchesTag && matchesCluster ? "" : "none";
  });
}
function filterDatasources() {
  const searchTerm = document.getElementById("datasource-search").value.toLowerCase();
  const rows = document.querySelectorAll(".datasource-row");
  rows.forEach((row) => {
    const searchContent = row.getAttribute("data-search");
    const type = row.getAttribute("data-type");
    const tags = row.getAttribute("data-tags").split(",").filter((t) => t);
    const cluster = row.getAttribute("data-cluster");
    const matchesSearch = !searchTerm || searchContent.includes(searchTerm);
    const matchesType = activeFilters.datasourceTypes.size === 0 || activeFilters.datasourceTypes.has(type);
    const matchesTag = activeFilters.datasourceTags.size === 0 || tags.some((t) => activeFilters.datasourceTags.has(t));
    const matchesCluster = activeFilters.datasourceClusters.size === 0 || activeFilters.datasourceClusters.has(cluster);
    row.style.display = matchesSearch && matchesType && matchesTag && matchesCluster ? "" : "none";
  });
}
function updateDotView() {
  const dotOutput = document.getElementById("dot-output");
  if (dotOutput) {
    dotOutput.value = generateGraphvizDot();
  }
}
function copyDotToClipboard(event) {
  const dotOutput = document.getElementById("dot-output");
  if (dotOutput) {
    navigator.clipboard.writeText(dotOutput.value).then(() => {
      const btn = event?.target || document.activeElement;
      const originalText = btn.textContent;
      btn.textContent = "Copied!";
      setTimeout(() => {
        btn.textContent = originalText;
      }, 2e3);
    }).catch(() => {
      dotOutput.select();
      dotOutput.setSelectionRange(0, 99999);
    });
  }
}
function loadExample() {
  document.getElementById("json-input").value = JSON.stringify(exampleConfig, null, 2);
  loadJson();
}
function generateShareableUrl() {
  if (!state.currentConfig) {
    alert("No configuration loaded to share");
    return;
  }
  const configJson = JSON.stringify(state.currentConfig);
  const encodedConfig = btoa(configJson);
  const currentUrl = window.location.origin + window.location.pathname;
  const shareableUrl = `${currentUrl}?config=${encodedConfig}`;
  navigator.clipboard.writeText(shareableUrl).then(() => {
    const statusDiv = document.getElementById("json-status");
    statusDiv.innerHTML = '<div class="alert alert-success">Shareable URL copied to clipboard!</div>';
    setTimeout(() => {
      statusDiv.innerHTML = "";
    }, 3e3);
  }).catch(() => {
    prompt("Copy this shareable URL:", shareableUrl);
  });
}
async function tryLoadPipevizJson() {
  try {
    const response = await fetch("pipeviz.json");
    if (response.ok) {
      const configText = await response.text();
      const parsed = JSON.parse(configText);
      document.getElementById("json-input").value = JSON.stringify(parsed, null, 2);
      loadJson();
      const statusDiv = document.getElementById("json-status");
      statusDiv.innerHTML = '<div class="alert alert-success">Loaded pipeviz.json</div>';
      setTimeout(() => {
        statusDiv.innerHTML = "";
      }, 3e3);
      return true;
    }
  } catch (error) {
  }
  return false;
}
async function loadFromUrl() {
  const urlParams = new URLSearchParams(window.location.search);
  const configParam = urlParams.get("config");
  const viewParam = urlParams.get("view");
  if (configParam) {
    try {
      const decodedConfig = atob(configParam);
      const parsed = JSON.parse(decodedConfig);
      document.getElementById("json-input").value = JSON.stringify(parsed, null, 2);
      loadJson();
      const targetView = viewParam || "graph";
      document.getElementById(targetView + "-tab")?.click();
      return;
    } catch (error) {
      console.error("Error decoding config parameter:", error);
    }
  }
  const urlParam = urlParams.get("url");
  const autoView = urlParams.get("view") || (urlParam ? "graph" : null);
  if (urlParam) {
    fetch(urlParam).then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return response.text();
    }).then((configText) => {
      try {
        const parsed = JSON.parse(configText);
        document.getElementById("json-input").value = JSON.stringify(parsed, null, 2);
        loadJson();
        if (autoView) {
          document.getElementById(autoView + "-tab")?.click();
        }
      } catch (error) {
        document.getElementById("json-input").value = configText;
        loadJson();
      }
    }).catch((error) => {
      const statusDiv = document.getElementById("json-status");
      statusDiv.innerHTML = `<div class="alert alert-danger">Error loading from URL: ${error.message}</div>`;
      if (!state.currentConfig) {
        loadExample();
      }
    });
    return;
  }
  const loaded = await tryLoadPipevizJson();
  if (!loaded && !state.currentConfig) {
    loadExample();
  }
}
function setupDragDrop() {
  const dropZone = document.getElementById("drop-zone");
  const textarea = document.getElementById("json-input");
  ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
    dropZone.addEventListener(eventName, preventDefaults, false);
  });
  function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
  }
  ["dragenter", "dragover"].forEach((eventName) => {
    dropZone.addEventListener(eventName, () => dropZone.classList.add("dragover"), false);
  });
  ["dragleave", "drop"].forEach((eventName) => {
    dropZone.addEventListener(eventName, () => dropZone.classList.remove("dragover"), false);
  });
  dropZone.addEventListener("drop", handleDrop, false);
  function handleDrop(e) {
    const files = e.dataTransfer.files;
    if (files.length > 0) {
      const file = files[0];
      if (file.type === "application/json" || file.name.endsWith(".json")) {
        const reader = new FileReader();
        reader.onload = function(e2) {
          try {
            const parsed = JSON.parse(e2.target.result);
            textarea.value = JSON.stringify(parsed, null, 2);
            loadJson();
          } catch (error) {
            textarea.value = e2.target.result;
            loadJson();
          }
        };
        reader.readAsText(file);
      } else {
        const statusDiv = document.getElementById("json-status");
        statusDiv.innerHTML = '<div class="alert alert-warning">Please drop a JSON file</div>';
      }
    }
  }
}
function loadFromFile(event) {
  const file = event.target.files[0];
  if (file && (file.type === "application/json" || file.name.endsWith(".json"))) {
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const parsed = JSON.parse(e.target.result);
        document.getElementById("json-input").value = JSON.stringify(parsed, null, 2);
        loadJson();
      } catch (error) {
        document.getElementById("json-input").value = e.target.result;
        loadJson();
      }
    };
    reader.readAsText(file);
  } else {
    const statusDiv = document.getElementById("json-status");
    statusDiv.innerHTML = '<div class="alert alert-warning">Please select a valid JSON file</div>';
  }
}
function setupAutoProcess() {
  const textarea = document.getElementById("json-input");
  const statusDiv = document.getElementById("json-status");
  let timeout;
  textarea.addEventListener("input", function() {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      const content = textarea.value.trim();
      if (!content) {
        statusDiv.innerHTML = "";
        return;
      }
      try {
        JSON.parse(content);
        statusDiv.innerHTML = '<div class="alert alert-success py-1 px-2" style="font-size: 0.85em;">Valid JSON</div>';
        loadJson();
      } catch (e) {
        statusDiv.innerHTML = `<div class="alert alert-danger py-1 px-2" style="font-size: 0.85em;">Invalid JSON: ${e.message}</div>`;
      }
    }, 500);
  });
}
function loadJson() {
  const jsonText = document.getElementById("json-input").value.trim();
  const statusDiv = document.getElementById("json-status");
  if (!jsonText) {
    statusDiv.innerHTML = '<div class="alert alert-warning">Please enter JSON configuration</div>';
    return;
  }
  try {
    state.currentConfig = JSON.parse(jsonText);
    statusDiv.innerHTML = '<div class="alert alert-success">Configuration loaded successfully!</div>';
    renderPipelines();
    renderDatasources();
    updateFilters();
    renderGraph();
    updateDotView();
  } catch (error) {
    statusDiv.innerHTML = `<div class="alert alert-danger">JSON Parse Error: ${error.message}</div>`;
  }
}
window.toggleTheme = toggleTheme;
window.loadExample = loadExample;
window.loadFromFile = loadFromFile;
window.generateShareableUrl = generateShareableUrl;
window.filterPipelines = filterPipelines;
window.filterDatasources = filterDatasources;
window.clearSelection = clearSelection;
window.resetGraph = resetGraph;
window.collapseAllGroups = collapseAllGroups;
window.toggleGroup = toggleGroup;
window.togglePipelinesOnly = togglePipelinesOnly;
window.searchNodes = searchNodes;
window.selectSearchResult = selectSearchResult;
window.clearAttributeSelection = clearAttributeSelection;
window.resetAttributeGraph = resetAttributeGraph;
window.searchAttributes = searchAttributes;
window.selectAttributeFromSearch = selectAttributeFromSearch;
window.updateDotView = updateDotView;
window.copyDotToClipboard = copyDotToClipboard;
document.addEventListener("DOMContentLoaded", () => {
  initTheme();
  setupTabs();
  activateTabFromHash();
});
window.addEventListener("load", () => {
  setupDragDrop();
  setupAutoProcess();
  loadFromUrl();
  renderSplashGraph();
});
window.addEventListener("hashchange", activateTabFromHash);</script>
</head>
<body>
    <div class="container-fluid py-4">
        <div class="hero-section">
            <div class="mb-4 text-center position-relative">
                <div class="header-controls">
                    <a href="https://github.com/mattlianje/pipeviz" target="_blank" style="color: var(--text-muted); font-size: 13px; text-decoration: none;" title="GitHub">github</a>
                    <button class="theme-toggle" onclick="toggleTheme()" title="Toggle dark mode" id="theme-toggle"></button>
                </div>
                <h1 class="hero-title"><img src="https://raw.githubusercontent.com/mattlianje/d4/master/pix/pipeviz.png" alt="Pipeviz logo" style="height: 1.2em; vertical-align: middle; margin-right: 0.25rem;"> Pipeviz</h1>
                <p class="lead">Easy, elegant lineage from a single <span style="color: #d63384;">.json</span></p>
            </div>

            <ul class="nav nav-tabs hidden-on-home" id="dashboardTabs">
                <li class="nav-item">
                    <button class="nav-link active" id="home-tab" data-bs-toggle="tab" data-bs-target="#home-pane">Home</button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="spec-tab" data-bs-toggle="tab" data-bs-target="#spec-pane">Spec</button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="config-tab" data-bs-toggle="tab" data-bs-target="#config-pane">Config</button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="graph-tab" data-bs-toggle="tab" data-bs-target="#graph-pane">Graph</button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="attributes-tab" data-bs-toggle="tab" data-bs-target="#attributes-pane">Attributes</button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="pipelines-tab" data-bs-toggle="tab" data-bs-target="#pipelines-pane">Pipelines</button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="datasources-tab" data-bs-toggle="tab" data-bs-target="#datasources-pane">Datasources</button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="dot-tab" data-bs-toggle="tab" data-bs-target="#dot-pane">Dot</button>
                </li>
            </ul>

            <div class="tab-content">
                <!-- Home Tab -->
                <div class="tab-pane fade show active" id="home-pane">
                    <div style="max-width: 750px; margin: 0 auto; padding: 2rem 1rem;">

                        <!-- Intro -->
                        <p style="font-size: 14px; color: var(--text-secondary); line-height: 1.7; margin-bottom: 1.5rem;">
                            An open source JSON spec for lineage. Declare your pipelines, get beautiful graphs.
                        </p>

                        <!-- Demo -->
                        <div style="display: flex; gap: 1.5rem; align-items: center; justify-content: center; flex-wrap: wrap; margin-bottom: 2rem;">
<pre class="hero-animate hero-animate-1" style="padding: 1rem; font-size: 13px; margin: 0; color: var(--text-primary);">{
  "pipelines": [{
    "name": "etl-job",
    "input_sources": ["raw_events"],
    "output_sources": ["cleaned_events"]
  }]
}</pre>
                            <svg class="hero-animate hero-animate-2" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="color: var(--text-muted); flex-shrink: 0;">
                                <path d="M5 12h14M13 5l7 7-7 7"/>
                            </svg>
                            <div id="splash-graph" class="hero-animate hero-animate-3" style="min-width: 240px; min-height: 120px; display: flex; align-items: center; justify-content: center;"></div>
                        </div>

                        <!-- Buttons -->
                        <div class="hero-animate hero-animate-4" style="display: flex; gap: 0.75rem; justify-content: center; margin-bottom: 2.5rem;">
                            <button class="btn btn-dark" onclick="loadExample(); document.getElementById('graph-tab').click();">
                                Try demo
                            </button>
                            <button class="btn btn-outline-secondary" onclick="document.getElementById('spec-tab').click();">
                                Read spec
                            </button>
                        </div>

                        <!-- Feature tiles -->
                        <div class="feature-grid">
                            <div class="feature-tile">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" class="feature-icon">
                                    <rect x="4" y="4" width="6" height="6" rx="1"/><rect x="14" y="4" width="6" height="6" rx="1"/><rect x="4" y="14" width="6" height="6" rx="1"/><rect x="14" y="14" width="6" height="6" rx="1"/>
                                </svg>
                                <div style="font-size: 12px; color: var(--text-primary); font-weight: 600; margin-bottom: 0.2rem;">Stack Agnostic</div>
                                <div style="font-size: 11px; color: var(--text-secondary); line-height: 1.4;">SQL, Spark, Kafka, APIs, shell scripts. Just JSON.</div>
                            </div>
                            <div class="feature-tile">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" class="feature-icon">
                                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/>
                                </svg>
                                <div style="font-size: 12px; color: var(--text-primary); font-weight: 600; margin-bottom: 0.2rem;">Zero Dependencies</div>
                                <div style="font-size: 11px; color: var(--text-secondary); line-height: 1.4;">One HTML file. No backend, no build step. Host anywhere.</div>
                            </div>
                            <div class="feature-tile">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" class="feature-icon">
                                    <circle cx="6" cy="6" r="3"/><circle cx="18" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="18" r="3"/><path d="M6 9v6m12-6v6M9 6h6m-6 12h6"/>
                                </svg>
                                <div style="font-size: 12px; color: var(--text-primary); font-weight: 600; margin-bottom: 0.2rem;">Federated</div>
                                <div style="font-size: 11px; color: var(--text-secondary); line-height: 1.4;">Each team owns their JSON. Merge with jq for the org-wide view.</div>
                            </div>
                            <div class="feature-tile">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" class="feature-icon">
                                    <path d="M3 6h18M3 12h18M3 18h18"/><circle cx="7" cy="6" r="1.5" fill="currentColor"/><circle cx="14" cy="12" r="1.5" fill="currentColor"/><circle cx="10" cy="18" r="1.5" fill="currentColor"/>
                                </svg>
                                <div style="font-size: 12px; color: var(--text-primary); font-weight: 600; margin-bottom: 0.2rem;">Column-Level Lineage</div>
                                <div style="font-size: 11px; color: var(--text-secondary); line-height: 1.4;">Track field-level provenance. See where each attribute comes from.</div>
                            </div>
                        </div>

                        <!-- How it works -->
                        <div style="margin-bottom: 2rem;">
                            <div style="font-size: 12px; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">How it works</div>
                            <div style="display: flex; justify-content: space-between; gap: 1.5rem; flex-wrap: wrap;">
                                <div style="flex: 1; min-width: 140px; text-align: center;">
                                    <div style="font-size: 1.25rem; color: var(--text-muted); margin-bottom: 0.2rem;">1</div>
                                    <div style="font-size: 12px; font-weight: 600; color: var(--text-primary); margin-bottom: 0.2rem;">Define</div>
                                    <div style="font-size: 11px; color: var(--text-secondary); line-height: 1.4;">Write a <code>pipeviz.json</code> describing your pipelines and data sources</div>
                                </div>
                                <div style="flex: 1; min-width: 140px; text-align: center;">
                                    <div style="font-size: 1.25rem; color: var(--text-muted); margin-bottom: 0.2rem;">2</div>
                                    <div style="font-size: 12px; font-weight: 600; color: var(--text-primary); margin-bottom: 0.2rem;">Load</div>
                                    <div style="font-size: 11px; color: var(--text-secondary); line-height: 1.4;">Drop your file here, or host both files together on any static server</div>
                                </div>
                                <div style="flex: 1; min-width: 140px; text-align: center;">
                                    <div style="font-size: 1.25rem; color: var(--text-muted); margin-bottom: 0.2rem;">3</div>
                                    <div style="font-size: 12px; font-weight: 600; color: var(--text-primary); margin-bottom: 0.2rem;">Explore</div>
                                    <div style="font-size: 11px; color: var(--text-secondary); line-height: 1.4;">Click through the graph, trace dependencies, export DOT for other tools</div>
                                </div>
                            </div>
                        </div>

                        <!-- Merging configs -->
                        <div style="margin-bottom: 2rem;">
                            <div style="font-size: 12px; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Merging configs</div>
<pre style="background: var(--bg-code); padding: 0.75rem; font-size: 12px; margin: 0; overflow-x: auto; color: var(--text-primary);"><span style="color: var(--text-muted);"># each team versions their own pipeviz.json</span>
<span style="color: var(--text-muted);"># merge for org-wide view</span>
jq -s '{
  pipelines: map(.pipelines // []) | add,
  datasources: map(.datasources // []) | add
}' team-*.json > pipeviz.json</pre>
                        </div>

                        <!-- Motivation -->
                        <div style="margin-bottom: 2rem;">
                            <div style="font-size: 12px; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Why</div>
                            <p style="font-size: 13px; color: var(--text-secondary); line-height: 1.6; margin: 0;">
                                <a href="https://openlineage.io/" target="_blank" style="color: var(--text-secondary);">OpenLineage</a>/<a href="https://marquezproject.ai/" target="_blank" style="color: var(--text-secondary);">Marquez</a> need agents, a metadata store, scheduler integration. <a href="https://atlas.apache.org/" target="_blank" style="color: var(--text-secondary);">Atlas</a> wants a governance platform. <a href="https://www.getdbt.com/" target="_blank" style="color: var(--text-secondary);">dbt</a> couples you to their framework. Pipeviz needs one JSON file.
                            </p>
                        </div>

                    </div>
                </div>

                <!-- Configuration Tab -->
                <div class="tab-pane fade" id="config-pane">
                    <div style="max-width: 900px; padding: 1rem 0;">
                        <div class="drop-zone" id="drop-zone">
                            <textarea class="form-control json-editor" id="json-input" rows="22"
                                      placeholder="Paste JSON here or drag & drop a file"></textarea>
                        </div>
                        <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; margin-top: 0.75rem;">
                            <input type="file" id="file-input" accept=".json" style="display: none;" onchange="loadFromFile(event)">
                            <button class="btn btn-outline-secondary btn-sm" onclick="document.getElementById('file-input').click()">Browse</button>
                            <button class="btn btn-outline-secondary btn-sm" onclick="loadExample()">Load Example</button>
                            <button class="btn btn-outline-secondary btn-sm" onclick="generateShareableUrl()">Share URL</button>
                            <span style="color: var(--text-muted); font-size: 12px; margin-left: auto;">Auto-load: <code style="font-size: 11px;">?url=your-json-url</code></span>
                        </div>
                        <div id="json-status" style="margin-top: 0.5rem;"></div>
                    </div>
                </div>

                <!-- Pipelines Tab -->
                <div class="tab-pane fade" id="pipelines-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="mb-3">
                                <input type="text" class="form-control" id="pipeline-search"
                                       placeholder="Search pipelines..." onkeyup="filterPipelines()" style="max-width: 300px;">
                            </div>
                            <div class="mb-3" id="pipeline-filters"></div>
                            <div id="pipelines-table-container">
                                <p class="text-muted text-center">Load a configuration to see your pipelines</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Data Sources Tab -->
                <div class="tab-pane fade" id="datasources-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="mb-3">
                                <input type="text" class="form-control" id="datasource-search"
                                       placeholder="Search data sources..." onkeyup="filterDatasources()" style="max-width: 300px;">
                            </div>
                            <div class="mb-3" id="datasource-filters"></div>
                            <div id="datasources-table-container">
                                <p class="text-muted text-center">Load a configuration to see your data sources</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Graph Tab -->
                <div class="tab-pane fade" id="graph-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="row mb-3">
                                <div class="col-md-4">
                                    <div class="position-relative">
                                        <input type="text" class="form-control" id="graph-search"
                                               placeholder="Search nodes..." onkeydown="searchNodes(event)">
                                        <div id="graph-search-results" class="search-results-dropdown"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="row">
                                <div id="graph-col" class="col-md-12">
                                    <div class="graph-container position-relative">
                                        <div class="graph-controls">
                                            <div class="btn-group me-2">
                                                <button class="btn btn-sm btn-outline-secondary" onclick="togglePipelinesOnly()" id="pipelines-only-btn">
                                                    Pipelines Only
                                                </button>
                                            </div>
                                            <div class="btn-group me-2">
                                                <button class="btn btn-sm btn-outline-secondary" onclick="collapseAllGroups()">
                                                    Collapse All
                                                </button>
                                            </div>
                                            <div class="btn-group me-2">
                                                <button class="btn btn-sm btn-outline-warning" onclick="clearSelection()">
                                                    Clear Selection
                                                </button>
                                            </div>
                                            <button class="btn btn-sm btn-outline-secondary" onclick="resetGraph()">Reset</button>
                                        </div>
                                        <div id="graph">
                                            <div class="graph-loading text-center py-5 text-muted">
                                                <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                                                Loading graph...
                                            </div>
                                        </div>
                                        <div class="legend">
                                            <div><strong>Legend:</strong></div>
                                            <div> = Pipeline</div>
                                            <div style="color: #00897b;"> = Group</div>
                                            <div> = Data Source</div>
                                            <div> = Cluster</div>
                                            <div> = Data flow</div>
                                            <div style="color: #ff6b35;"> = Dependency</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4" id="node-details-col" style="display: none;">
                                    <div class="node-details-panel" id="node-details-panel">
                                        <div id="node-details-content"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Attributes Tab -->
                <div class="tab-pane fade" id="attributes-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="row mb-3">
                                <div class="col-md-4">
                                    <div class="position-relative">
                                        <input type="text" class="form-control" id="attribute-search"
                                               placeholder="Search attributes..." onkeydown="searchAttributes(event)">
                                        <div id="attribute-search-results" class="search-results-dropdown"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="row">
                                <div id="attribute-graph-col" class="col-md-12">
                                    <div class="graph-container position-relative">
                                        <div class="graph-controls">
                                            <div class="btn-group me-2">
                                                <button class="btn btn-sm btn-outline-warning" onclick="clearAttributeSelection()">
                                                    Clear Selection
                                                </button>
                                            </div>
                                            <button class="btn btn-sm btn-outline-secondary" onclick="resetAttributeGraph()">Reset</button>
                                        </div>
                                        <div id="attribute-graph">
                                            <div class="graph-loading text-center py-5 text-muted">
                                                <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                                                Loading graph...
                                            </div>
                                        </div>
                                        <div class="legend">
                                            <div><strong>Legend:</strong></div>
                                            <div> = Data Source</div>
                                            <div> = Attribute</div>
                                            <div> = Derived from</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4" id="attribute-details-col" style="display: none;">
                                    <div class="node-details-panel" id="attribute-details-panel">
                                        <div id="attribute-details-content"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Raw DOT Tab -->
                <div class="tab-pane fade" id="dot-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h5 class="mb-0">Generated Graphviz DOT</h5>
                                <div>
                                    <button class="btn btn-sm btn-outline-info me-2" onclick="updateDotView()">Refresh</button>
                                    <button class="btn btn-sm btn-outline-secondary" onclick="copyDotToClipboard(event)">Copy to Clipboard</button>
                                </div>
                            </div>
                            <textarea class="form-control json-editor" id="dot-output" rows="25" readonly
                                      placeholder="Load a configuration to see the generated DOT code..."></textarea>
                        </div>
                    </div>
                </div>

                <!-- Spec Tab -->
                <div class="tab-pane fade" id="spec-pane">
                    <div style="max-width: 800px; padding: 1rem 0;">
                        <style>
                            .spec-table { width: 100%; border-collapse: collapse; font-size: 12px; margin: 0.75rem 0 1rem 0; }
                            .spec-table th, .spec-table td { padding: 6px 10px; border: 1px solid var(--border-color); text-align: left; }
                            .spec-table th { background: var(--bg-secondary); }
                            .spec-section { margin-bottom: 2rem; }
                            .spec-section h6 { font-weight: 600; margin-bottom: 0.5rem; }
                            .spec-pre { background: var(--bg-code); border: 1px solid var(--border-color); padding: 12px; font-size: 12px; color: var(--text-primary); margin: 0; }
                        </style>

                        <div style="margin-bottom: 1.5rem;">
                            <h5 style="font-weight: 600; margin-bottom: 0.25rem;">Pipeviz JSON Spec</h5>
                            <p style="color: var(--text-secondary); font-size: 13px;">Only <code>pipelines</code> is required. Clusters and datasources are auto-created when referenced.</p>
                        </div>

                        <div class="spec-section">
                            <h6>Root</h6>
                            <table class="spec-table">
                                <tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr>
                                <tr><td><code>pipelines</code></td><td>array</td><td>Yes</td><td>Jobs that transform or move data</td></tr>
                                <tr><td><code>datasources</code></td><td>array</td><td>No</td><td>Tables, files, streams, APIs</td></tr>
                                <tr><td><code>clusters</code></td><td>array</td><td>No</td><td>Groups for visual organization</td></tr>
                            </table>
<pre class="spec-pre">{
  "clusters": [...],
  "pipelines": [...],
  "datasources": [...]
}</pre>
                        </div>

                        <div class="spec-section">
                            <h6>Pipeline</h6>
                            <table class="spec-table">
                                <tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr>
                                <tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Unique identifier</td></tr>
                                <tr><td><code>description</code></td><td>string</td><td>No</td><td></td></tr>
                                <tr><td><code>input_sources</code></td><td>array</td><td>No</td><td>Datasources read from</td></tr>
                                <tr><td><code>output_sources</code></td><td>array</td><td>No</td><td>Datasources written to</td></tr>
                                <tr><td><code>upstream_pipelines</code></td><td>array</td><td>No</td><td>Pipeline or group names (orange edges)</td></tr>
                                <tr><td><code>cluster</code></td><td>string</td><td>No</td><td>Cluster name</td></tr>
                                <tr><td><code>group</code></td><td>string</td><td>No</td><td>Collapse into group node</td></tr>
                                <tr><td><code>schedule</code></td><td>string</td><td>No</td><td>Free text</td></tr>
                                <tr><td><code>tags</code></td><td>array</td><td>No</td><td></td></tr>
                                <tr><td><code>links</code></td><td>object</td><td>No</td><td>name to URL</td></tr>
                            </table>
<pre class="spec-pre">{
  "name": "user-enrichment",
  "description": "Enriches user data with events",
  "input_sources": ["raw_users", "events"],
  "output_sources": ["enriched_users"],
  "upstream_pipelines": ["data-ingestion"],
  "cluster": "user-processing",
  "group": "etl-jobs",
  "schedule": "Every 2 hours",
  "tags": ["user-data", "ml"],
  "links": {
    "airflow": "https://...",
    "docs": "https://..."
  }
}</pre>
                        </div>

                        <div class="spec-section">
                            <h6>Datasource</h6>
                            <p style="color: var(--text-secondary); font-size: 12px; margin-bottom: 0.5rem;">Auto-created when referenced. Define explicitly to add metadata.</p>
                            <table class="spec-table">
                                <tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr>
                                <tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Unique identifier</td></tr>
                                <tr><td><code>description</code></td><td>string</td><td>No</td><td></td></tr>
                                <tr><td><code>type</code></td><td>string</td><td>No</td><td>snowflake, postgres, kafka, s3...</td></tr>
                                <tr><td><code>owner</code></td><td>string</td><td>No</td><td></td></tr>
                                <tr><td><code>cluster</code></td><td>string</td><td>No</td><td></td></tr>
                                <tr><td><code>tags</code></td><td>array</td><td>No</td><td></td></tr>
                                <tr><td><code>metadata</code></td><td>object</td><td>No</td><td>Arbitrary key-value</td></tr>
                                <tr><td><code>links</code></td><td>object</td><td>No</td><td>name to URL</td></tr>
                                <tr><td><code>attributes</code></td><td>array</td><td>No</td><td>Column-level lineage</td></tr>
                            </table>
<pre class="spec-pre">{
  "name": "raw_users",
  "description": "Raw user data from prod",
  "type": "snowflake",
  "owner": "data-team@company.com",
  "cluster": "user-processing",
  "tags": ["pii", "users"],
  "metadata": {
    "size": "2.1TB",
    "record_count": "45M"
  },
  "links": {
    "snowflake": "https://...",
    "docs": "https://..."
  }
}</pre>
                        </div>

                        <div class="spec-section">
                            <h6>Cluster</h6>
                            <p style="color: var(--text-secondary); font-size: 12px; margin-bottom: 0.5rem;">Auto-created when referenced. Define explicitly for nesting.</p>
                            <table class="spec-table">
                                <tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr>
                                <tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Unique identifier</td></tr>
                                <tr><td><code>description</code></td><td>string</td><td>No</td><td></td></tr>
                                <tr><td><code>parent</code></td><td>string</td><td>No</td><td>Parent cluster for nesting</td></tr>
                            </table>
<pre class="spec-pre">{
  "name": "realtime",
  "description": "Real-time processing cluster",
  "parent": "order-processing"
}</pre>
                        </div>

                        <div class="spec-section">
                            <h6>Attribute Lineage</h6>
                            <p style="color: var(--text-secondary); font-size: 12px; margin-bottom: 0.5rem;">Add <code>attributes</code> to a datasource. Supports nesting for structs/objects. Reference upstream with <code>source::attr</code> or <code>source::parent::child</code>.</p>
                            <table class="spec-table">
                                <tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr>
                                <tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Column/field name</td></tr>
                                <tr><td><code>from</code></td><td>string or array</td><td>No</td><td>Upstream refs</td></tr>
                                <tr><td><code>attributes</code></td><td>array</td><td>No</td><td>Nested child attributes</td></tr>
                            </table>
<pre class="spec-pre">{
  "name": "enriched_users",
  "attributes": [
    { "name": "user_id", "from": "raw_users::id" },
    {
      "name": "location",
      "from": "raw_users::address",
      "attributes": [
        { "name": "city", "from": "raw_users::address::city" },
        { "name": "zip", "from": "raw_users::address::zip" }
      ]
    }
  ]
}</pre>
                        </div>

                        <div class="spec-section">
                            <h6>Full Example</h6>
<pre class="spec-pre">{
  "clusters": [
    { "name": "etl", "description": "ETL pipelines" }
  ],
  "pipelines": [
    {
      "name": "user-enrichment",
      "description": "Enriches user data with events",
      "input_sources": ["raw_users", "events"],
      "output_sources": ["enriched_users"],
      "cluster": "etl",
      "schedule": "Every 2 hours",
      "tags": ["user-data"],
      "links": { "airflow": "https://..." }
    }
  ],
  "datasources": [
    {
      "name": "raw_users",
      "type": "snowflake",
      "owner": "data-team@company.com",
      "attributes": [
        { "name": "id" },
        { "name": "first" },
        { "name": "last" }
      ]
    },
    {
      "name": "enriched_users",
      "type": "snowflake",
      "attributes": [
        { "name": "user_id", "from": "raw_users::id" },
        { "name": "full_name", "from": ["raw_users::first", "raw_users::last"] }
      ]
    }
  ]
}</pre>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Spec Modal -->
    <div class="modal fade" id="specModal" tabindex="-1" aria-labelledby="specModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="specModalLabel">json spec</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-4">
                        <h6>Overview</h6>
                        <p class="text-muted">Pipeviz uses a simple JSON configuration to define your data lineage. Only pipelines are required. Clusters and datasources are auto-created when referenced, but you can add rich descriptors for better documentation.</p>
                    </div>

                    <div class="mb-4">
                        <h6>Root Structure</h6>
                        <pre class="bg-light p-3 rounded"><code>{
  "clusters": [ ... ],     // Optional: cluster definitions
  "pipelines": [ ... ],    // Required: pipeline definitions
  "datasources": [ ... ]   // Optional: rich data source definitions
}</code></pre>
                    </div>

                    <div class="mb-4">
                        <h6>Clusters (Optional)</h6>
                        <p class="text-muted small">Clusters can be optionally declared upfront or referenced on-the-fly. Support nested hierarchies with parent relationships.</p>
                        <pre class="bg-light p-3 rounded"><code>{
  "name": "real-time",
  "description": "Real-time processing cluster",  // Optional
  "parent": "order-management"                    // Optional: creates nested cluster
}</code></pre>
                    </div>

                    <div class="mb-4">
                        <h6>Pipelines</h6>
                        <pre class="bg-light p-3 rounded"><code>{
  "name": "user-enrichment",
  "description": "Enriches user data...",       // Optional
  "input_sources": ["raw_users", "events"],     // Optional
  "output_sources": ["enriched_users"],         // Optional
  "schedule": "Every 2 hours",                  // Optional
  "tags": ["user-data", "ml"],                  // Optional
  "cluster": "user-processing",                 // Optional: single cluster
  "upstream_pipelines": ["data-ingestion"],     // Optional
  "links": {                                    // Optional
    "airflow": "https://...",
    "monitoring": "https://..."
  }
}</code></pre>
                    </div>

                    <div class="mb-4">
                        <h6>Data Sources (Optional)</h6>
                        <p class="text-muted small">Data sources are auto-created when referenced in pipelines. Define them explicitly to add rich metadata, ownership, and documentation.</p>
                        <pre class="bg-light p-3 rounded"><code>{
  "name": "raw_users",
  "description": "Raw user data...",            // Optional
  "type": "snowflake",                          // Optional
  "owner": "data-team@company.com",             // Optional
  "tags": ["pii", "users"],                     // Optional
  "cluster": "user-processing",                 // Optional: single cluster
  "metadata": {                                 // Optional
    "size": "2.1TB",
    "record_count": "45M"
  },
  "links": {                                    // Optional
    "snowflake": "https://...",
    "docs": "https://..."
  }
}</code></pre>
                    </div>

                    <div class="alert alert-info">
                        <strong>Tips:</strong>
                        <ul class="mb-0 mt-2">
                            <li>Only <code>pipelines</code> array with pipeline <code>name</code> fields is required</li>
                            <li>Clusters and datasources are auto-created when referenced in pipelines</li>
                            <li>Define datasources explicitly to add rich metadata, ownership, and links</li>
                            <li>Use <code>cluster</code> (singular) to assign nodes to one cluster each</li>
                            <li>Create nested clusters using the <code>parent</code> field in cluster definitions</li>
                            <li>Use <code>upstream_pipelines</code> to show pipeline dependencies</li>
                            <li>Links can point to any external tools (Airflow, monitoring, docs, etc.)</li>
                        </ul>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
