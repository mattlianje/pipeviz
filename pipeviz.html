<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipeviz</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üõ∞Ô∏è</text></svg>">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/@hpcc-js/wasm@2.13.0/dist/graphviz.umd.js"></script>
    <script src="https://unpkg.com/d3-graphviz@5.0.2/build/d3-graphviz.min.js"></script>
    <style>
        :root {
            --bg-primary: #fff;
            --bg-secondary: #f5f5f5;
            --bg-code: #f5f5f5;
            --text-primary: #000;
            --text-secondary: #666;
            --text-muted: #828282;
            --border-color: #ccc;
            --border-light: #eee;
        }
        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #252525;
            --bg-code: #2d2d2d;
            --text-primary: #e0e0e0;
            --text-secondary: #aaa;
            --text-muted: #888;
            --border-color: #444;
            --border-light: #333;
        }
        html {
            overflow-y: scroll;
        }
        body {
            background-color: var(--bg-primary);
            min-height: 100vh;
            font-family: Verdana, Geneva, sans-serif;
            font-size: 13px;
            color: var(--text-primary);
        }
        .hero-section {
            background: var(--bg-primary);
            margin: 1rem auto;
            padding: 1.5rem 4rem;
            max-width: 1600px;
        }
        @media (max-width: 768px) {
            .hero-section {
                padding: 1.5rem 1.5rem;
            }
        }
        .nav-tabs {
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 1.5rem;
        }
        .nav-tabs .nav-link {
            border: none;
            color: var(--text-muted);
            font-weight: 400;
            padding: 6px 12px;
            margin-right: 2px;
            background: transparent;
            border-radius: 0;
            font-size: 12px;
        }
        .nav-tabs .nav-link:hover {
            color: var(--text-primary);
            background-color: var(--bg-secondary);
        }
        .nav-tabs .nav-link.active {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            border-bottom: 2px solid var(--text-primary);
        }
        .nav-tabs.hidden-on-home {
            display: none;
        }
        .card {
            border: none;
            border-radius: 0;
            box-shadow: none;
            background: transparent;
        }
        .card-body {
            padding: 0;
        }
        .table-container {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        .table {
            background: var(--bg-primary);
            font-size: 13px;
            border-collapse: collapse;
        }
        .table th {
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            font-weight: bold;
            color: var(--text-primary);
            white-space: nowrap;
            font-size: 11px;
        }
        .table td {
            border-bottom: 1px solid var(--border-light);
            vertical-align: top;
            color: var(--text-primary);
        }
        .table tr:last-child td {
            border-bottom: none;
        }
        .table .col-name {
            min-width: 140px;
            white-space: nowrap;
        }
        .table .col-desc {
            min-width: 200px;
            max-width: 400px;
        }
        .table .col-schedule {
            min-width: 100px;
            white-space: nowrap;
        }
        .table .col-sources {
            min-width: 140px;
            max-width: 300px;
        }
        .table .col-cluster {
            min-width: 80px;
        }
        .table .col-tags {
            min-width: 120px;
            max-width: 280px;
        }
        .table .col-links {
            min-width: 100px;
        }
        .table .col-owner {
            min-width: 140px;
            max-width: 250px;
        }
        .table .col-metadata {
            min-width: 160px;
            max-width: 320px;
        }
        .badge {
            font-weight: normal;
            font-size: 11px;
            padding: 2px 5px;
            border-radius: 2px;
            display: inline-block;
            margin-bottom: 2px;
        }
        .badge-snowflake { background-color: #e8f4fd; color: #0366d6; border: 1px solid #0366d6; }
        .badge-delta { background-color: #fff3e0; color: #e65100; border: 1px solid #e65100; }
        .badge-s3 { background-color: #fff8e1; color: #f57c00; border: 1px solid #f57c00; }
        .badge-api { background-color: #e8f5e9; color: #2e7d32; border: 1px solid #2e7d32; }
        .badge-database { background-color: #f3e5f5; color: #7b1fa2; border: 1px solid #7b1fa2; }
        .badge-tag { background-color: #fff3e0; color: #e65100; border: 1px solid #e65100; }
        .badge-cluster { background-color: #e3f2fd; color: #1565c0; border: 1px solid #1565c0; }
        .graph-container {
            background: var(--bg-primary);
            min-height: 500px;
            position: relative;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }
        .graph-container svg {
            max-width: 100%;
        }
        .graph-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        #graph svg {
            width: 100%;
            height: 500px;
        }
        .legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: var(--bg-primary);
            padding: 8px 12px;
            font-size: 11px;
            max-width: 160px;
            opacity: 0.9;
            color: var(--text-primary);
        }
        .json-editor {
            font-family: monospace;
            font-size: 12px;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        .json-editor:focus {
            border-color: var(--text-muted);
            box-shadow: none;
            outline: none;
        }
        .node-highlighted {
            stroke: #d32f2f !important;
            stroke-width: 4px !important;
            filter: drop-shadow(0 0 8px rgba(211, 47, 47, 0.6));
        }
        .node-highlighted polygon,
        .node-highlighted ellipse,
        .node-highlighted path {
            fill: #ffcdd2 !important;
        }
        .node-highlighted text {
            font-weight: normal !important;
            fill: #000 !important;
            stroke: none !important;
            stroke-width: 0 !important;
        }
        .node-connected {
            stroke: #64748b !important;
            stroke-width: 2px !important;
            filter: drop-shadow(0 0 3px rgba(100, 116, 139, 0.3));
        }
        .node-connected text {
            font-weight: normal !important;
            fill: #000 !important;
            stroke: none !important;
            stroke-width: 0 !important;
        }
        .node-dimmed {
            opacity: 0.3 !important;
        }
        .edge-highlighted {
            stroke: #555555 !important;
            stroke-width: 2px !important;
        }
        .edge-dimmed {
            opacity: 0.2 !important;
        }
        .node-tooltip {
            position: absolute;
            background: #000;
            color: #fff;
            padding: 6px 8px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            max-width: 280px;
            white-space: pre-line;
        }
        .node {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .node:hover {
            stroke-width: 2px !important;
            filter: drop-shadow(0 0 4px rgba(0, 0, 0, 0.3));
        }
        .node:hover text {
            font-weight: normal !important;
            fill: #000 !important;
            stroke: none !important;
            stroke-width: 0 !important;
        }
        .node-details-panel {
            background: var(--bg-primary);
            padding: 1rem;
            min-height: 500px;
            max-height: 500px;
            overflow-y: auto;
        }
        .node-details-panel h5 {
            color: var(--text-primary);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            font-weight: bold;
            font-size: 13px;
        }
        .node-details-panel .detail-label {
            font-size: 10px;
            color: var(--text-muted);
            font-weight: bold;
            margin-bottom: 0.25rem;
        }
        .node-details-panel .detail-value {
            margin-bottom: 1rem;
            font-size: 12px;
            color: var(--text-primary);
        }
        .lineage-link {
            margin-bottom: 4px;
            cursor: pointer;
            color: #0366d6;
        }
        .lineage-link:hover {
            text-decoration: underline;
        }
        [data-theme="dark"] .lineage-link {
            color: #58a6ff;
        }
        .node-details-panel .detail-value:last-child {
            margin-bottom: 0;
        }
        .node-details-panel .links-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #eee;
        }
        .node-details-panel .link-btn {
            display: inline-block;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
            border-color: var(--border-color);
            color: var(--text-secondary);
            background: var(--bg-secondary);
        }
        .node-details-panel .link-btn:hover {
            background-color: var(--text-secondary);
            border-color: var(--text-secondary);
            color: var(--bg-primary);
        }
        [data-theme="dark"] .node-details-panel .link-btn {
            border-color: #666;
            color: #ccc;
            background: #333;
        }
        [data-theme="dark"] .node-details-panel .link-btn:hover {
            background-color: #888;
            border-color: #888;
            color: #fff;
        }
        .search-results-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-top: none;
            max-height: 300px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }
        .search-results-dropdown.show {
            display: block;
        }
        .search-result-item {
            padding: 6px 10px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--text-primary);
        }
        .search-result-item:last-child {
            border-bottom: none;
        }
        .search-result-item:hover {
            background-color: var(--bg-secondary);
        }
        .search-result-item .result-type {
            font-size: 9px;
            padding: 2px 4px;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .search-result-item .result-type.pipeline {
            background-color: #e3f2fd;
            color: #1565c0;
            border: 1px solid #1565c0;
        }
        .search-result-item .result-type.datasource {
            background-color: #f3e5f5;
            color: #7b1fa2;
            border: 1px solid #7b1fa2;
        }
        .search-result-item .result-name {
            font-weight: 400;
        }
        .search-result-item .result-match {
            color: #d84315;
            font-weight: 600;
        }
        .btn {
            border-radius: 0;
            font-size: 12px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .btn-primary {
            background-color: #333;
            border-color: #333;
            color: #fff;
        }
        .btn-primary:hover {
            background-color: #000;
            border-color: #000;
            color: #fff;
        }
        .btn-outline-primary {
            color: #333;
            border-color: #333;
        }
        .btn-outline-primary:hover {
            background-color: #333;
            border-color: #333;
            color: #fff;
        }
        .btn-outline-secondary {
            color: #666;
            border-color: #999;
        }
        .btn-outline-secondary:hover {
            background-color: #666;
            border-color: #666;
            color: #fff;
        }
        .btn-outline-warning {
            color: #b45309;
            border-color: #b45309;
        }
        .btn-outline-warning:hover {
            background-color: #b45309;
            border-color: #b45309;
            color: #fff;
        }
        .btn-outline-info {
            color: #0369a1;
            border-color: #0369a1;
        }
        .btn-outline-info:hover {
            background-color: #0369a1;
            border-color: #0369a1;
            color: #fff;
        }
        .hero-title {
            color: var(--text-primary);
            font-weight: bold;
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            letter-spacing: -0.5px;
        }
        .link-icon {
            text-decoration: none;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 12px;
            margin: 2px;
            display: inline-block;
        }
        .link-icon:hover {
            background: #555;
            border-color: #555;
            color: #fff;
        }
        [data-theme="dark"] .link-icon {
            background: #333;
            border-color: #555;
            color: #ccc;
        }
        [data-theme="dark"] .link-icon:hover {
            background: #666;
            border-color: #666;
            color: #fff;
        }
        .form-control, .form-select {
            border-radius: 0;
            border: 1px solid var(--border-color);
            font-size: 13px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        .form-control:focus, .form-select:focus {
            border-color: var(--text-muted);
            box-shadow: none;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        .form-control::placeholder {
            color: var(--text-muted);
        }
        .alert {
            border-radius: 0;
            font-size: 13px;
        }
        .alert-info {
            background-color: #f5f5f5;
            border: 1px solid #ccc;
            color: #333;
        }
        .alert-success {
            background-color: #e8f5e9;
            border: 1px solid #4caf50;
            color: #2e7d32;
        }
        .alert-danger {
            background-color: #ffebee;
            border: 1px solid #f44336;
            color: #c62828;
        }
        .alert-warning {
            background-color: #fff8e1;
            border: 1px solid #ff9800;
            color: #e65100;
        }
        .text-muted {
            color: var(--text-secondary) !important;
        }
        .lead {
            color: var(--text-muted);
            font-size: 12px;
        }
        .theme-toggle {
            background: none;
            border: 1px solid var(--border-color);
            padding: 4px 8px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 0;
        }
        .theme-toggle:hover {
            background: var(--bg-secondary);
        }
        .drop-zone {
            position: relative;
            border: 1px dashed #999;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .drop-zone:hover {
            border-color: #333;
            background-color: #fafafa;
        }
        .drop-zone.dragover {
            border-color: #333;
            background-color: #f0f0f0;
            border-style: solid;
        }
        .modal-content {
            border-radius: 0;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        .modal-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 0.75rem 1rem;
        }
        .modal-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .modal-body {
            font-size: 13px;
            color: var(--text-primary);
        }
        .modal-body pre {
            background: #1a1a1a;
            color: #f0f0f0;
            padding: 12px;
            font-size: 12px;
            border: none;
            border-radius: 0;
        }
        .modal-body code {
            color: #d63384;
            background: var(--bg-code);
            padding: 1px 4px;
            font-size: 11px;
        }
        .modal-footer {
            border-top: 1px solid var(--border-color);
            padding: 0.5rem 1rem;
        }
        code {
            font-family: monospace;
            font-size: 12px;
        }
        .filter-tag {
            display: inline-block;
            padding: 2px 8px;
            margin: 2px;
            font-size: 11px;
            cursor: pointer;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
        }
        .filter-tag:hover {
            border-color: var(--text-muted);
            color: var(--text-primary);
        }
        .filter-tag.active {
            background: var(--text-primary);
            border-color: var(--text-primary);
            color: var(--bg-primary);
        }
        .filter-group {
            display: inline-block;
            margin-right: 1rem;
        }
        .filter-group-label {
            font-size: 10px;
            color: var(--text-muted);
            margin-right: 4px;
        }
        /* Dark mode graph text fix */
        [data-theme="dark"] #graph text,
        [data-theme="dark"] #splash-graph text,
        [data-theme="dark"] #attribute-graph text {
            fill: #e0e0e0 !important;
        }
        [data-theme="dark"] #graph .node text,
        [data-theme="dark"] #splash-graph .node text,
        [data-theme="dark"] #attribute-graph .node text {
            fill: #000 !important;
        }
        [data-theme="dark"] #graph .graph > polygon,
        [data-theme="dark"] #splash-graph .graph > polygon,
        [data-theme="dark"] #attribute-graph .graph > polygon {
            fill: transparent !important;
        }
        [data-theme="dark"] #graph .cluster > polygon,
        [data-theme="dark"] #graph .cluster > path,
        [data-theme="dark"] #attribute-graph .cluster > polygon,
        [data-theme="dark"] #attribute-graph .cluster > path {
            fill: #2a2a2a !important;
            stroke: #555 !important;
        }
        [data-theme="dark"] #graph .cluster text,
        [data-theme="dark"] #attribute-graph .cluster text {
            fill: #e0e0e0 !important;
        }
        /* Dark mode Bootstrap table overrides */
        [data-theme="dark"] .table {
            --bs-table-bg: var(--bg-primary);
            --bs-table-striped-bg: var(--bg-secondary);
            --bs-table-hover-bg: #333;
            --bs-table-color: var(--text-primary);
            --bs-table-striped-color: var(--text-primary);
            --bs-table-hover-color: var(--text-primary);
            color: var(--text-primary);
            border-color: var(--border-color);
        }
        [data-theme="dark"] .table > :not(caption) > * > * {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            border-bottom-color: var(--border-light);
        }
        [data-theme="dark"] .table-striped > tbody > tr:nth-of-type(odd) > * {
            background-color: var(--bg-secondary);
        }
        [data-theme="dark"] .table th {
            background-color: #252525 !important;
            color: #e0e0e0 !important;
        }
        /* Dark mode for table link buttons */
        [data-theme="dark"] .table .btn-outline-primary {
            border-color: #666;
            color: #aaa;
        }
        [data-theme="dark"] .table .btn-outline-primary:hover {
            background-color: #555;
            border-color: #555;
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="container-fluid py-4">
        <div class="hero-section">
            <div class="mb-4 text-center position-relative">
                <button class="theme-toggle position-absolute" style="top: 0; right: 0;" onclick="toggleTheme()" title="Toggle dark mode" id="theme-toggle">‚òÄÔ∏è</button>
                <h1 class="hero-title">üõ∞Ô∏è Pipeviz</h1>
                <p class="lead">Easy, elegant lineage from a single <span style="color: #d63384;">.json</span></p>
            </div>

            <ul class="nav nav-tabs hidden-on-home" id="dashboardTabs">
                <li class="nav-item">
                    <button class="nav-link active" id="home-tab" data-bs-toggle="tab" data-bs-target="#home-pane">Home</button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="spec-tab" data-bs-toggle="tab" data-bs-target="#spec-pane">Spec</button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="config-tab" data-bs-toggle="tab" data-bs-target="#config-pane">Config</button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="graph-tab" data-bs-toggle="tab" data-bs-target="#graph-pane">Graph</button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="attributes-tab" data-bs-toggle="tab" data-bs-target="#attributes-pane">Attributes</button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="pipelines-tab" data-bs-toggle="tab" data-bs-target="#pipelines-pane">Pipelines</button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="datasources-tab" data-bs-toggle="tab" data-bs-target="#datasources-pane">Datasources</button>
                </li>
                <li class="nav-item">
                    <button class="nav-link" id="dot-tab" data-bs-toggle="tab" data-bs-target="#dot-pane">Dot</button>
                </li>
            </ul>

            <div class="tab-content">
                <!-- Home Tab -->
                <div class="tab-pane fade show active" id="home-pane">
                    <div style="max-width: 750px; margin: 0 auto; padding: 2rem 1rem;">

                        <!-- Intro -->
                        <p style="font-size: 15px; color: var(--text-secondary); line-height: 1.7; margin-bottom: 1.5rem;">
                            Describe your pipelines in JSON, get a dependency graph.
                        </p>

                        <!-- Demo -->
                        <div style="display: flex; gap: 1.5rem; align-items: center; justify-content: center; flex-wrap: wrap; margin-bottom: 2rem;">
<pre style="padding: 1rem; font-size: 13px; margin: 0; color: var(--text-primary);">{
  "pipelines": [{
    "name": "etl-job",
    "input_sources": ["raw_events"],
    "output_sources": ["cleaned_events"]
  }]
}</pre>
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="color: var(--text-muted); flex-shrink: 0;">
                                <path d="M5 12h14M13 5l7 7-7 7"/>
                            </svg>
                            <div id="splash-graph" style="min-width: 240px; min-height: 120px; display: flex; align-items: center; justify-content: center;"></div>
                        </div>

                        <!-- Buttons -->
                        <div style="display: flex; gap: 0.75rem; justify-content: center; margin-bottom: 2.5rem;">
                            <button class="btn btn-dark" onclick="loadExample(); document.getElementById('graph-tab').click();">
                                Try the demo
                            </button>
                            <button class="btn btn-outline-secondary" onclick="document.getElementById('spec-tab').click();">
                                Read the spec
                            </button>
                        </div>

                        <!-- Feature tiles -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2.5rem;">
                            <div style="padding: 1.25rem; border: 1px solid var(--border-color); background: var(--bg-secondary);">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="color: var(--text-muted); margin-bottom: 0.75rem;">
                                    <rect x="4" y="4" width="6" height="6" rx="1"/><rect x="14" y="4" width="6" height="6" rx="1"/><rect x="4" y="14" width="6" height="6" rx="1"/><rect x="14" y="14" width="6" height="6" rx="1"/>
                                </svg>
                                <div style="font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 0.25rem;">Stack Agnostic</div>
                                <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.5;">SQL, Spark, Kafka, APIs, shell scripts. Just JSON.</div>
                            </div>
                            <div style="padding: 1.25rem; border: 1px solid var(--border-color); background: var(--bg-secondary);">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="color: var(--text-muted); margin-bottom: 0.75rem;">
                                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/>
                                </svg>
                                <div style="font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 0.25rem;">Zero Dependencies</div>
                                <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.5;">One HTML file. No backend, no build step. Open locally or host anywhere.</div>
                            </div>
                            <div style="padding: 1.25rem; border: 1px solid var(--border-color); background: var(--bg-secondary);">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="color: var(--text-muted); margin-bottom: 0.75rem;">
                                    <circle cx="6" cy="6" r="3"/><circle cx="18" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="18" r="3"/><path d="M6 9v6m12-6v6M9 6h6m-6 12h6"/>
                                </svg>
                                <div style="font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 0.25rem;">Federated</div>
                                <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.5;">Each team owns their JSON. Merge with jq for the org-wide view.</div>
                            </div>
                        </div>

                        <!-- How it works -->
                        <div style="margin-bottom: 2.5rem;">
                            <div style="font-size: 13px; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">How it works</div>
                            <p style="font-size: 13px; color: var(--text-secondary); line-height: 1.6; margin-bottom: 1.25rem;">
                                You know your pipelines. Declare them as JSON, generate it from your build, or write it by hand.
                            </p>
                            <div style="display: flex; justify-content: space-between; gap: 1.5rem; flex-wrap: wrap;">
                                <div style="flex: 1; min-width: 140px; text-align: center;">
                                    <div style="font-size: 1.5rem; color: var(--text-muted); margin-bottom: 0.25rem;">1</div>
                                    <div style="font-size: 13px; font-weight: 500; color: var(--text-primary); margin-bottom: 0.25rem;">Define</div>
                                    <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.5;">Write a <code>pipeviz.json</code> describing your pipelines and data sources</div>
                                </div>
                                <div style="flex: 1; min-width: 140px; text-align: center;">
                                    <div style="font-size: 1.5rem; color: var(--text-muted); margin-bottom: 0.25rem;">2</div>
                                    <div style="font-size: 13px; font-weight: 500; color: var(--text-primary); margin-bottom: 0.25rem;">Load</div>
                                    <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.5;">Drop your file here, or host both files together on any static server</div>
                                </div>
                                <div style="flex: 1; min-width: 140px; text-align: center;">
                                    <div style="font-size: 1.5rem; color: var(--text-muted); margin-bottom: 0.25rem;">3</div>
                                    <div style="font-size: 13px; font-weight: 500; color: var(--text-primary); margin-bottom: 0.25rem;">Explore</div>
                                    <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.5;">Click through the graph, trace dependencies, export DOT for other tools</div>
                                </div>
                            </div>
                        </div>

                        <!-- Federated lineage -->
                        <div style="margin-bottom: 2rem;">
                            <div style="font-size: 13px; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">Federated lineage</div>
                            <p style="font-size: 13px; color: var(--text-secondary); line-height: 1.6; margin: 0 0 0.75rem 0;">
                                Each team versions their own <code>pipeviz.json</code> alongside their code. Generate it at compile time from your build, tests, or annotations. When you need the org-wide view, merge with <a href="https://jqlang.github.io/jq/" target="_blank" style="color: var(--text-secondary);">jq</a> (probably already on your machine) or any JSON tool:
                            </p>
<pre style="background: var(--bg-code); padding: 0.75rem; font-size: 12px; margin: 0; overflow-x: auto; color: var(--text-primary);"><span style="color: var(--text-muted);"># merge all team configs into one</span>
jq -s '{
  pipelines: map(.pipelines // []) | add,
  datasources: map(.datasources // []) | add
}' team-*.json > pipeviz.json</pre>
                        </div>

                        <!-- Philosophy -->
                        <div style="margin-bottom: 2rem;">
                            <div style="font-size: 13px; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">Philosophy</div>
                            <p style="font-size: 13px; color: var(--text-secondary); line-height: 1.6; margin: 0;">
                                <a href="https://openlineage.io/" target="_blank" style="color: var(--text-secondary);">OpenLineage</a>, <a href="https://marquezproject.ai/" target="_blank" style="color: var(--text-secondary);">Marquez</a>, and <a href="https://atlas.apache.org/" target="_blank" style="color: var(--text-secondary);">Atlas</a> instrument your runtime, buffer events into a central orchestrator, and extract whatever graph their agents can infer. <a href="https://www.getdbt.com/" target="_blank" style="color: var(--text-secondary);">dbt</a> takes a different approach but still asks you to rewrite pipelines in their SQL dialect and structure your project around their manifest.
                            </p>
                            <p style="font-size: 13px; color: var(--text-secondary); line-height: 1.6; margin: 0.75rem 0 0 0;">
                                Pipeviz is just a JSON file and one HTML page. Nothing to install, nothing running in your cluster.
                            </p>
                        </div>

                        <!-- Footer -->
                        <div style="font-size: 12px; padding-top: 1rem; border-top: 1px solid var(--border-light);">
                            <a href="#" onclick="document.getElementById('spec-tab').click(); return false;" style="color: var(--text-muted);">spec</a>
                            <span style="color: var(--border-color); margin: 0 6px;">¬∑</span>
                            <a href="https://github.com/mattlianje/pipeviz" target="_blank" style="color: var(--text-muted);">github</a>
                        </div>
                    </div>
                </div>

                <!-- Configuration Tab -->
                <div class="tab-pane fade" id="config-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-10">
                                    <h5 class="mb-3">Configuration</h5>
                                    <div class="drop-zone" id="drop-zone">
                                        <textarea class="form-control json-editor" id="json-input" rows="20"
                                                  placeholder="Paste your pipeviz.json here, drag & drop a file, or click the button below to browse..."></textarea>
                                    </div>
                                    <div class="mt-3">
                                        <input type="file" id="file-input" accept=".json" style="display: none;" onchange="loadFromFile(event)">
                                        <button class="btn btn-outline-secondary me-2" onclick="document.getElementById('file-input').click()">Browse File</button>
                                        <button class="btn btn-outline-secondary me-2" onclick="loadExample()">Load Example</button>
                                        <button class="btn btn-outline-info" onclick="generateShareableUrl()">Generate Shareable URL</button>
                                    </div>
                                    <div id="json-status" class="mt-2"></div>
                                </div>
                                <div class="col-md-2">
                                    <div class="small text-muted">
                                        <div class="mb-3"><strong>Documentation:</strong></div>
                                        <div class="mb-2">
                                            <a href="#" onclick="document.getElementById('spec-tab').click(); return false;" class="link-icon">
                                                spec
                                            </a>
                                        </div>
                                        <div class="mb-3"><strong>Load from URL:</strong></div>
                                        <div class="mb-2">Add <code style="font-size: 0.7rem;">?url=your-json-url</code> to this page's URL to auto-load a config.</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Pipelines Tab -->
                <div class="tab-pane fade" id="pipelines-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="mb-3">
                                <input type="text" class="form-control" id="pipeline-search"
                                       placeholder="Search pipelines..." onkeyup="filterPipelines()" style="max-width: 300px;">
                            </div>
                            <div class="mb-3" id="pipeline-filters"></div>
                            <div id="pipelines-table-container">
                                <p class="text-muted text-center">Load a configuration to see your pipelines</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Data Sources Tab -->
                <div class="tab-pane fade" id="datasources-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="mb-3">
                                <input type="text" class="form-control" id="datasource-search"
                                       placeholder="Search data sources..." onkeyup="filterDatasources()" style="max-width: 300px;">
                            </div>
                            <div class="mb-3" id="datasource-filters"></div>
                            <div id="datasources-table-container">
                                <p class="text-muted text-center">Load a configuration to see your data sources</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Graph Tab -->
                <div class="tab-pane fade" id="graph-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="row mb-3">
                                <div class="col-md-4">
                                    <div class="position-relative">
                                        <input type="text" class="form-control" id="graph-search"
                                               placeholder="Search nodes..." onkeyup="searchNodes(event)">
                                        <div id="graph-search-results" class="search-results-dropdown"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="row">
                                <div id="graph-col" class="col-md-12">
                                    <div class="graph-container position-relative">
                                        <div class="graph-controls">
                                            <div class="btn-group me-2">
                                                <button class="btn btn-sm btn-outline-secondary" onclick="collapseAllGroups()">
                                                    Collapse All
                                                </button>
                                            </div>
                                            <div class="btn-group me-2">
                                                <button class="btn btn-sm btn-outline-warning" onclick="clearSelection()">
                                                    Clear Selection
                                                </button>
                                            </div>
                                            <button class="btn btn-sm btn-outline-secondary" onclick="resetGraph()">Reset</button>
                                        </div>
                                        <div id="graph">
                                            <div class="graph-loading text-center py-5 text-muted">
                                                <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                                                Loading graph...
                                            </div>
                                        </div>
                                        <div class="legend">
                                            <div><strong>Legend:</strong></div>
                                            <div>‚ñ† = Pipeline</div>
                                            <div style="color: #ef6c00;">‚ñ† = Group</div>
                                            <div>‚óè = Data Source</div>
                                            <div>‚ñ° = Cluster</div>
                                            <div>‚Üí = Data flow</div>
                                            <div style="color: #ff6b35;">‚Üí = Dependency</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4" id="node-details-col" style="display: none;">
                                    <div class="node-details-panel" id="node-details-panel">
                                        <div id="node-details-content"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Attributes Tab -->
                <div class="tab-pane fade" id="attributes-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="row mb-3">
                                <div class="col-md-4">
                                    <div class="position-relative">
                                        <input type="text" class="form-control" id="attribute-search"
                                               placeholder="Search attributes..." onkeyup="searchAttributes(event)">
                                        <div id="attribute-search-results" class="search-results-dropdown"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="row">
                                <div id="attribute-graph-col" class="col-md-12">
                                    <div class="graph-container position-relative">
                                        <div class="graph-controls">
                                            <div class="btn-group me-2">
                                                <button class="btn btn-sm btn-outline-warning" onclick="clearAttributeSelection()">
                                                    Clear Selection
                                                </button>
                                            </div>
                                            <button class="btn btn-sm btn-outline-secondary" onclick="resetAttributeGraph()">Reset</button>
                                        </div>
                                        <div id="attribute-graph">
                                            <div class="graph-loading text-center py-5 text-muted">
                                                <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                                                Loading graph...
                                            </div>
                                        </div>
                                        <div class="legend">
                                            <div><strong>Legend:</strong></div>
                                            <div>‚ñ¢ = Data Source</div>
                                            <div>¬∑ = Attribute</div>
                                            <div>‚Üí = Derived from</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4" id="attribute-details-col" style="display: none;">
                                    <div class="node-details-panel" id="attribute-details-panel">
                                        <div id="attribute-details-content"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Raw DOT Tab -->
                <div class="tab-pane fade" id="dot-pane">
                    <div class="card">
                        <div class="card-body">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h5 class="mb-0">Generated Graphviz DOT</h5>
                                <div>
                                    <button class="btn btn-sm btn-outline-info me-2" onclick="updateDotView()">Refresh</button>
                                    <button class="btn btn-sm btn-outline-secondary" onclick="copyDotToClipboard()">Copy to Clipboard</button>
                                </div>
                            </div>
                            <textarea class="form-control json-editor" id="dot-output" rows="25" readonly
                                      placeholder="Load a configuration to see the generated DOT code..."></textarea>
                        </div>
                    </div>
                </div>

                <!-- Spec Tab -->
                <div class="tab-pane fade" id="spec-pane">
                    <div style="max-width: 800px; padding: 1rem 0;">
                        <div class="mb-4">
                            <h5 style="font-weight: bold; margin-bottom: 1rem;">JSON Spec</h5>
                            <p style="color: var(--text-secondary);">Pipeviz uses a simple JSON configuration to define your data lineage. Only pipelines are required. Clusters and datasources are auto-created when referenced, but you can add rich descriptors for better documentation.</p>
                        </div>

                        <div class="mb-4">
                            <h6 style="font-weight: bold;">Root Structure</h6>
                            <pre style="background: var(--bg-code); border: 1px solid var(--border-color); padding: 12px; font-size: 12px; color: var(--text-primary);">{
  "clusters": [ ... ],     // Optional: cluster definitions
  "pipelines": [ ... ],    // Required: pipeline definitions
  "datasources": [ ... ]   // Optional: rich data source definitions
}</pre>
                        </div>

                        <div class="mb-4">
                            <h6 style="font-weight: bold;">Clusters (Optional)</h6>
                            <p style="color: var(--text-secondary); font-size: 12px;">Clusters can be declared upfront or referenced on-the-fly. Support nested hierarchies with parent relationships.</p>
                            <pre style="background: var(--bg-code); border: 1px solid var(--border-color); padding: 12px; font-size: 12px; color: var(--text-primary);">{
  "name": "real-time",
  "description": "Real-time processing cluster",  // Optional
  "parent": "order-management"                    // Optional: creates nested cluster
}</pre>
                        </div>

                        <div class="mb-4">
                            <h6 style="font-weight: bold;">Pipelines</h6>
                            <pre style="background: var(--bg-code); border: 1px solid var(--border-color); padding: 12px; font-size: 12px; color: var(--text-primary);">{
  "name": "user-enrichment",
  "description": "Enriches user data...",       // Optional
  "input_sources": ["raw_users", "events"],     // Optional
  "output_sources": ["enriched_users"],         // Optional
  "schedule": "Every 2 hours",                  // Optional
  "tags": ["user-data", "ml"],                  // Optional
  "cluster": "user-processing",                 // Optional: single cluster
  "group": "etl-jobs",                          // Optional: collapse into group
  "upstream_pipelines": ["data-ingestion"],     // Optional
  "links": {                                    // Optional
    "airflow": "https://...",
    "monitoring": "https://..."
  }
}</pre>
                            <p style="color: var(--text-secondary); font-size: 12px; margin-top: 0.5rem;">Use <code>group</code> to collapse multiple pipelines into a single node. Toggle between grouped and expanded views in the Graph tab.</p>
                        </div>

                        <div class="mb-4">
                            <h6 style="font-weight: bold;">Data Sources (Optional)</h6>
                            <p style="color: var(--text-secondary); font-size: 12px;">Data sources are auto-created when referenced in pipelines. Define them explicitly to add rich metadata, ownership, and documentation.</p>
                            <pre style="background: var(--bg-code); border: 1px solid var(--border-color); padding: 12px; font-size: 12px; color: var(--text-primary);">{
  "name": "raw_users",
  "description": "Raw user data...",            // Optional
  "type": "snowflake",                          // Optional
  "owner": "data-team@company.com",             // Optional
  "tags": ["pii", "users"],                     // Optional
  "cluster": "user-processing",                 // Optional
  "metadata": {                                 // Optional
    "size": "2.1TB",
    "record_count": "45M"
  },
  "links": {                                    // Optional
    "snowflake": "https://...",
    "docs": "https://..."
  }
}</pre>
                        </div>

                        <div class="mb-4">
                            <h6 style="font-weight: bold;">Attribute Lineage (Optional)</h6>
                            <p style="color: var(--text-secondary); font-size: 12px;">Track column-level lineage by adding an <code>attributes</code> array to datasources. Use <code>::</code> to reference source attributes.</p>
                            <pre style="background: var(--bg-code); border: 1px solid var(--border-color); padding: 12px; font-size: 12px; color: var(--text-primary);">{
  "name": "enriched_users",
  "attributes": [
    { "name": "user_id", "from": "raw_users::id" },
    { "name": "full_name", "from": ["raw_users::first_name", "raw_users::last_name"] },
    { "name": "event_count", "from": "user_events::event_id" }
  ]
}</pre>
                            <p style="color: var(--text-secondary); font-size: 12px; margin-top: 0.5rem;">View attribute lineage in the <strong>Attributes</strong> tab.</p>
                        </div>

                        <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); padding: 1rem;">
                            <strong>Tips</strong>
                            <ul style="margin: 0.5rem 0 0 0; padding-left: 1.25rem; font-size: 13px;">
                                <li>Only <code>pipelines</code> array with pipeline <code>name</code> fields is required</li>
                                <li>Clusters and datasources are auto-created when referenced</li>
                                <li>Use <code>upstream_pipelines</code> to show pipeline dependencies</li>
                                <li>Create nested clusters using the <code>parent</code> field</li>
                                <li>Use <code>group</code> to collapse similar pipelines into a single node</li>
                                <li>Use <code>attributes</code> with <code>::</code> separator for column-level lineage</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Spec Modal -->
    <div class="modal fade" id="specModal" tabindex="-1" aria-labelledby="specModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="specModalLabel">json spec</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-4">
                        <h6>Overview</h6>
                        <p class="text-muted">Pipeviz uses a simple JSON configuration to define your data lineage. Only pipelines are required. Clusters and datasources are auto-created when referenced, but you can add rich descriptors for better documentation.</p>
                    </div>

                    <div class="mb-4">
                        <h6>Root Structure</h6>
                        <pre class="bg-light p-3 rounded"><code>{
  "clusters": [ ... ],     // Optional: cluster definitions
  "pipelines": [ ... ],    // Required: pipeline definitions
  "datasources": [ ... ]   // Optional: rich data source definitions
}</code></pre>
                    </div>

                    <div class="mb-4">
                        <h6>Clusters (Optional)</h6>
                        <p class="text-muted small">Clusters can be optionally declared upfront or referenced on-the-fly. Support nested hierarchies with parent relationships.</p>
                        <pre class="bg-light p-3 rounded"><code>{
  "name": "real-time",
  "description": "Real-time processing cluster",  // Optional
  "parent": "order-management"                    // Optional: creates nested cluster
}</code></pre>
                    </div>

                    <div class="mb-4">
                        <h6>Pipelines</h6>
                        <pre class="bg-light p-3 rounded"><code>{
  "name": "user-enrichment",
  "description": "Enriches user data...",       // Optional
  "input_sources": ["raw_users", "events"],     // Optional
  "output_sources": ["enriched_users"],         // Optional
  "schedule": "Every 2 hours",                  // Optional
  "tags": ["user-data", "ml"],                  // Optional
  "cluster": "user-processing",                 // Optional: single cluster
  "upstream_pipelines": ["data-ingestion"],     // Optional
  "links": {                                    // Optional
    "airflow": "https://...",
    "monitoring": "https://..."
  }
}</code></pre>
                    </div>

                    <div class="mb-4">
                        <h6>Data Sources (Optional)</h6>
                        <p class="text-muted small">Data sources are auto-created when referenced in pipelines. Define them explicitly to add rich metadata, ownership, and documentation.</p>
                        <pre class="bg-light p-3 rounded"><code>{
  "name": "raw_users",
  "description": "Raw user data...",            // Optional
  "type": "snowflake",                          // Optional
  "owner": "data-team@company.com",             // Optional
  "tags": ["pii", "users"],                     // Optional
  "cluster": "user-processing",                 // Optional: single cluster
  "metadata": {                                 // Optional
    "size": "2.1TB",
    "record_count": "45M"
  },
  "links": {                                    // Optional
    "snowflake": "https://...",
    "docs": "https://..."
  }
}</code></pre>
                    </div>

                    <div class="alert alert-info">
                        <strong>Tips:</strong>
                        <ul class="mb-0 mt-2">
                            <li>Only <code>pipelines</code> array with pipeline <code>name</code> fields is required</li>
                            <li>Clusters and datasources are auto-created when referenced in pipelines</li>
                            <li>Define datasources explicitly to add rich metadata, ownership, and links</li>
                            <li>Use <code>cluster</code> (singular) to assign nodes to one cluster each</li>
                            <li>Create nested clusters using the <code>parent</code> field in cluster definitions</li>
                            <li>Use <code>upstream_pipelines</code> to show pipeline dependencies</li>
                            <li>Links can point to any external tools (Airflow, monitoring, docs, etc.)</li>
                        </ul>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Theme toggle
        function toggleTheme() {
            const html = document.documentElement;
            const btn = document.getElementById('theme-toggle');
            if (html.getAttribute('data-theme') === 'dark') {
                html.removeAttribute('data-theme');
                btn.textContent = '‚òÄÔ∏è';
                localStorage.setItem('pipeviz-theme', 'light');
            } else {
                html.setAttribute('data-theme', 'dark');
                btn.textContent = 'üåô';
                localStorage.setItem('pipeviz-theme', 'dark');
            }
            // Re-render graphs for theme
            if (typeof renderSplashGraph === 'function') {
                renderSplashGraph();
            }
            if (typeof updateGraph === 'function') {
                updateGraph();
            }
        }
        // Initialize theme from localStorage
        (function() {
            const saved = localStorage.getItem('pipeviz-theme');
            if (saved === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
                document.addEventListener('DOMContentLoaded', () => {
                    document.getElementById('theme-toggle').textContent = 'üåô';
                });
            }
        })();

        // Show/hide tabs based on home tab + URL hash linking
        document.querySelectorAll('#dashboardTabs button').forEach(tab => {
            tab.addEventListener('shown.bs.tab', function(e) {
                const tabs = document.getElementById('dashboardTabs');
                const tabName = e.target.id.replace('-tab', '');
                if (e.target.id === 'home-tab') {
                    tabs.classList.add('hidden-on-home');
                    history.replaceState(null, '', window.location.pathname + window.location.search);
                } else {
                    tabs.classList.remove('hidden-on-home');
                    history.replaceState(null, '', '#' + tabName);
                }
            });
        });

        // Handle initial hash or hash changes
        function activateTabFromHash() {
            const hash = window.location.hash.slice(1);
            if (hash) {
                const tab = document.getElementById(hash + '-tab');
                if (tab) {
                    tab.click();
                }
            }
        }
        window.addEventListener('hashchange', activateTabFromHash);
        document.addEventListener('DOMContentLoaded', activateTabFromHash);

        let currentConfig = null;
        let graphviz = null;
        let groupedView = true;
        let expandedGroups = new Set();
        let selectedNode = null;

        // Cached lineage maps for performance
        let cachedUpstreamMap = {};
        let cachedDownstreamMap = {};
        let cachedLineage = {}; // node -> {upstream: [], downstream: []}

        const exampleConfig = {
            "clusters": [
                {
                    "name": "user-processing",
                    "description": "User data processing and enrichment cluster"
                },
                {
                    "name": "order-management",
                    "description": "Order processing and validation cluster"
                },
                {
                    "name": "real-time",
                    "description": "Real-time streaming data cluster",
                    "parent": "order-management"
                },
                {
                    "name": "analytics",
                    "description": "Analytics and reporting cluster"
                }
            ],
            "pipelines": [
                {
                    "name": "user-enrichment",
                    "description": "Enriches user data with behavioral signals and ML features",
                    "input_sources": ["raw_users", "user_events"],
                    "output_sources": ["enriched_users"],
                    "schedule": "Every 2 hours",
                    "tags": ["user-data", "ml", "enrichment"],
                    "cluster": "user-processing",
                    "links": {
                        "airflow": "https://airflow.company.com/dags/user_enrichment",
                        "monitoring": "https://grafana.company.com/d/user-enrichment",
                        "docs": "https://docs.company.com/pipelines/user-enrichment"
                    },
                    "upstream_pipelines": []
                },
                {
                    "name": "order-processing",
                    "description": "Validates and processes incoming orders in real-time",
                    "input_sources": ["raw_orders", "inventory"],
                    "output_sources": ["processed_orders", "order_audit"],
                    "schedule": "Every 15 minutes",
                    "tags": ["orders", "real-time", "validation"],
                    "cluster": "real-time",
                    "links": {
                        "airflow": "https://airflow.company.com/dags/order_processing",
                        "monitoring": "https://grafana.company.com/d/orders",
                        "alerts": "https://pagerduty.company.com/services/orders"
                    },
                    "upstream_pipelines": []
                },
                {
                    "name": "analytics-aggregation",
                    "description": "Daily aggregation of user metrics and business KPIs",
                    "input_sources": ["enriched_users", "processed_orders", "user_events"],
                    "output_sources": ["daily_metrics", "user_cohorts"],
                    "schedule": "Daily at 1:00 AM",
                    "tags": ["analytics", "aggregation", "daily"],
                    "cluster": "analytics",
                    "links": {
                        "airflow": "https://airflow.company.com/dags/analytics_agg",
                        "dashboard": "https://tableau.company.com/analytics-dashboard"
                    },
                    "upstream_pipelines": ["user-enrichment", "order-processing"]
                },
                {
                    "name": "export-to-salesforce",
                    "description": "Sync user cohorts to Salesforce",
                    "input_sources": ["user_cohorts"],
                    "output_sources": ["salesforce_users"],
                    "group": "data-exports",
                    "cluster": "analytics"
                },
                {
                    "name": "export-to-hubspot",
                    "description": "Sync user cohorts to HubSpot",
                    "input_sources": ["user_cohorts"],
                    "output_sources": ["hubspot_contacts"],
                    "group": "data-exports",
                    "cluster": "analytics"
                },
                {
                    "name": "export-to-amplitude",
                    "description": "Sync daily metrics to Amplitude",
                    "input_sources": ["daily_metrics"],
                    "output_sources": ["amplitude_events"],
                    "group": "data-exports",
                    "cluster": "analytics"
                },
                {
                    "name": "weekly-rollup",
                    "description": "Aggregate daily metrics into weekly executive summary",
                    "input_sources": ["daily_metrics", "enriched_users"],
                    "output_sources": ["executive_summary"],
                    "schedule": "0 6 * * MON",
                    "cluster": "analytics"
                }
            ],
            "datasources": [
                {
                    "name": "raw_users",
                    "description": "Raw user registration and profile data from production database",
                    "type": "snowflake",
                    "owner": "data-platform@company.com",
                    "tags": ["pii", "users", "core-data"],
                    "cluster": "user-processing",
                    "attributes": [
                        { "name": "id" },
                        { "name": "first_name" },
                        { "name": "last_name" },
                        { "name": "email" },
                        { "name": "signup_date" }
                    ],
                    "metadata": {
                        "schema": "RAW_DATA",
                        "table": "USERS",
                        "size": "2.1TB",
                        "record_count": "45M",
                        "refresh_frequency": "real-time"
                    },
                    "links": {
                        "snowflake": "https://company.snowflakecomputing.com/console#/data/databases/PROD/schemas/RAW_DATA/table/USERS",
                        "monitoring": "https://grafana.company.com/d/raw-users",
                        "docs": "https://docs.company.com/schemas/raw_users"
                    }
                },
                {
                    "name": "user_events",
                    "description": "Clickstream and interaction events from all digital touchpoints",
                    "type": "s3",
                    "owner": "analytics-team@company.com",
                    "tags": ["events", "clickstream", "large-dataset"],
                    "cluster": "analytics",
                    "attributes": [
                        { "name": "event_id" },
                        { "name": "user_id", "from": "raw_users::id" },
                        { "name": "event_type" },
                        { "name": "page_url" },
                        { "name": "timestamp" }
                    ],
                    "metadata": {
                        "bucket": "company-events-prod",
                        "size": "15TB",
                        "record_count": "2.5B",
                        "file_format": "parquet"
                    },
                    "links": {
                        "s3": "https://s3.console.aws.amazon.com/s3/buckets/company-events-prod",
                        "athena": "https://console.aws.amazon.com/athena/home#query"
                    }
                },
                {
                    "name": "raw_orders",
                    "description": "Real-time order data from e-commerce platform",
                    "type": "api",
                    "owner": "platform-team@company.com",
                    "tags": ["orders", "real-time", "revenue"],
                    "cluster": "real-time",
                    "metadata": {
                        "endpoint": "https://api.company.com/v2/orders",
                        "rate_limit": "1000 req/min",
                        "record_count": "120M"
                    },
                    "links": {
                        "api_docs": "https://docs.company.com/api/orders",
                        "monitoring": "https://grafana.company.com/d/orders-api"
                    }
                },
                {
                    "name": "inventory",
                    "description": "Product inventory levels across all warehouses",
                    "type": "snowflake",
                    "owner": "supply-chain@company.com",
                    "tags": ["inventory", "warehouse", "operational"],
                    "cluster": "order-management",
                    "metadata": {
                        "schema": "INVENTORY",
                        "size": "150GB",
                        "refresh_frequency": "every 15 minutes"
                    },
                    "links": {
                        "snowflake": "https://company.snowflakecomputing.com/console#/data/databases/PROD/schemas/INVENTORY",
                        "tableau": "https://tableau.company.com/views/inventory-dashboard"
                    }
                },
                {
                    "name": "enriched_users",
                    "description": "Enriched user profiles with behavioral features",
                    "type": "delta",
                    "owner": "data-platform@company.com",
                    "tags": ["users", "enriched", "ml-ready"],
                    "cluster": "user-processing",
                    "attributes": [
                        { "name": "user_id", "from": "raw_users::id" },
                        { "name": "full_name", "from": ["raw_users::first_name", "raw_users::last_name"] },
                        { "name": "email", "from": "raw_users::email" },
                        { "name": "event_count", "from": "user_events::event_id" },
                        { "name": "last_active", "from": "user_events::timestamp" },
                        { "name": "signup_date", "from": "raw_users::signup_date" }
                    ]
                },
                {
                    "name": "daily_metrics",
                    "description": "Aggregated daily business metrics",
                    "type": "snowflake",
                    "owner": "analytics-team@company.com",
                    "tags": ["metrics", "daily", "kpi"],
                    "cluster": "analytics",
                    "attributes": [
                        { "name": "date" },
                        { "name": "active_users", "from": "enriched_users::user_id" },
                        { "name": "total_events", "from": "user_events::event_id" }
                    ]
                },
                {
                    "name": "executive_summary",
                    "description": "Weekly executive dashboard metrics",
                    "type": "snowflake",
                    "cluster": "analytics",
                    "attributes": [
                        { "name": "week" },
                        { "name": "weekly_active_users", "from": "daily_metrics::active_users" },
                        { "name": "weekly_events", "from": "daily_metrics::total_events" },
                        { "name": "user_growth", "from": ["daily_metrics::active_users", "enriched_users::signup_date"] }
                    ]
                },
                {
                    "name": "user_cohorts",
                    "description": "User segmentation and cohort definitions",
                    "type": "snowflake",
                    "cluster": "analytics"
                },
                {
                    "name": "salesforce_users",
                    "description": "User data synced to Salesforce CRM",
                    "type": "api",
                    "cluster": "analytics"
                },
                {
                    "name": "hubspot_contacts",
                    "description": "Contact data synced to HubSpot",
                    "type": "api",
                    "cluster": "analytics"
                },
                {
                    "name": "amplitude_events",
                    "description": "Product analytics events sent to Amplitude",
                    "type": "api",
                    "cluster": "analytics"
                }
            ]
        };

        function loadExample() {
            document.getElementById('json-input').value = JSON.stringify(exampleConfig, null, 2);
            loadJson();
        }

        function generateShareableUrl() {
            if (!currentConfig) {
                alert('No configuration loaded to share');
                return;
            }

            const configJson = JSON.stringify(currentConfig);
            const encodedConfig = btoa(configJson);
            const currentUrl = window.location.origin + window.location.pathname;
            const shareableUrl = `${currentUrl}?config=${encodedConfig}`;

            navigator.clipboard.writeText(shareableUrl).then(() => {
                const statusDiv = document.getElementById('json-status');
                statusDiv.innerHTML = '<div class="alert alert-success">Shareable URL copied to clipboard!</div>';
                setTimeout(() => {
                    statusDiv.innerHTML = '';
                }, 3000);
            }).catch(() => {
                prompt('Copy this shareable URL:', shareableUrl);
            });
        }

        async function tryLoadPipevizJson() {
            try {
                // Try to load pipeviz.json from the same directory
                const response = await fetch('pipeviz.json');
                if (response.ok) {
                    const configText = await response.text();
                    const parsed = JSON.parse(configText);
                    document.getElementById('json-input').value = JSON.stringify(parsed, null, 2);
                    loadJson();
                    const statusDiv = document.getElementById('json-status');
                    statusDiv.innerHTML = '<div class="alert alert-success">Loaded pipeviz.json</div>';
                    setTimeout(() => { statusDiv.innerHTML = ''; }, 3000);
                    return true;
                }
            } catch (error) {
                // File doesn't exist, that's okay
            }
            return false;
        }

        async function loadFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);

            const configParam = urlParams.get('config');
            const viewParam = urlParams.get('view');
            if (configParam) {
                try {
                    const decodedConfig = atob(configParam);
                    const parsed = JSON.parse(decodedConfig);
                    document.getElementById('json-input').value = JSON.stringify(parsed, null, 2);
                    loadJson();
                    const targetView = viewParam || 'graph';
                    document.getElementById(targetView + '-tab')?.click();
                    return;
                } catch (error) {
                    console.error('Error decoding config parameter:', error);
                }
            }

            const urlParam = urlParams.get('url');
            const autoView = urlParams.get('view') || (urlParam ? 'graph' : null);

            if (urlParam) {
                fetch(urlParam)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        return response.text();
                    })
                    .then(configText => {
                        try {
                            const parsed = JSON.parse(configText);
                            document.getElementById('json-input').value = JSON.stringify(parsed, null, 2);
                            loadJson();
                            if (autoView) {
                                document.getElementById(autoView + '-tab')?.click();
                            }
                        } catch (error) {
                            document.getElementById('json-input').value = configText;
                            loadJson();
                        }
                    })
                    .catch(error => {
                        const statusDiv = document.getElementById('json-status');
                        statusDiv.innerHTML = `<div class="alert alert-danger">Error loading from URL: ${error.message}</div>`;
                        loadExample();
                    });
                return;
            }

            // Try to load pipeviz.json first, fall back to example
            const loaded = await tryLoadPipevizJson();
            if (!loaded) {
                loadExample();
            }
        }

        function setupDragDrop() {
            const dropZone = document.getElementById('drop-zone');
            const textarea = document.getElementById('json-input');

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => dropZone.classList.add('dragover'), false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => dropZone.classList.remove('dragover'), false);
            });

            dropZone.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type === "application/json" || file.name.endsWith('.json')) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            try {
                                const parsed = JSON.parse(e.target.result);
                                textarea.value = JSON.stringify(parsed, null, 2);
                                loadJson();
                            } catch (error) {
                                textarea.value = e.target.result;
                                loadJson();
                            }
                        };
                        reader.readAsText(file);
                    } else {
                        const statusDiv = document.getElementById('json-status');
                        statusDiv.innerHTML = '<div class="alert alert-warning">Please drop a JSON file</div>';
                    }
                }
            }
        }

        function loadFromFile(event) {
            const file = event.target.files[0];
            if (file && (file.type === "application/json" || file.name.endsWith('.json'))) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const parsed = JSON.parse(e.target.result);
                        document.getElementById('json-input').value = JSON.stringify(parsed, null, 2);
                        loadJson();
                    } catch (error) {
                        document.getElementById('json-input').value = e.target.result;
                        loadJson();
                    }
                };
                reader.readAsText(file);
            } else {
                const statusDiv = document.getElementById('json-status');
                statusDiv.innerHTML = '<div class="alert alert-warning">Please select a valid JSON file</div>';
            }
        }

        function setupAutoProcess() {
            const textarea = document.getElementById('json-input');
            const statusDiv = document.getElementById('json-status');
            let timeout;

            textarea.addEventListener('input', function() {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    const content = textarea.value.trim();
                    if (!content) {
                        statusDiv.innerHTML = '';
                        return;
                    }
                    try {
                        JSON.parse(content);
                        statusDiv.innerHTML = '<div class="alert alert-success py-1 px-2" style="font-size: 0.85em;">Valid JSON</div>';
                        loadJson();
                    } catch (e) {
                        statusDiv.innerHTML = `<div class="alert alert-danger py-1 px-2" style="font-size: 0.85em;">Invalid JSON: ${e.message}</div>`;
                    }
                }, 500);
            });
        }

        function loadJson() {
            const jsonText = document.getElementById('json-input').value.trim();
            const statusDiv = document.getElementById('json-status');

            if (!jsonText) {
                statusDiv.innerHTML = '<div class="alert alert-warning">Please enter JSON configuration</div>';
                return;
            }

            try {
                currentConfig = JSON.parse(jsonText);
                statusDiv.innerHTML = '<div class="alert alert-success">Configuration loaded successfully!</div>';

                renderPipelines();
                renderDatasources();
                updateFilters();
                renderGraph();
                updateDotView();

            } catch (error) {
                statusDiv.innerHTML = `<div class="alert alert-danger">JSON Parse Error: ${error.message}</div>`;
            }
        }

        function renderPipelines() {
            if (!currentConfig || !currentConfig.pipelines) return;

            const container = document.getElementById('pipelines-table-container');
            let html = `
                <div class="table-container">
                <table class="table table-striped table-hover">
                    <thead>
                        <tr>
                            <th>Pipeline</th>
                            <th>Description</th>
                            <th>Schedule</th>
                            <th>Input Sources</th>
                            <th>Output Sources</th>
                            <th>Cluster</th>
                            <th>Tags</th>
                            <th>Links</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            currentConfig.pipelines.forEach(pipeline => {
                const inputSources = pipeline.input_sources?.map(s =>
                    `<span class="badge me-1 mb-1" style="background-color: #e3f2fd; color: #1565c0; font-size: 0.85em;">${s}</span>`
                ).join('') || '';

                const outputSources = pipeline.output_sources?.map(s =>
                    `<span class="badge me-1 mb-1" style="background-color: #e8f5e8; color: #2e7d32; font-size: 0.85em;">${s}</span>`
                ).join('') || '';

                const cluster = pipeline.cluster ?
                    `<span class="badge badge-cluster me-1 mb-1">${pipeline.cluster}</span>` : '';

                const tags = pipeline.tags?.map(t =>
                    `<span class="badge me-1 mb-1" style="background-color: #fff3cd; color: #856404; font-size: 0.85em;">${t}</span>`
                ).join('') || '';

                const links = pipeline.links ? Object.entries(pipeline.links).map(([name, url]) =>
                    `<a href="${url}" target="_blank" class="btn btn-sm btn-outline-primary me-1 mb-1" style="font-size: 0.75em; padding: 2px 6px;">${name}</a>`
                ).join('') : '';

                html += `
                    <tr class="pipeline-row"
                        data-name="${pipeline.name.toLowerCase()}"
                        data-description="${(pipeline.description || '').toLowerCase()}"
                        data-cluster="${(pipeline.cluster || '').toLowerCase()}"
                        data-tags="${(pipeline.tags || []).join(',').toLowerCase()}">
                        <td class="col-name"><strong>${pipeline.name}</strong></td>
                        <td class="col-desc">${pipeline.description || ''}</td>
                        <td class="col-schedule"><code class="text-success">${pipeline.schedule || ''}</code></td>
                        <td class="col-sources">${inputSources}</td>
                        <td class="col-sources">${outputSources}</td>
                        <td class="col-cluster">${cluster}</td>
                        <td class="col-tags">${tags}</td>
                        <td class="col-links">${links}</td>
                    </tr>
                `;
            });

            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        function renderDatasources() {
            if (!currentConfig || !currentConfig.pipelines) {
                const container = document.getElementById('datasources-table-container');
                container.innerHTML = '<p class="text-muted text-center">Load a configuration to see your data sources</p>';
                return;
            }
        
            const allDataSources = new Map();
            
            if (currentConfig.datasources) {
                currentConfig.datasources.forEach(ds => {
                    allDataSources.set(ds.name, ds);
                });
            }
            
            currentConfig.pipelines.forEach(pipeline => {
                pipeline.input_sources?.forEach(sourceName => {
                    if (!allDataSources.has(sourceName)) {
                        allDataSources.set(sourceName, { 
                            name: sourceName, 
                            type: 'auto-created',
                            description: 'Auto-created from pipeline references',
                            isAutoCreated: true
                        });
                    }
                });
                pipeline.output_sources?.forEach(sourceName => {
                    if (!allDataSources.has(sourceName)) {
                        allDataSources.set(sourceName, { 
                            name: sourceName, 
                            type: 'auto-created',
                            description: 'Auto-created from pipeline references',
                            isAutoCreated: true
                        });
                    }
                });
            });
        
            const container = document.getElementById('datasources-table-container');
            
            if (allDataSources.size === 0) {
                container.innerHTML = '<p class="text-muted text-center">No data sources found</p>';
                return;
            }
        
            let html = `
                <div class="table-container">
                <table class="table table-striped table-hover">
                    <thead>
                        <tr>
                            <th>Name & Type</th>
                            <th>Description</th>
                            <th>Owner</th>
                            <th>Metadata</th>
                            <th>Cluster</th>
                            <th>Tags</th>
                            <th>Links</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            allDataSources.forEach(ds => {
                const typeBadge = `<span class="badge badge-${ds.type || 'secondary'}">${(ds.type || 'unknown').toUpperCase()}</span>`;

                const metadata = ds.metadata ? Object.entries(ds.metadata).map(([k, v]) =>
                    `<div class="small text-muted mb-1"><span style="font-weight: 500;">${k.replace(/_/g, ' ')}:</span> ${v}</div>`
                ).join('') : '';

                const cluster = ds.cluster ?
                    `<span class="badge badge-cluster me-1 mb-1">${ds.cluster}</span>` : '';

                const tags = ds.tags?.map(t =>
                    `<span class="badge me-1 mb-1" style="background-color: #fff3cd; color: #856404; font-size: 0.85em;">${t}</span>`
                ).join('') || '';

                const links = ds.links ? Object.entries(ds.links).map(([name, url]) =>
                    `<a href="${url}" target="_blank" class="btn btn-sm btn-outline-primary me-1 mb-1" style="font-size: 0.75em; padding: 2px 6px;">${name}</a>`
                ).join('') : '';

                html += `
                    <tr class="datasource-row"
                        data-name="${ds.name.toLowerCase()}"
                        data-type="${(ds.type || '').toLowerCase()}"
                        data-cluster="${(ds.cluster || '').toLowerCase()}"
                        data-tags="${(ds.tags || []).join(',').toLowerCase()}"
                        data-search="${(ds.name + ' ' + (ds.description || '') + ' ' + (ds.owner || '')).toLowerCase()}">
                        <td class="col-name">
                            <div><strong>${ds.name}</strong></div>
                            <div>${typeBadge}</div>
                        </td>
                        <td class="col-desc">${ds.isAutoCreated ? `<span class="text-secondary fst-italic">${ds.description}</span>` : (ds.description || '')}</td>
                        <td class="col-owner small text-muted">${ds.owner || ''}</td>
                        <td class="col-metadata">${metadata}</td>
                        <td class="col-cluster">${cluster}</td>
                        <td class="col-tags">${tags}</td>
                        <td class="col-links">${links}</td>
                    </tr>
                `;
            });

            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        // Store active filters
        const activeFilters = {
            pipelineTags: new Set(),
            pipelineClusters: new Set(),
            datasourceTypes: new Set(),
            datasourceTags: new Set(),
            datasourceClusters: new Set()
        };

        function updateFilters() {
            if (!currentConfig) return;

            // Pipeline filters
            const pipelineTags = [...new Set(currentConfig.pipelines?.flatMap(p => p.tags || []) || [])].sort();
            const pipelineClusters = [...new Set(currentConfig.pipelines?.map(p => p.cluster).filter(c => c) || [])].sort();

            let pipelineHtml = '';
            if (pipelineClusters.length) {
                pipelineHtml += '<span class="filter-group"><span class="filter-group-label">cluster:</span>';
                pipelineHtml += pipelineClusters.map(c =>
                    `<span class="filter-tag" data-type="pipelineClusters" data-value="${c}">${c}</span>`
                ).join('');
                pipelineHtml += '</span>';
            }
            if (pipelineTags.length) {
                pipelineHtml += '<span class="filter-group"><span class="filter-group-label">tag:</span>';
                pipelineHtml += pipelineTags.map(t =>
                    `<span class="filter-tag" data-type="pipelineTags" data-value="${t}">${t}</span>`
                ).join('');
                pipelineHtml += '</span>';
            }
            document.getElementById('pipeline-filters').innerHTML = pipelineHtml;

            // Datasource filters
            const datasourceTypes = [...new Set(currentConfig.datasources?.map(ds => ds.type || 'unknown') || [])].sort();
            const datasourceTags = [...new Set(currentConfig.datasources?.flatMap(ds => ds.tags || []) || [])].sort();
            const datasourceClusters = [...new Set(currentConfig.datasources?.map(ds => ds.cluster).filter(c => c) || [])].sort();

            let datasourceHtml = '';
            if (datasourceTypes.length) {
                datasourceHtml += '<span class="filter-group"><span class="filter-group-label">type:</span>';
                datasourceHtml += datasourceTypes.map(t =>
                    `<span class="filter-tag" data-type="datasourceTypes" data-value="${t}">${t}</span>`
                ).join('');
                datasourceHtml += '</span>';
            }
            if (datasourceClusters.length) {
                datasourceHtml += '<span class="filter-group"><span class="filter-group-label">cluster:</span>';
                datasourceHtml += datasourceClusters.map(c =>
                    `<span class="filter-tag" data-type="datasourceClusters" data-value="${c}">${c}</span>`
                ).join('');
                datasourceHtml += '</span>';
            }
            if (datasourceTags.length) {
                datasourceHtml += '<span class="filter-group"><span class="filter-group-label">tag:</span>';
                datasourceHtml += datasourceTags.map(t =>
                    `<span class="filter-tag" data-type="datasourceTags" data-value="${t}">${t}</span>`
                ).join('');
                datasourceHtml += '</span>';
            }
            document.getElementById('datasource-filters').innerHTML = datasourceHtml;

            // Add click handlers
            document.querySelectorAll('.filter-tag').forEach(tag => {
                tag.addEventListener('click', function() {
                    const type = this.dataset.type;
                    const value = this.dataset.value;
                    if (activeFilters[type].has(value)) {
                        activeFilters[type].delete(value);
                        this.classList.remove('active');
                    } else {
                        activeFilters[type].add(value);
                        this.classList.add('active');
                    }
                    if (type.startsWith('pipeline')) {
                        filterPipelines();
                    } else {
                        filterDatasources();
                    }
                });
            });
        }

        function filterPipelines() {
            const searchTerm = document.getElementById('pipeline-search').value.toLowerCase();
            const rows = document.querySelectorAll('.pipeline-row');

            rows.forEach(row => {
                const name = row.getAttribute('data-name');
                const description = row.getAttribute('data-description');
                const tags = row.getAttribute('data-tags').split(',').filter(t => t);
                const cluster = row.getAttribute('data-cluster');

                const matchesSearch = !searchTerm || name.includes(searchTerm) || description.includes(searchTerm);
                const matchesTag = activeFilters.pipelineTags.size === 0 || tags.some(t => activeFilters.pipelineTags.has(t));
                const matchesCluster = activeFilters.pipelineClusters.size === 0 || activeFilters.pipelineClusters.has(cluster);

                row.style.display = (matchesSearch && matchesTag && matchesCluster) ? '' : 'none';
            });
        }

        function filterDatasources() {
            const searchTerm = document.getElementById('datasource-search').value.toLowerCase();
            const rows = document.querySelectorAll('.datasource-row');

            rows.forEach(row => {
                const searchContent = row.getAttribute('data-search');
                const type = row.getAttribute('data-type');
                const tags = row.getAttribute('data-tags').split(',').filter(t => t);
                const cluster = row.getAttribute('data-cluster');

                const matchesSearch = !searchTerm || searchContent.includes(searchTerm);
                const matchesType = activeFilters.datasourceTypes.size === 0 || activeFilters.datasourceTypes.has(type);
                const matchesTag = activeFilters.datasourceTags.size === 0 || tags.some(t => activeFilters.datasourceTags.has(t));
                const matchesCluster = activeFilters.datasourceClusters.size === 0 || activeFilters.datasourceClusters.has(cluster);

                row.style.display = (matchesSearch && matchesType && matchesTag && matchesCluster) ? '' : 'none';
            });
        }

        function generateGraphvizDot() {
            if (!currentConfig) return '';

            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const edgeColor = isDark ? '#b0b0b0' : '#555';

            let pipelines = currentConfig.pipelines || [];
            const datasources = currentConfig.datasources || [];
            const explicitClusters = currentConfig.clusters || [];

            // Handle grouped view - aggregate pipelines by group (unless expanded)
            if (groupedView) {
                const groups = new Map();
                const ungroupedPipelines = [];

                pipelines.forEach(p => {
                    if (p.group && !expandedGroups.has(p.group)) {
                        // Only group if not expanded
                        if (!groups.has(p.group)) {
                            groups.set(p.group, {
                                name: p.group,
                                description: `Grouped pipelines: ${p.group}`,
                                input_sources: new Set(),
                                output_sources: new Set(),
                                cluster: p.cluster,
                                _isGroup: true,
                                _members: []
                            });
                        }
                        const group = groups.get(p.group);
                        p.input_sources?.forEach(s => group.input_sources.add(s));
                        p.output_sources?.forEach(s => group.output_sources.add(s));
                        group._members.push(p.name);
                    } else {
                        ungroupedPipelines.push(p);
                    }
                });

                // Convert groups to pipeline-like objects
                const groupedPipelines = Array.from(groups.values()).map(g => ({
                    ...g,
                    input_sources: Array.from(g.input_sources),
                    output_sources: Array.from(g.output_sources)
                }));

                pipelines = [...ungroupedPipelines, ...groupedPipelines];
            }
        
            // Collect ALL data sources (explicit + auto-created from pipeline references)
            const allDataSources = new Map();
            
            // Add explicit data sources
            datasources.forEach(ds => {
                allDataSources.set(ds.name, ds);
            });
            
            // Add auto-created data sources from pipeline input/output references
            pipelines.forEach(pipeline => {
                pipeline.input_sources?.forEach(sourceName => {
                    if (!allDataSources.has(sourceName)) {
                        allDataSources.set(sourceName, { 
                            name: sourceName, 
                            type: 'auto-created'
                            // No cluster assignment - let auto-created sources be unclustered
                        });
                    }
                });
                pipeline.output_sources?.forEach(sourceName => {
                    if (!allDataSources.has(sourceName)) {
                        allDataSources.set(sourceName, { 
                            name: sourceName, 
                            type: 'auto-created'
                            // No cluster assignment - let auto-created sources be unclustered
                        });
                    }
                });
            });
        
            // Collect all clusters mentioned in pipelines and datasources
            const allClusterNames = new Set();
            pipelines.forEach(p => { if (p.cluster) allClusterNames.add(p.cluster); });
            allDataSources.forEach(ds => { if (ds.cluster) allClusterNames.add(ds.cluster); });
        
            // Build cluster hierarchy
            const clusterDefinitions = new Map();
            const clusterHierarchy = new Map(); // child -> parent
            const clusterChildren = new Map(); // parent -> [children]
        
            // Process explicit clusters
            explicitClusters.forEach(cluster => {
                clusterDefinitions.set(cluster.name, cluster);
                allClusterNames.add(cluster.name);
        
                if (cluster.parent) {
                    clusterHierarchy.set(cluster.name, cluster.parent);
                    if (!clusterChildren.has(cluster.parent)) {
                        clusterChildren.set(cluster.parent, []);
                    }
                    clusterChildren.get(cluster.parent).push(cluster.name);
                    allClusterNames.add(cluster.parent); // Ensure parent exists
                }
            });
        
            // Add implicit clusters (those referenced but not explicitly defined)
            allClusterNames.forEach(name => {
                if (!clusterDefinitions.has(name)) {
                    clusterDefinitions.set(name, { name, description: `Auto-generated cluster: ${name}` });
                }
            });
        
            let dot = `digraph PipevizGraph {
            rankdir=LR;
            bgcolor="transparent";
            node [fontsize=12];
            edge [fontsize=10];
        
        `;
        
            // Generate cluster colors automatically
            const clusterColors = [
                "#1976d2", "#7b1fa2", "#388e3c", "#f57c00", "#d32f2f",
                "#1976d2", "#616161", "#c2185b", "#303f9f", "#f57c00"
            ];
        
            // Group nodes by cluster
            const nodesByCluster = new Map();
        
            pipelines.forEach(pipeline => {
                const cluster = pipeline.cluster || '_unclustered';
                if (!nodesByCluster.has(cluster)) {
                    nodesByCluster.set(cluster, []);
                }
                nodesByCluster.get(cluster).push({ type: 'pipeline', node: pipeline });
            });
        
            // Use ALL data sources (explicit + auto-created)
            allDataSources.forEach(ds => {
                const cluster = ds.cluster || '_unclustered';
                if (!nodesByCluster.has(cluster)) {
                    nodesByCluster.set(cluster, []);
                }
                nodesByCluster.get(cluster).push({ type: 'datasource', node: ds });
            });
        
            // Find root clusters (those without parents)
            const rootClusters = [];
            clusterDefinitions.forEach((cluster, name) => {
                if (!clusterHierarchy.has(name) && nodesByCluster.has(name)) {
                    rootClusters.push(name);
                }
            });
        
            let colorIndex = 0;
        
            function renderCluster(clusterName, depth = 0) {
                const cluster = clusterDefinitions.get(clusterName);
                if (!cluster) return '';
        
                const nodesInCluster = nodesByCluster.get(clusterName) || [];
                const children = clusterChildren.get(clusterName) || [];
        
                // Skip if cluster has no nodes and no children with nodes
                const hasNodes = nodesInCluster.length > 0;
                const hasChildrenWithNodes = children.some(child =>
                    nodesByCluster.has(child) && nodesByCluster.get(child).length > 0
                );
        
                if (!hasNodes && !hasChildrenWithNodes) return '';
        
                const clusterColor = clusterColors[colorIndex % clusterColors.length];
                colorIndex++;
        
                let result = `${'    '.repeat(depth + 1)}subgraph cluster_${clusterName.replace(/[^a-zA-Z0-9]/g, '_')} {
        ${'    '.repeat(depth + 2)}label="${clusterName}";
        ${'    '.repeat(depth + 2)}style="dotted";
        ${'    '.repeat(depth + 2)}color="#666666";
        ${'    '.repeat(depth + 2)}fontsize=11;
        ${'    '.repeat(depth + 2)}fontname="Arial";
        
        `;
        
                // Add nodes in this cluster
                nodesInCluster.forEach(item => {
                    if (item.type === 'pipeline') {
                        const pipeline = item.node;
                        const isGroup = pipeline._isGroup;
                        const memberCount = pipeline._members?.length || 0;
                        const label = isGroup ?
                            `<${pipeline.name}<BR/><FONT POINT-SIZE="9" COLOR="#666">(${memberCount} pipelines)</FONT>>` :
                            (pipeline.schedule ?
                                `<${pipeline.name}<BR/><FONT POINT-SIZE="9" COLOR="#d63384"><I>${pipeline.schedule}</I></FONT>>` :
                                `"${pipeline.name}"`);
                        const fillColor = isGroup ? '#fff3e0' : '#e3f2fd';
                        const borderColor = isGroup ? '#ef6c00' : '#1976d2';
                        const penWidth = isGroup ? '2' : '1';
                        result += `${'    '.repeat(depth + 2)}"${pipeline.name}" [shape=box, style="filled,rounded",
        ${'    '.repeat(depth + 3)}fillcolor="${fillColor}", color="${borderColor}", penwidth=${penWidth},
        ${'    '.repeat(depth + 3)}fontname="Arial",
        ${'    '.repeat(depth + 3)}label=${label}];
        `;
                    } else if (item.type === 'datasource') {
                        const ds = item.node;
                        result += `${'    '.repeat(depth + 2)}"${ds.name}" [shape=ellipse, style=filled,
        ${'    '.repeat(depth + 3)}fillcolor="#f3e5f5", color="#7b1fa2",
        ${'    '.repeat(depth + 3)}fontname="Arial", fontsize=10];
        `;
                    }
                });
        
                // Add child clusters
                children.forEach(childName => {
                    result += renderCluster(childName, depth + 1);
                });
        
                result += `${'    '.repeat(depth + 1)}}
        
        `;
                return result;
            }
        
            // Render all root clusters
            rootClusters.forEach(clusterName => {
                dot += renderCluster(clusterName);
            });
        
            // Add unclustered nodes
            const unclusteredNodes = nodesByCluster.get('_unclustered') || [];
            unclusteredNodes.forEach(item => {
                if (item.type === 'pipeline') {
                    const pipeline = item.node;
                    const isGroup = pipeline._isGroup;
                    const memberCount = pipeline._members?.length || 0;
                    const label = isGroup ?
                        `<${pipeline.name}<BR/><FONT POINT-SIZE="9" COLOR="#666">(${memberCount} pipelines)</FONT>>` :
                        (pipeline.schedule ?
                            `<${pipeline.name}<BR/><FONT POINT-SIZE="9" COLOR="#d63384"><I>${pipeline.schedule}</I></FONT>>` :
                            `"${pipeline.name}"`);
                    const fillColor = isGroup ? '#fff3e0' : '#e3f2fd';
                    const borderColor = isGroup ? '#ef6c00' : '#1976d2';
                    const penWidth = isGroup ? '2' : '1';
                    dot += `    "${pipeline.name}" [shape=box, style="filled,rounded",
                fillcolor="${fillColor}", color="${borderColor}", penwidth=${penWidth},
                fontname="Arial",
                label=${label}];
        `;
                } else if (item.type === 'datasource') {
                    const ds = item.node;
                    dot += `    "${ds.name}" [shape=ellipse, style=filled,
                fillcolor="#f3e5f5", color="#7b1fa2",
                fontname="Arial", fontsize=10];
        `;
                }
            });
        
            // Add data flow edges
            dot += '\n';
            pipelines.forEach(pipeline => {
                pipeline.input_sources?.forEach(source => {
                    dot += `    "${source}" -> "${pipeline.name}" [color="${edgeColor}", arrowsize=0.8];\n`;
                });
                pipeline.output_sources?.forEach(source => {
                    dot += `    "${pipeline.name}" -> "${source}" [color="${edgeColor}", arrowsize=0.8];\n`;
                });
            });
        
            // Add pipeline dependencies
            dot += '\n';
            pipelines.forEach(pipeline => {
                pipeline.upstream_pipelines?.forEach(upstream => {
                    dot += `    "${upstream}" -> "${pipeline.name}" [color="#ff6b35", style="solid", arrowsize=0.8];\n`;
                });
            });
        
            dot += '\n    overlap=false; splines=true;\n}';
            return dot;
        }



        function renderGraph() {
            if (!currentConfig) return;

            document.getElementById('graph-tab').addEventListener('shown.bs.tab', function() {
                if (!graphviz) {
                    setTimeout(initializeGraph, 100);
                } else {
                    // Force re-render when tab is shown
                    updateGraph();
                }
            });

            if (document.getElementById('graph-tab').classList.contains('active')) {
                setTimeout(initializeGraph, 100);
            }
        }

        function initializeGraph() {
            try {
                // Clear loading indicator
                document.getElementById('graph').innerHTML = '';
                graphviz = d3.select("#graph").graphviz()
                    .width(document.getElementById('graph').clientWidth)
                    .height(500)
                    .fit(true)
                    .on("initEnd", setupGraphInteractivity)
                    .on("renderEnd", setupGraphInteractivity);
                updateGraph();
            } catch (error) {
                console.error('Graphviz initialization error:', error);
                // Fallback: show DOT code in graph area
                document.getElementById('graph').innerHTML = `
                    <div class="alert alert-warning m-3">
                        <strong>Graph rendering issue detected.</strong><br>
                        Please check the Raw DOT tab to see the generated code.<br>
                        <small>Error: ${error.message}</small>
                    </div>
                `;
            }
        }

        function updateGraph() {
            if (graphviz) {
                const dotSrc = generateGraphvizDot();
                graphviz.renderDot(dotSrc);
            }
        }

        function setupGraphInteractivity() {
            // Build and cache lineage maps once on render
            cachedUpstreamMap = {};
            cachedDownstreamMap = {};
            cachedLineage = {};

            d3.select("#graph").selectAll(".edge").each(function() {
                const edge = d3.select(this);
                const title = edge.select("title").text();
                const match = title.match(/^(.+?)(?:->|--)\s*(.+?)$/);
                if (match) {
                    const source = match[1];
                    const target = match[2];
                    if (!cachedDownstreamMap[source]) cachedDownstreamMap[source] = [];
                    if (!cachedUpstreamMap[target]) cachedUpstreamMap[target] = [];
                    cachedDownstreamMap[source].push(target);
                    cachedUpstreamMap[target].push(source);
                }
            });

            // Pre-compute full lineage for all nodes with distance
            function getFullChain(node, map, visited = new Set(), depth = 1) {
                if (visited.has(node)) return [];
                visited.add(node);
                const neighbors = map[node] || [];
                let result = [];
                neighbors.forEach(n => {
                    result.push({ name: n, depth: depth });
                    result.push(...getFullChain(n, map, visited, depth + 1));
                });
                return result;
            }

            d3.select("#graph").selectAll(".node").each(function() {
                const nodeName = d3.select(this).select("title").text();
                cachedLineage[nodeName] = {
                    upstream: getFullChain(nodeName, cachedUpstreamMap, new Set()),
                    downstream: getFullChain(nodeName, cachedDownstreamMap, new Set())
                };
            });

            if (document.getElementById('node-tooltip')) {
                document.getElementById('node-tooltip').remove();
            }
            const tooltip = document.createElement('div');
            tooltip.id = 'node-tooltip';
            tooltip.className = 'node-tooltip';
            tooltip.style.display = 'none';
            document.body.appendChild(tooltip);

            d3.select("#graph").selectAll(".node")
                .style("cursor", "pointer")
                .on("click", function(event, d) {
                    event.stopPropagation();
                    const nodeName = d3.select(this).select("title").text();
                    selectNode(nodeName, this);
                })
                .on("dblclick", function(event, d) {
                    event.stopPropagation();
                    const nodeName = d3.select(this).select("title").text();
                    // Check if this is a group node
                    if (groupedView && currentConfig?.pipelines) {
                        const isGroupNode = currentConfig.pipelines.some(p => p.group === nodeName);
                        if (isGroupNode) {
                            toggleGroup(nodeName);
                        }
                    }
                })
                .on("mouseover", function(event, d) {
                    const nodeName = d3.select(this).select("title").text();
                    showNodeTooltip(event, nodeName);
                })
                .on("mousemove", function(event, d) {
                    tooltip.style.left = (event.pageX + 10) + 'px';
                    tooltip.style.top = (event.pageY - 10) + 'px';
                })
                .on("mouseout", function(event, d) {
                    hideNodeTooltip();
                });

            d3.select("#graph").on("click", function(event) {
                // Check if clicked on background
                if (event.target.tagName === "svg" || event.target === event.currentTarget || 
                    event.target.classList.contains('graph-container') || 
                    !event.target.closest('.node')) {
                    clearSelection();
                }
            });
        }

        function showNodeTooltip(event, nodeName) {
            const tooltip = document.getElementById('node-tooltip');
            if (!tooltip || !currentConfig) return;

            let content = '';

            // Check if this is a group node
            if (groupedView) {
                const groupMembers = currentConfig.pipelines?.filter(p => p.group === nodeName);
                if (groupMembers?.length > 0) {
                    content = `${nodeName} (${groupMembers.length} pipelines)`;
                    content += `\nClick for details`;
                    content += `\nMembers: ${groupMembers.map(p => p.name).join(', ')}`;
                    tooltip.textContent = content;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (event.pageX + 10) + 'px';
                    tooltip.style.top = (event.pageY - 10) + 'px';
                    return;
                }
            }

            const pipeline = currentConfig.pipelines?.find(p => p.name === nodeName);
            if (pipeline) {
                content = `${pipeline.name}`;
                if (pipeline.description) content += `\nDescription: ${pipeline.description}`;
                if (pipeline.schedule) content += `\nSchedule: ${pipeline.schedule}`;
                if (pipeline.cluster) content += `\nCluster: ${pipeline.cluster}`;
                if (pipeline.tags && pipeline.tags.length > 0) content += `\nTags: ${pipeline.tags.join(', ')}`;
                if (pipeline.input_sources && pipeline.input_sources.length > 0) content += `\nInputs: ${pipeline.input_sources.join(', ')}`;
                if (pipeline.output_sources && pipeline.output_sources.length > 0) content += `\nOutputs: ${pipeline.output_sources.join(', ')}`;
            }

            const datasource = currentConfig.datasources?.find(ds => ds.name === nodeName);
            if (datasource) {
                content = `${datasource.name}`;
                if (datasource.type) content += `\nType: ${datasource.type.toUpperCase()}`;
                if (datasource.description) content += `\nDescription: ${datasource.description}`;
                if (datasource.owner) content += `\nOwner: ${datasource.owner}`;
                if (datasource.cluster) content += `\nCluster: ${datasource.cluster}`;
                if (datasource.tags && datasource.tags.length > 0) content += `\nTags: ${datasource.tags.join(', ')}`;

                if (datasource.metadata) {
                    const keyFields = ['size', 'record_count', 'refresh_frequency', 'environment'];
                    keyFields.forEach(field => {
                        if (datasource.metadata[field]) {
                            content += `\n${field.replace(/_/g, ' ')}: ${datasource.metadata[field]}`;
                        }
                    });
                }
            }

            if (content) {
                tooltip.textContent = content;
                tooltip.style.display = 'block';
                tooltip.style.left = (event.pageX + 10) + 'px';
                tooltip.style.top = (event.pageY - 10) + 'px';
            }
        }

        function hideNodeTooltip() {
            const tooltip = document.getElementById('node-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        function selectNode(nodeName, nodeElement) {
            selectedNode = nodeName;
            clearHighlights();
            d3.select(nodeElement).classed("node-highlighted", true);

            // Use cached lineage for performance
            const lineage = cachedLineage[nodeName] || { upstream: [], downstream: [] };
            const upstream = lineage.upstream;
            const downstream = lineage.downstream;
            const allConnected = new Set([...upstream.map(x => x.name), ...downstream.map(x => x.name)]);

            // Highlight connected nodes
            d3.select("#graph").selectAll(".node").each(function() {
                const node = d3.select(this);
                const nodeTitle = node.select("title").text();
                if (allConnected.has(nodeTitle)) {
                    node.classed("node-connected", true);
                } else if (nodeTitle !== nodeName) {
                    node.classed("node-dimmed", true);
                }
            });

            // Highlight edges in the chain
            d3.select("#graph").selectAll(".edge").each(function() {
                const edge = d3.select(this);
                const title = edge.select("title").text();
                const match = title.match(/^(.+?)(?:->|--)\s*(.+?)$/);
                if (match) {
                    const source = match[1];
                    const target = match[2];
                    const sourceInChain = source === nodeName || allConnected.has(source);
                    const targetInChain = target === nodeName || allConnected.has(target);
                    if (sourceInChain && targetInChain) {
                        edge.classed("edge-highlighted", true);
                    } else {
                        edge.classed("edge-dimmed", true);
                    }
                }
            });

            // Show node details in side panel
            showNodeDetails(nodeName, upstream, downstream);
        }

        function showNodeDetails(nodeName, upstream = [], downstream = []) {
            const col = document.getElementById('node-details-col');
            const content = document.getElementById('node-details-content');

            if (!currentConfig) return;

            let html = '';
            let nodeData = null;
            let nodeType = '';

            // Check if it's a pipeline
            const pipeline = currentConfig.pipelines?.find(p => p.name === nodeName);
            if (pipeline) {
                nodeData = pipeline;
                nodeType = 'Pipeline';
            }

            // Check if it's a pipeline group (in grouped view mode)
            if (!nodeData && groupedView) {
                const groupMembers = currentConfig.pipelines?.filter(p => p.group === nodeName);
                if (groupMembers?.length > 0) {
                    const allInputs = new Set();
                    const allOutputs = new Set();
                    groupMembers.forEach(p => {
                        p.input_sources?.forEach(s => allInputs.add(s));
                        p.output_sources?.forEach(s => allOutputs.add(s));
                    });
                    nodeData = {
                        name: nodeName,
                        description: `Group containing ${groupMembers.length} pipelines`,
                        input_sources: Array.from(allInputs),
                        output_sources: Array.from(allOutputs),
                        cluster: groupMembers[0].cluster,
                        _members: groupMembers.map(p => p.name)
                    };
                    nodeType = 'Pipeline Group';
                }
            }

            // Check if it's a datasource
            const datasource = currentConfig.datasources?.find(ds => ds.name === nodeName);
            if (datasource) {
                nodeData = datasource;
                nodeType = 'Data Source';
            }

            // Check auto-created datasources
            if (!nodeData) {
                const allSources = new Set();
                currentConfig.pipelines?.forEach(p => {
                    p.input_sources?.forEach(s => allSources.add(s));
                    p.output_sources?.forEach(s => allSources.add(s));
                });
                if (allSources.has(nodeName)) {
                    nodeData = { name: nodeName, description: 'Auto-created from pipeline references' };
                    nodeType = 'Data Source';
                }
            }

            if (!nodeData) {
                col.style.display = 'none';
                return;
            }

            html = `<h5>${nodeData.name}</h5>`;
            html += `<div class="detail-label">Type</div>`;
            html += `<div class="detail-value"><span class="badge bg-secondary">${nodeType}</span></div>`;

            // Add expand/collapse button for pipeline groups
            if (nodeType === 'Pipeline Group') {
                const isExpanded = expandedGroups.has(nodeName);
                html += `<div class="mt-2 mb-2">
                    <button class="btn btn-sm btn-outline-warning" onclick="toggleGroup('${nodeName}')">
                        ${isExpanded ? 'Collapse Group' : 'Expand Group'}
                    </button>
                </div>`;
            }

            // Add collapse button for pipelines that belong to an expanded group
            if (nodeType === 'Pipeline' && nodeData.group && expandedGroups.has(nodeData.group)) {
                html += `<div class="mt-2 mb-2">
                    <button class="btn btn-sm btn-outline-secondary" onclick="toggleGroup('${nodeData.group}')">
                        Collapse Group (${nodeData.group})
                    </button>
                </div>`;
            }

            if (nodeData.description) {
                html += `<div class="detail-label">Description</div>`;
                html += `<div class="detail-value">${nodeData.description}</div>`;
            }

            if (nodeData.schedule) {
                html += `<div class="detail-label">Schedule</div>`;
                html += `<div class="detail-value"><code class="text-success">${nodeData.schedule}</code></div>`;
            }

            if (nodeData.type) {
                html += `<div class="detail-label">Source Type</div>`;
                html += `<div class="detail-value"><span class="badge badge-${nodeData.type}">${nodeData.type.toUpperCase()}</span></div>`;
            }

            if (nodeData.owner) {
                html += `<div class="detail-label">Owner</div>`;
                html += `<div class="detail-value">${nodeData.owner}</div>`;
            }

            if (nodeData.cluster) {
                html += `<div class="detail-label">Cluster</div>`;
                html += `<div class="detail-value"><span class="badge badge-cluster">${nodeData.cluster}</span></div>`;
            }

            if (nodeData.input_sources?.length) {
                html += `<div class="detail-label">Input Sources</div>`;
                html += `<div class="detail-value">${nodeData.input_sources.map(s =>
                    `<span class="badge me-1 mb-1" style="background-color: #e3f2fd; color: #1565c0;">${s}</span>`
                ).join('')}</div>`;
            }

            if (nodeData.output_sources?.length) {
                html += `<div class="detail-label">Output Sources</div>`;
                html += `<div class="detail-value">${nodeData.output_sources.map(s =>
                    `<span class="badge me-1 mb-1" style="background-color: #e8f5e8; color: #2e7d32;">${s}</span>`
                ).join('')}</div>`;
            }

            if (nodeData.upstream_pipelines?.length) {
                html += `<div class="detail-label">Upstream Pipelines</div>`;
                html += `<div class="detail-value">${nodeData.upstream_pipelines.map(p =>
                    `<span class="badge me-1 mb-1" style="background-color: #fff3e0; color: #e65100;">${p}</span>`
                ).join('')}</div>`;
            }

            if (nodeData._members?.length) {
                html += `<div class="detail-label">Member Pipelines</div>`;
                html += `<div class="detail-value">${nodeData._members.map(p =>
                    `<span class="badge me-1 mb-1" style="background-color: #fff3e0; color: #ef6c00;">${p}</span>`
                ).join('')}</div>`;
            }

            if (nodeData.tags?.length) {
                html += `<div class="detail-label">Tags</div>`;
                html += `<div class="detail-value">${nodeData.tags.map(t =>
                    `<span class="badge me-1 mb-1" style="background-color: #fff3cd; color: #856404;">${t}</span>`
                ).join('')}</div>`;
            }

            if (nodeData.metadata && Object.keys(nodeData.metadata).length) {
                html += `<div class="detail-label">Metadata</div>`;
                html += `<div class="detail-value">`;
                Object.entries(nodeData.metadata).forEach(([key, value]) => {
                    html += `<div class="small"><strong>${key.replace(/_/g, ' ')}:</strong> ${value}</div>`;
                });
                html += `</div>`;
            }

            if (nodeData.links && Object.keys(nodeData.links).length) {
                html += `<div class="links-section">`;
                html += `<div class="detail-label">Links</div>`;
                Object.entries(nodeData.links).forEach(([name, url]) => {
                    html += `<a href="${url}" target="_blank" class="btn btn-sm btn-outline-primary link-btn">${name}</a>`;
                });
                html += `</div>`;
            }

            // Categorize upstream/downstream by type, deduplicate, sort by depth
            const pipelineNames = new Set((currentConfig.pipelines || []).map(p => p.name));
            if (groupedView) {
                (currentConfig.pipelines || []).forEach(p => {
                    if (p.group) pipelineNames.add(p.group);
                });
            }

            // Deduplicate keeping lowest depth, then sort by depth
            function dedupeAndSort(items, filterFn) {
                const seen = new Map();
                items.filter(x => filterFn(x.name)).forEach(x => {
                    if (!seen.has(x.name) || seen.get(x.name).depth > x.depth) {
                        seen.set(x.name, x);
                    }
                });
                return [...seen.values()].sort((a, b) => a.depth - b.depth);
            }

            const upstreamPipelines = dedupeAndSort(upstream, n => pipelineNames.has(n));
            const upstreamSources = dedupeAndSort(upstream, n => !pipelineNames.has(n));
            const downstreamPipelines = dedupeAndSort(downstream, n => pipelineNames.has(n));
            const downstreamSources = dedupeAndSort(downstream, n => !pipelineNames.has(n));

            // Render with depth indication
            function renderLineageList(items, label) {
                if (items.length === 0) return '';
                let out = `<div class="detail-label">${label} (${items.length})</div><div class="detail-value">`;
                items.forEach(x => {
                    const indent = (x.depth - 1) * 12;
                    const opacity = Math.max(0.5, 1 - (x.depth - 1) * 0.15);
                    out += `<div class="lineage-link" data-node-name="${x.name}" style="padding-left: ${indent}px; opacity: ${opacity};">${x.name}</div>`;
                });
                out += `</div>`;
                return out;
            }

            html += renderLineageList(upstreamPipelines, 'UPSTREAM PIPELINES');
            html += renderLineageList(upstreamSources, 'UPSTREAM SOURCES');
            html += renderLineageList(downstreamPipelines, 'DOWNSTREAM PIPELINES');
            html += renderLineageList(downstreamSources, 'DOWNSTREAM SOURCES');

            // Shrink graph and show panel
            const graphCol = document.getElementById('graph-col');
            graphCol.classList.remove('col-md-12');
            graphCol.classList.add('col-md-8');
            col.style.display = 'block';
            content.innerHTML = html;

            // Add click handlers for lineage links
            content.querySelectorAll('.lineage-link').forEach(el => {
                el.addEventListener('click', function() {
                    const targetName = this.getAttribute('data-node-name');
                    if (targetName) {
                        // Find and click the node in the graph
                        d3.select("#graph").selectAll(".node").each(function() {
                            const nodeTitle = d3.select(this).select("title").text();
                            if (nodeTitle === targetName) {
                                selectNode(targetName, this);
                            }
                        });
                    }
                });
            });
        }

        function clearSelection() {
            selectedNode = null;
            clearHighlights();
            // Hide details panel and expand graph
            const col = document.getElementById('node-details-col');
            const graphCol = document.getElementById('graph-col');
            if (col) col.style.display = 'none';
            if (graphCol) {
                graphCol.classList.remove('col-md-8');
                graphCol.classList.add('col-md-12');
            }
        }

        function clearHighlights() {
            d3.select("#graph").selectAll(".node")
                .classed("node-highlighted node-connected node-dimmed", false);
            d3.select("#graph").selectAll(".edge")
                .classed("edge-highlighted edge-dimmed", false);
        }

        function fuzzyMatch(text, query) {
            text = text.toLowerCase();
            query = query.toLowerCase();

            // Direct substring match
            if (text.includes(query)) {
                return { match: true, score: query.length / text.length + 0.5 };
            }

            // Fuzzy match - all query chars must appear in order
            let queryIdx = 0;
            let score = 0;
            let lastMatchIdx = -1;

            for (let i = 0; i < text.length && queryIdx < query.length; i++) {
                if (text[i] === query[queryIdx]) {
                    score += 1;
                    // Bonus for consecutive matches
                    if (lastMatchIdx === i - 1) score += 0.5;
                    // Bonus for matching at word boundaries
                    if (i === 0 || text[i-1] === '_' || text[i-1] === '-' || text[i-1] === ' ') score += 0.3;
                    lastMatchIdx = i;
                    queryIdx++;
                }
            }

            if (queryIdx === query.length) {
                return { match: true, score: score / text.length };
            }
            return { match: false, score: 0 };
        }

        function highlightMatch(text, query) {
            const lowerText = text.toLowerCase();
            const lowerQuery = query.toLowerCase();

            // Try substring match first
            const idx = lowerText.indexOf(lowerQuery);
            if (idx !== -1) {
                return text.substring(0, idx) +
                       '<span class="result-match">' + text.substring(idx, idx + query.length) + '</span>' +
                       text.substring(idx + query.length);
            }

            // Fuzzy highlight
            let result = '';
            let queryIdx = 0;
            for (let i = 0; i < text.length; i++) {
                if (queryIdx < query.length && text[i].toLowerCase() === lowerQuery[queryIdx]) {
                    result += '<span class="result-match">' + text[i] + '</span>';
                    queryIdx++;
                } else {
                    result += text[i];
                }
            }
            return result;
        }

        function searchNodes(event) {
            const query = event.target.value.trim();
            const dropdown = document.getElementById('graph-search-results');

            if (!query || query.length < 1 || !currentConfig) {
                dropdown.classList.remove('show');
                dropdown.innerHTML = '';
                return;
            }

            const results = [];

            // Search pipelines
            currentConfig.pipelines?.forEach(p => {
                const nameMatch = fuzzyMatch(p.name, query);
                const descMatch = p.description ? fuzzyMatch(p.description, query) : { match: false, score: 0 };
                if (nameMatch.match || descMatch.match) {
                    results.push({
                        name: p.name,
                        type: 'pipeline',
                        score: Math.max(nameMatch.score * 1.5, descMatch.score) // Boost name matches
                    });
                }
            });

            // Search datasources
            currentConfig.datasources?.forEach(ds => {
                const nameMatch = fuzzyMatch(ds.name, query);
                const descMatch = ds.description ? fuzzyMatch(ds.description, query) : { match: false, score: 0 };
                if (nameMatch.match || descMatch.match) {
                    results.push({
                        name: ds.name,
                        type: 'datasource',
                        score: Math.max(nameMatch.score * 1.5, descMatch.score)
                    });
                }
            });

            // Search auto-created datasources
            const autoSources = new Set();
            currentConfig.pipelines?.forEach(p => {
                p.input_sources?.forEach(s => autoSources.add(s));
                p.output_sources?.forEach(s => autoSources.add(s));
            });
            autoSources.forEach(name => {
                if (!currentConfig.datasources?.find(ds => ds.name === name)) {
                    const nameMatch = fuzzyMatch(name, query);
                    if (nameMatch.match) {
                        results.push({
                            name: name,
                            type: 'datasource',
                            score: nameMatch.score * 1.5
                        });
                    }
                }
            });

            // Sort by score
            results.sort((a, b) => b.score - a.score);

            // Limit results
            const topResults = results.slice(0, 8);

            if (topResults.length === 0) {
                dropdown.innerHTML = '<div class="search-result-item text-muted">No matches found</div>';
                dropdown.classList.add('show');
                return;
            }

            dropdown.innerHTML = topResults.map(r => `
                <div class="search-result-item" onclick="selectSearchResult('${r.name}')">
                    <span class="result-type ${r.type}">${r.type === 'pipeline' ? 'Pipeline' : 'Source'}</span>
                    <span class="result-name">${highlightMatch(r.name, query)}</span>
                </div>
            `).join('');
            dropdown.classList.add('show');
        }

        function selectSearchResult(nodeName) {
            // Hide dropdown and clear search
            const dropdown = document.getElementById('graph-search-results');
            const searchInput = document.getElementById('graph-search');
            dropdown.classList.remove('show');
            searchInput.value = '';

            // Find and click the node in the graph
            let found = false;
            d3.select("#graph").selectAll(".node").each(function() {
                const node = d3.select(this);
                const nodeTitle = node.select("title").text();
                if (nodeTitle === nodeName) {
                    found = true;
                    selectNode(nodeName, this);
                }
            });

            if (!found) {
                // Node might not be visible, just show details
                showNodeDetails(nodeName);
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            const dropdown = document.getElementById('graph-search-results');
            const searchInput = document.getElementById('graph-search');
            if (dropdown && !dropdown.contains(e.target) && e.target !== searchInput) {
                dropdown.classList.remove('show');
            }
        });

        function fitGraph() {
            if (graphviz) graphviz.fit(true);
        }

        function resetGraph() {
            if (graphviz) graphviz.resetZoom();
        }

        function collapseAllGroups() {
            expandedGroups.clear();
            updateGraph();
        }

        function toggleGroup(groupName) {
            if (expandedGroups.has(groupName)) {
                expandedGroups.delete(groupName);
            } else {
                expandedGroups.add(groupName);
            }
            updateGraph();
            // Refresh the details panel to update the button state
            showNodeDetails(groupName);
        }

        // Attribute lineage graph
        let attributeGraphviz = null;

        function generateAttributeDot() {
            if (!currentConfig) return '';

            const datasources = currentConfig.datasources || [];
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const textColor = '#334155';
            const clusterBg = '#f1f5f9';
            const attrFill = '#ffffff';
            const attrBorder = '#94a3b8';

            let dot = `digraph AttributeLineage {
            rankdir=LR;
            bgcolor="transparent";
            nodesep=0.15;
            node [fontname="Arial" fontsize="10"];
            edge [fontsize="9" color="#94a3b8" arrowsize="0.6"];

`;

            // Create subgraphs for each datasource with attributes
            datasources.forEach(ds => {
                if (!ds.attributes || ds.attributes.length === 0) return;

                const dsId = ds.name.replace(/[^a-zA-Z0-9]/g, '_');
                dot += `    subgraph cluster_${dsId} {
                label="${ds.name}";
                style=filled;
                fillcolor="${clusterBg}";
                fontcolor="${textColor}";
                color="${attrBorder}";
                fontname="Arial";
                fontsize="11";

`;
                ds.attributes.forEach(attr => {
                    const attrId = `${dsId}__${attr.name.replace(/[^a-zA-Z0-9]/g, '_')}`;
                    const hasLineage = attr.from ? true : false;
                    const fill = hasLineage ? '#e2e8f0' : attrFill;
                    dot += `        "${attrId}" [label="${attr.name}" shape=box style="filled,rounded" fillcolor="${fill}" color="${attrBorder}" fontcolor="${textColor}" fontsize="9" height="0.3"];\n`;
                });
                dot += `    }\n\n`;
            });

            // Create edges for attribute lineage
            datasources.forEach(ds => {
                if (!ds.attributes) return;
                const dsId = ds.name.replace(/[^a-zA-Z0-9]/g, '_');

                ds.attributes.forEach(attr => {
                    if (!attr.from) return;

                    const targetId = `${dsId}__${attr.name.replace(/[^a-zA-Z0-9]/g, '_')}`;
                    const sources = Array.isArray(attr.from) ? attr.from : [attr.from];

                    sources.forEach(source => {
                        // Parse source::attribute format
                        const parts = source.split('::');
                        if (parts.length === 2) {
                            const sourceDs = parts[0].replace(/[^a-zA-Z0-9]/g, '_');
                            const sourceAttr = parts[1].replace(/[^a-zA-Z0-9]/g, '_');
                            const sourceId = `${sourceDs}__${sourceAttr}`;
                            dot += `    "${sourceId}" -> "${targetId}" [color="#7b1fa2"];\n`;
                        }
                    });
                });
            });

            dot += `}`;
            return dot;
        }

        function renderAttributeGraph() {
            if (!currentConfig) return;

            const dot = generateAttributeDot();
            if (!dot) return;

            if (!attributeGraphviz) {
                // Clear loading indicator
                document.getElementById('attribute-graph').innerHTML = '';
                attributeGraphviz = d3.select("#attribute-graph").graphviz()
                    .width(document.getElementById('attribute-graph').offsetWidth || 800)
                    .height(500)
                    .fit(true)
                    .zoom(true);
            }

            attributeGraphviz.renderDot(dot).on('end', function() {
                // Add click handlers to nodes
                d3.select('#attribute-graph').selectAll('.node').on('click', function(event) {
                    event.stopPropagation();
                    const title = d3.select(this).select('title').text();
                    if (title && attributeLineageMap[title]) {
                        selectAttribute(title);
                    }
                });

                // Click on graph background to clear selection
                d3.select('#attribute-graph svg').on('click', function(event) {
                    if (event.target.tagName === 'svg' || event.target.classList.contains('graph')) {
                        clearAttributeSelection();
                    }
                });
            });
        }

        function fitAttributeGraph() {
            if (attributeGraphviz) attributeGraphviz.fit(true);
        }

        function resetAttributeGraph() {
            if (attributeGraphviz) attributeGraphviz.resetZoom();
        }

        // Attribute lineage data structures
        let attributeLineageMap = {}; // attrId -> { upstream: [], downstream: [] }
        let selectedAttribute = null;

        function buildAttributeLineageMap() {
            attributeLineageMap = {};
            if (!currentConfig) return;

            const datasources = currentConfig.datasources || [];

            // First pass: create entries for all attributes
            datasources.forEach(ds => {
                if (!ds.attributes) return;
                const dsId = ds.name.replace(/[^a-zA-Z0-9]/g, '_');
                ds.attributes.forEach(attr => {
                    const attrId = `${dsId}__${attr.name.replace(/[^a-zA-Z0-9]/g, '_')}`;
                    attributeLineageMap[attrId] = {
                        id: attrId,
                        name: attr.name,
                        datasource: ds.name,
                        fullName: `${ds.name}::${attr.name}`,
                        upstream: [],
                        downstream: []
                    };
                });
            });

            // Second pass: build lineage relationships
            datasources.forEach(ds => {
                if (!ds.attributes) return;
                const dsId = ds.name.replace(/[^a-zA-Z0-9]/g, '_');

                ds.attributes.forEach(attr => {
                    if (!attr.from) return;
                    const targetId = `${dsId}__${attr.name.replace(/[^a-zA-Z0-9]/g, '_')}`;
                    const sources = Array.isArray(attr.from) ? attr.from : [attr.from];

                    sources.forEach(source => {
                        const parts = source.split('::');
                        if (parts.length === 2) {
                            const sourceDs = parts[0].replace(/[^a-zA-Z0-9]/g, '_');
                            const sourceAttr = parts[1].replace(/[^a-zA-Z0-9]/g, '_');
                            const sourceId = `${sourceDs}__${sourceAttr}`;

                            if (attributeLineageMap[targetId]) {
                                attributeLineageMap[targetId].upstream.push(sourceId);
                            }
                            if (attributeLineageMap[sourceId]) {
                                attributeLineageMap[sourceId].downstream.push(targetId);
                            }
                        }
                    });
                });
            });

            // Third pass: pre-compute full provenance chains with depth for each attribute
            function computeFullChain(attrId, direction, visited = new Set(), depth = 1) {
                if (visited.has(attrId)) return [];
                visited.add(attrId);
                const attr = attributeLineageMap[attrId];
                if (!attr) return [];
                const next = direction === 'upstream' ? attr.upstream : attr.downstream;
                let result = [];
                next.forEach(nextId => {
                    result.push({ id: nextId, depth: depth });
                    result.push(...computeFullChain(nextId, direction, visited, depth + 1));
                });
                return result;
            }

            Object.keys(attributeLineageMap).forEach(attrId => {
                attributeLineageMap[attrId].fullUpstream = computeFullChain(attrId, 'upstream', new Set());
                attributeLineageMap[attrId].fullDownstream = computeFullChain(attrId, 'downstream', new Set());
            });
        }

        function getFullProvenance(attrId, direction, visited = new Set()) {
            if (visited.has(attrId)) return [];
            visited.add(attrId);

            const attr = attributeLineageMap[attrId];
            if (!attr) return [];

            const next = direction === 'upstream' ? attr.upstream : attr.downstream;
            let result = [];

            next.forEach(nextId => {
                result.push(nextId);
                result.push(...getFullProvenance(nextId, direction, visited));
            });

            return result;
        }

        function selectAttribute(attrId) {
            selectedAttribute = attrId;
            const attr = attributeLineageMap[attrId];
            if (!attr) return;

            // Clear all previous highlighting first
            d3.select('#attribute-graph').selectAll('.node')
                .classed('node-highlighted', false)
                .classed('node-connected', false)
                .classed('node-dimmed', false);
            d3.select('#attribute-graph').selectAll('.edge')
                .classed('edge-highlighted', false)
                .classed('edge-dimmed', false);

            // Use cached full provenance chains for performance
            const upstream = attr.fullUpstream || [];
            const downstream = attr.fullDownstream || [];
            const allConnected = new Set([attrId, ...upstream.map(x => x.id), ...downstream.map(x => x.id)]);

            // Highlight nodes
            d3.select('#attribute-graph').selectAll('.node').each(function() {
                const node = d3.select(this);
                const title = node.select('title').text();
                if (title === attrId) {
                    node.classed('node-highlighted', true).classed('node-dimmed', false);
                } else if (allConnected.has(title)) {
                    node.classed('node-connected', true).classed('node-dimmed', false);
                } else {
                    node.classed('node-dimmed', true);
                }
            });

            // Highlight edges
            d3.select('#attribute-graph').selectAll('.edge').each(function() {
                const edge = d3.select(this);
                const title = edge.select('title').text();
                const [from, to] = title.split('->').map(s => s.trim());
                if (allConnected.has(from) && allConnected.has(to)) {
                    edge.classed('edge-highlighted', true).classed('edge-dimmed', false);
                } else {
                    edge.classed('edge-dimmed', true);
                }
            });

            // Show details panel
            showAttributeDetails(attrId, upstream, downstream);
        }

        function showAttributeDetails(attrId, upstream, downstream) {
            const attr = attributeLineageMap[attrId];
            if (!attr) return;

            const col = document.getElementById('attribute-details-col');
            const graphCol = document.getElementById('attribute-graph-col');
            const content = document.getElementById('attribute-details-content');

            graphCol.classList.remove('col-md-12');
            graphCol.classList.add('col-md-8');
            col.style.display = 'block';

            // Refit graph after layout change
            setTimeout(() => {
                if (attributeGraphviz) attributeGraphviz.fit(true);
            }, 50);

            let html = `<h5>${attr.name}</h5>`;
            html += `<div class="detail-label">DATASOURCE</div>`;
            html += `<div class="detail-value">${attr.datasource}</div>`;

            // Deduplicate and sort by depth
            function dedupeAndSort(items) {
                const seen = new Map();
                items.forEach(x => {
                    if (!seen.has(x.id) || seen.get(x.id).depth > x.depth) {
                        seen.set(x.id, x);
                    }
                });
                return [...seen.values()].sort((a, b) => a.depth - b.depth);
            }

            const sortedUpstream = dedupeAndSort(upstream);
            const sortedDownstream = dedupeAndSort(downstream);

            if (sortedUpstream.length > 0) {
                html += `<div class="detail-label">UPSTREAM (${sortedUpstream.length})</div>`;
                html += `<div class="detail-value">`;
                sortedUpstream.forEach(x => {
                    const upAttr = attributeLineageMap[x.id];
                    if (upAttr) {
                        const indent = (x.depth - 1) * 12;
                        const opacity = Math.max(0.5, 1 - (x.depth - 1) * 0.15);
                        html += `<div class="lineage-link" data-attr-id="${x.id}" style="padding-left: ${indent}px; opacity: ${opacity};">${upAttr.fullName}</div>`;
                    }
                });
                html += `</div>`;
            }

            if (sortedDownstream.length > 0) {
                html += `<div class="detail-label">DOWNSTREAM (${sortedDownstream.length})</div>`;
                html += `<div class="detail-value">`;
                sortedDownstream.forEach(x => {
                    const downAttr = attributeLineageMap[x.id];
                    if (downAttr) {
                        const indent = (x.depth - 1) * 12;
                        const opacity = Math.max(0.5, 1 - (x.depth - 1) * 0.15);
                        html += `<div class="lineage-link" data-attr-id="${x.id}" style="padding-left: ${indent}px; opacity: ${opacity};">${downAttr.fullName}</div>`;
                    }
                });
                html += `</div>`;
            }

            if (sortedUpstream.length === 0 && sortedDownstream.length === 0) {
                html += `<div class="detail-value text-muted">No lineage connections</div>`;
            }

            content.innerHTML = html;

            // Add click handlers via delegation
            content.querySelectorAll('.lineage-link').forEach(el => {
                el.addEventListener('click', function() {
                    const attrId = this.getAttribute('data-attr-id');
                    if (attrId) selectAttribute(attrId);
                });
            });
        }

        function clearAttributeSelection() {
            selectedAttribute = null;

            d3.select('#attribute-graph').selectAll('.node')
                .classed('node-highlighted', false)
                .classed('node-connected', false)
                .classed('node-dimmed', false);

            d3.select('#attribute-graph').selectAll('.edge')
                .classed('edge-highlighted', false)
                .classed('edge-dimmed', false);

            const col = document.getElementById('attribute-details-col');
            const graphCol = document.getElementById('attribute-graph-col');
            col.style.display = 'none';
            graphCol.classList.remove('col-md-8');
            graphCol.classList.add('col-md-12');

            // Refit graph after layout change
            setTimeout(() => {
                if (attributeGraphviz) attributeGraphviz.fit(true);
            }, 50);
        }

        function searchAttributes(event) {
            const query = event.target.value.toLowerCase().trim();
            const resultsDiv = document.getElementById('attribute-search-results');

            if (query.length < 2) {
                resultsDiv.classList.remove('show');
                return;
            }

            const matches = [];
            Object.values(attributeLineageMap).forEach(attr => {
                if (attr.fullName.toLowerCase().includes(query) || attr.name.toLowerCase().includes(query)) {
                    matches.push(attr);
                }
            });

            if (matches.length === 0) {
                resultsDiv.classList.remove('show');
                return;
            }

            let html = '';
            matches.slice(0, 10).forEach(attr => {
                html += `<div class="search-result-item" onclick="selectAttributeFromSearch('${attr.id}')">
                    <span class="result-type datasource">${attr.datasource}</span>
                    <span class="result-name">${attr.name}</span>
                </div>`;
            });

            resultsDiv.innerHTML = html;
            resultsDiv.classList.add('show');
        }

        function selectAttributeFromSearch(attrId) {
            document.getElementById('attribute-search-results').classList.remove('show');
            document.getElementById('attribute-search').value = '';
            selectAttribute(attrId);
        }

        // Close search dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('#attribute-search') && !e.target.closest('#attribute-search-results')) {
                document.getElementById('attribute-search-results')?.classList.remove('show');
            }
        });

        // Set up attributes tab listener
        document.getElementById('attributes-tab')?.addEventListener('shown.bs.tab', function() {
            setTimeout(() => {
                buildAttributeLineageMap();
                renderAttributeGraph();
            }, 100);
        });

        function updateDotView() {
            const dotOutput = document.getElementById('dot-output');
            if (currentConfig) {
                dotOutput.value = generateGraphvizDot();
            } else {
                dotOutput.value = '';
            }
        }

        function copyDotToClipboard() {
            const dotOutput = document.getElementById('dot-output');
            if (dotOutput.value) {
                navigator.clipboard.writeText(dotOutput.value).then(() => {
                    // Show temporary success message
                    const originalText = document.querySelector('#dot-pane .btn-outline-secondary').textContent;
                    const btn = document.querySelector('#dot-pane .btn-outline-secondary');
                    btn.textContent = 'Copied!';
                    btn.classList.remove('btn-outline-secondary');
                    btn.classList.add('btn-success');
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.classList.remove('btn-success');
                        btn.classList.add('btn-outline-secondary');
                    }, 2000);
                }).catch(() => {
                    // Fallback: select the text
                    dotOutput.select();
                    dotOutput.setSelectionRange(0, 99999);
                });
            }
        }

        function showSpecModal() {
            const modal = new bootstrap.Modal(document.getElementById('specModal'));
            modal.show();
        }

        function renderSplashGraph() {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const textColor = isDark ? '#e0e0e0' : '#000000';
            const dot = `digraph {
                rankdir=LR
                bgcolor="transparent"
                node [fontname="Arial" fontsize="10" fontcolor="${textColor}"]
                edge [color="#999999"]
                "raw_events" [shape=ellipse style=filled fillcolor="#f3e5f5" color="#7b1fa2"]
                "etl-job" [shape=box style="filled,rounded" fillcolor="#e3f2fd" color="#1976d2" fontname="Arial"]
                "cleaned_events" [shape=ellipse style=filled fillcolor="#f3e5f5" color="#7b1fa2"]
                "raw_events" -> "etl-job"
                "etl-job" -> "cleaned_events"
            }`;
            d3.select("#splash-graph").graphviz()
                .width(260)
                .height(110)
                .fit(true)
                .renderDot(dot);
        }

        window.addEventListener('load', function() {
            setupDragDrop();
            setupAutoProcess();
            loadFromUrl();
            renderSplashGraph();
        });
    </script>
</body>
</html>
